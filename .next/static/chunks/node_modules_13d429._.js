(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_13d429._.js", {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function disabledLog() {}
    function disableLogs() {
        if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
                configurable: !0,
                enumerable: !0,
                value: disabledLog,
                writable: !0
            };
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
            var props = {
                configurable: !0,
                enumerable: !0,
                writable: !0
            };
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        }
        0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix) try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = !0;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
            var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if ("object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    var control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x$0) {
                                    control = x$0;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x$1) {
                                control = x$1;
                            }
                            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                        }
                    } catch (sample) {
                        if (sample && control && "string" === typeof sample.stack) return [
                            sample.stack,
                            control.stack
                        ];
                    }
                    return [
                        null,
                        null
                    ];
                }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                            var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                            fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                            "function" === typeof fn && componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter)
                    }
                    break;
                }
            }
        } finally{
            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return type = describeNativeComponentFrame(type.render, !1), type;
            case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                    return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x) {}
        }
        return "";
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
        if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
            var children = config.children;
            if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
                for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren], type);
                Object.freeze && Object.freeze(children);
            } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else validateChildKeys(children, type);
        } else {
            children = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
            console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
        }
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey);
    }
    function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node)) for(var i = 0; i < node.length; i++){
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
            }
            else if (isValidElement(node)) node._store && (node._store.validated = 1);
            else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for(; !(node = i.next()).done;)isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = !0;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
                var stack = describeUnknownElementTypeFrameInDEV(element.type);
                prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
                return stack;
            };
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
    }
    var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix, suffix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/highcharts/highcharts.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
!/**
 * Highcharts JS v12.1.2 (2024-12-21)
 * @module highcharts/highcharts
 *
 * (c) 2009-2024 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */ function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? (t._Highcharts = e(), module.exports = t._Highcharts) : ("TURBOPACK unreachable", undefined);
}("undefined" == typeof window ? this : window, ()=>(()=>{
        "use strict";
        let t, e;
        var i, s, o, r, a, n, h, l, d, c, p, g, u, f, m, x, y, b = {};
        b.d = (t, e)=>{
            for(var i in e)b.o(e, i) && !b.o(t, i) && Object.defineProperty(t, i, {
                enumerable: !0,
                get: e[i]
            });
        }, b.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e);
        var v = {};
        b.d(v, {
            default: ()=>lb
        }), function(t) {
            t.SVG_NS = "http://www.w3.org/2000/svg", t.product = "Highcharts", t.version = "12.1.2", t.win = "undefined" != typeof window ? window : {}, t.doc = t.win.document, t.svg = t.doc && t.doc.createElementNS && !!t.doc.createElementNS(t.SVG_NS, "svg").createSVGRect, t.pageLang = t.doc?.documentElement?.closest("[lang]")?.lang, t.userAgent = t.win.navigator && t.win.navigator.userAgent || "", t.isChrome = t.win.chrome, t.isFirefox = -1 !== t.userAgent.indexOf("Firefox"), t.isMS = /(edge|msie|trident)/i.test(t.userAgent) && !t.win.opera, t.isSafari = !t.isChrome && -1 !== t.userAgent.indexOf("Safari"), t.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(t.userAgent), t.isWebKit = -1 !== t.userAgent.indexOf("AppleWebKit"), t.deg2rad = 2 * Math.PI / 360, t.marginNames = [
                "plotTop",
                "marginRight",
                "marginBottom",
                "plotLeft"
            ], t.noop = function() {}, t.supportsPassiveEvents = function() {
                let e = !1;
                if (!t.isMS) {
                    let i = Object.defineProperty({}, "passive", {
                        get: function() {
                            e = !0;
                        }
                    });
                    t.win.addEventListener && t.win.removeEventListener && (t.win.addEventListener("testPassive", t.noop, i), t.win.removeEventListener("testPassive", t.noop, i));
                }
                return e;
            }(), t.charts = [], t.composed = [], t.dateFormats = {}, t.seriesTypes = {}, t.symbolSizes = {}, t.chartCount = 0;
        }(i || (i = {}));
        let k = i, { charts: w, doc: M, win: S } = k;
        function T(t, e, i, s) {
            let o = e ? "Highcharts error" : "Highcharts warning";
            32 === t && (t = `${o}: Deprecated member`);
            let r = I(t), a = r ? `${o} #${t}: www.highcharts.com/errors/${t}/` : t.toString();
            if (void 0 !== s) {
                let t = "";
                r && (a += "?"), G(s, function(e, i) {
                    t += `
 - ${i}: ${e}`, r && (a += encodeURI(i) + "=" + encodeURI(e));
                }), a += t;
            }
            j(k, "displayError", {
                chart: i,
                code: t,
                message: a,
                params: s
            }, function() {
                if (e) throw Error(a);
                S.console && -1 === T.messages.indexOf(a) && console.warn(a);
            }), T.messages.push(a);
        }
        function C(t, e) {
            return parseInt(t, e || 10);
        }
        function A(t) {
            return "string" == typeof t;
        }
        function P(t) {
            let e = Object.prototype.toString.call(t);
            return "[object Array]" === e || "[object Array Iterator]" === e;
        }
        function L(t, e) {
            return !!t && "object" == typeof t && (!e || !P(t));
        }
        function O(t) {
            return L(t) && "number" == typeof t.nodeType;
        }
        function E(t) {
            let e = t && t.constructor;
            return !!(L(t, !0) && !O(t) && e && e.name && "Object" !== e.name);
        }
        function I(t) {
            return "number" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;
        }
        function D(t) {
            return null != t;
        }
        function B(t, e, i) {
            let s;
            let o = A(e) && !D(i), r = (e, i)=>{
                D(e) ? t.setAttribute(i, e) : o ? (s = t.getAttribute(i)) || "class" !== i || (s = t.getAttribute(i + "Name")) : t.removeAttribute(i);
            };
            return A(e) ? r(i, e) : G(e, r), s;
        }
        function N(t) {
            return P(t) ? t : [
                t
            ];
        }
        function z(t, e) {
            let i;
            for(i in t || (t = {}), e)t[i] = e[i];
            return t;
        }
        function R() {
            let t = arguments, e = t.length;
            for(let i = 0; i < e; i++){
                let e = t[i];
                if (null != e) return e;
            }
        }
        function W(t, e) {
            z(t.style, e);
        }
        function H(t) {
            return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));
        }
        function X(t, e) {
            return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));
        }
        (T || (T = {})).messages = [], Math.easeInOutSine = function(t) {
            return -.5 * (Math.cos(Math.PI * t) - 1);
        };
        let F = Array.prototype.find ? function(t, e) {
            return t.find(e);
        } : function(t, e) {
            let i;
            let s = t.length;
            for(i = 0; i < s; i++)if (e(t[i], i)) return t[i];
        };
        function G(t, e, i) {
            for(let s in t)Object.hasOwnProperty.call(t, s) && e.call(i || t[s], t[s], s, t);
        }
        function Y(t, e, i) {
            function s(e, i) {
                let s = t.removeEventListener;
                s && s.call(t, e, i, !1);
            }
            function o(i) {
                let o, r;
                t.nodeName && (e ? (o = {})[e] = !0 : o = i, G(o, function(t, e) {
                    if (i[e]) for(r = i[e].length; r--;)s(e, i[e][r].fn);
                }));
            }
            let r = "function" == typeof t && t.prototype || t;
            if (Object.hasOwnProperty.call(r, "hcEvents")) {
                let t = r.hcEvents;
                if (e) {
                    let r = t[e] || [];
                    i ? (t[e] = r.filter(function(t) {
                        return i !== t.fn;
                    }), s(e, i)) : (o(t), t[e] = []);
                } else o(t), delete r.hcEvents;
            }
        }
        function j(t, e, i, s) {
            if (i = i || {}, M.createEvent && (t.dispatchEvent || t.fireEvent && t !== k)) {
                let s = M.createEvent("Events");
                s.initEvent(e, !0, !0), i = z(s, i), t.dispatchEvent ? t.dispatchEvent(i) : t.fireEvent(e, i);
            } else if (t.hcEvents) {
                i.target || z(i, {
                    preventDefault: function() {
                        i.defaultPrevented = !0;
                    },
                    target: t,
                    type: e
                });
                let s = [], o = t, r = !1;
                for(; o.hcEvents;)Object.hasOwnProperty.call(o, "hcEvents") && o.hcEvents[e] && (s.length && (r = !0), s.unshift.apply(s, o.hcEvents[e])), o = Object.getPrototypeOf(o);
                r && s.sort((t, e)=>t.order - e.order), s.forEach((e)=>{
                    !1 === e.fn.call(t, i) && i.preventDefault();
                });
            }
            s && !i.defaultPrevented && s.call(t, i);
        }
        let U = function() {
            let e = Math.random().toString(36).substring(2, 9) + "-", i = 0;
            return function() {
                return "highcharts-" + (t ? "" : e) + i++;
            };
        }();
        S.jQuery && (S.jQuery.fn.highcharts = function() {
            let t = [].slice.call(arguments);
            if (this[0]) return t[0] ? (new k[A(t[0]) ? t.shift() : "Chart"](this[0], t[0], t[1]), this) : w[B(this[0], "data-highcharts-chart")];
        });
        let $ = {
            addEvent: function(t, e, i, s = {}) {
                let o = "function" == typeof t && t.prototype || t;
                Object.hasOwnProperty.call(o, "hcEvents") || (o.hcEvents = {});
                let r = o.hcEvents;
                k.Point && t instanceof k.Point && t.series && t.series.chart && (t.series.chart.runTrackerClick = !0);
                let a = t.addEventListener;
                a && a.call(t, e, i, !!k.supportsPassiveEvents && {
                    passive: void 0 === s.passive ? -1 !== e.indexOf("touch") : s.passive,
                    capture: !1
                }), r[e] || (r[e] = []);
                let n = {
                    fn: i,
                    order: "number" == typeof s.order ? s.order : 1 / 0
                };
                return r[e].push(n), r[e].sort((t, e)=>t.order - e.order), function() {
                    Y(t, e, i);
                };
            },
            arrayMax: function(t) {
                let e = t.length, i = t[0];
                for(; e--;)t[e] > i && (i = t[e]);
                return i;
            },
            arrayMin: function(t) {
                let e = t.length, i = t[0];
                for(; e--;)t[e] < i && (i = t[e]);
                return i;
            },
            attr: B,
            clamp: function(t, e, i) {
                return t > e ? t < i ? t : i : e;
            },
            clearTimeout: function(t) {
                D(t) && clearTimeout(t);
            },
            correctFloat: X,
            createElement: function(t, e, i, s, o) {
                let r = M.createElement(t);
                return e && z(r, e), o && W(r, {
                    padding: "0",
                    border: "none",
                    margin: "0"
                }), i && W(r, i), s && s.appendChild(r), r;
            },
            crisp: function(t, e = 0, i) {
                let s = e % 2 / 2, o = i ? -1 : 1;
                return (Math.round(t * o - s) + s) * o;
            },
            css: W,
            defined: D,
            destroyObjectProperties: function(t, e, i) {
                G(t, function(s, o) {
                    s !== e && s?.destroy && s.destroy(), (s?.destroy || !i) && delete t[o];
                });
            },
            diffObjects: function(t, e, i, s) {
                let o = {};
                return !function t(e, o, r, a) {
                    let n = i ? o : e;
                    G(e, function(i, h) {
                        if (!a && s && s.indexOf(h) > -1 && o[h]) {
                            i = N(i), r[h] = [];
                            for(let e = 0; e < Math.max(i.length, o[h].length); e++)o[h][e] && (void 0 === i[e] ? r[h][e] = o[h][e] : (r[h][e] = {}, t(i[e], o[h][e], r[h][e], a + 1)));
                        } else L(i, !0) && !i.nodeType ? (r[h] = P(i) ? [] : {}, t(i, o[h] || {}, r[h], a + 1), 0 !== Object.keys(r[h]).length || "colorAxis" === h && 0 === a || delete r[h]) : (e[h] !== o[h] || h in e && !(h in o)) && "__proto__" !== h && "constructor" !== h && (r[h] = n[h]);
                    });
                }(t, e, o, 0), o;
            },
            discardElement: function(t) {
                t && t.parentElement && t.parentElement.removeChild(t);
            },
            erase: function(t, e) {
                let i = t.length;
                for(; i--;)if (t[i] === e) {
                    t.splice(i, 1);
                    break;
                }
            },
            error: T,
            extend: z,
            extendClass: function(t, e) {
                let i = function() {};
                return i.prototype = new t, z(i.prototype, e), i;
            },
            find: F,
            fireEvent: j,
            getAlignFactor: (t = "")=>({
                    center: .5,
                    right: 1,
                    middle: .5,
                    bottom: 1
                })[t] || 0,
            getClosestDistance: function(t, e) {
                let i, s, o, r;
                let a = !e;
                return t.forEach((t)=>{
                    if (t.length > 1) for(r = s = t.length - 1; r > 0; r--)(o = t[r] - t[r - 1]) < 0 && !a ? (e?.(), e = void 0) : o && (void 0 === i || o < i) && (i = o);
                }), i;
            },
            getMagnitude: H,
            getNestedProperty: function(t, e) {
                let i = t.split(".");
                for(; i.length && D(e);){
                    let t = i.shift();
                    if (void 0 === t || "__proto__" === t) return;
                    if ("this" === t) {
                        let t;
                        return L(e) && (t = e["@this"]), t ?? e;
                    }
                    let s = e[t.replace(/[\\'"]/g, "")];
                    if (!D(s) || "function" == typeof s || "number" == typeof s.nodeType || s === S) return;
                    e = s;
                }
                return e;
            },
            getStyle: function t(e, i, s) {
                let o;
                if ("width" === i) {
                    let i = Math.min(e.offsetWidth, e.scrollWidth), s = e.getBoundingClientRect && e.getBoundingClientRect().width;
                    return s < i && s >= i - 1 && (i = Math.floor(s)), Math.max(0, i - (t(e, "padding-left", !0) || 0) - (t(e, "padding-right", !0) || 0));
                }
                if ("height" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, "padding-top", !0) || 0) - (t(e, "padding-bottom", !0) || 0));
                let r = S.getComputedStyle(e, void 0);
                return r && (o = r.getPropertyValue(i), R(s, "opacity" !== i) && (o = C(o))), o;
            },
            insertItem: function(t, e) {
                let i;
                let s = t.options.index, o = e.length;
                for(i = t.options.isInternal ? o : 0; i < o + 1; i++)if (!e[i] || I(s) && s < R(e[i].options.index, e[i]._i) || e[i].options.isInternal) {
                    e.splice(i, 0, t);
                    break;
                }
                return i;
            },
            isArray: P,
            isClass: E,
            isDOMElement: O,
            isFunction: function(t) {
                return "function" == typeof t;
            },
            isNumber: I,
            isObject: L,
            isString: A,
            merge: function(t, ...e) {
                let i, s = [
                    t,
                    ...e
                ], o = {}, r = function(t, e) {
                    return "object" != typeof t && (t = {}), G(e, function(i, s) {
                        "__proto__" !== s && "constructor" !== s && (!L(i, !0) || E(i) || O(i) ? t[s] = e[s] : t[s] = r(t[s] || {}, i));
                    }), t;
                };
                !0 === t && (o = s[1], s = Array.prototype.slice.call(s, 2));
                let a = s.length;
                for(i = 0; i < a; i++)o = r(o, s[i]);
                return o;
            },
            normalizeTickInterval: function(t, e, i, s, o) {
                let r, a = t;
                i = R(i, H(t));
                let n = t / i;
                for(!e && (e = o ? [
                    1,
                    1.2,
                    1.5,
                    2,
                    2.5,
                    3,
                    4,
                    5,
                    6,
                    8,
                    10
                ] : [
                    1,
                    2,
                    2.5,
                    5,
                    10
                ], !1 === s && (1 === i ? e = e.filter(function(t) {
                    return t % 1 == 0;
                }) : i <= .1 && (e = [
                    1 / i
                ]))), r = 0; r < e.length && (a = e[r], (!o || !(a * i >= t)) && (o || !(n <= (e[r] + (e[r + 1] || e[r])) / 2))); r++);
                return X(a * i, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: G,
            offset: function(t) {
                let e = M.documentElement, i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {
                    top: 0,
                    left: 0,
                    width: 0,
                    height: 0
                };
                return {
                    top: i.top + (S.pageYOffset || e.scrollTop) - (e.clientTop || 0),
                    left: i.left + (S.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),
                    width: i.width,
                    height: i.height
                };
            },
            pad: function(t, e, i) {
                return Array((e || 2) + 1 - String(t).replace("-", "").length).join(i || "0") + t;
            },
            pick: R,
            pInt: C,
            pushUnique: function(t, e) {
                return 0 > t.indexOf(e) && !!t.push(e);
            },
            relativeLength: function(t, e, i) {
                return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);
            },
            removeEvent: Y,
            replaceNested: function(t, ...e) {
                let i, s;
                do for (s of (i = t, e))t = t.replace(s[0], s[1]);
                while (t !== i)
                return t;
            },
            splat: N,
            stableSort: function(t, e) {
                let i, s;
                let o = t.length;
                for(s = 0; s < o; s++)t[s].safeI = s;
                for(t.sort(function(t, s) {
                    return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;
                }), s = 0; s < o; s++)delete t[s].safeI;
            },
            syncTimeout: function(t, e, i) {
                return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);
            },
            timeUnits: {
                millisecond: 1,
                second: 1e3,
                minute: 6e4,
                hour: 36e5,
                day: 864e5,
                week: 6048e5,
                month: 24192e5,
                year: 314496e5
            },
            ucfirst: function(t) {
                return A(t) ? t.substring(0, 1).toUpperCase() + t.substring(1) : String(t);
            },
            uniqueKey: U,
            useSerialIds: function(e) {
                return t = R(e, t);
            },
            wrap: function(t, e, i) {
                let s = t[e];
                t[e] = function() {
                    let t = arguments, e = this;
                    return i.apply(this, [
                        function() {
                            return s.apply(e, arguments.length ? arguments : t);
                        }
                    ].concat([].slice.call(arguments)));
                };
            }
        }, { pageLang: V, win: _ } = k, { defined: q, error: Z, extend: K, isNumber: J, isObject: Q, isString: tt, merge: te, objectEach: ti, pad: ts, splat: to, timeUnits: tr, ucfirst: ta } = $, tn = k.isSafari && _.Intl && !_.Intl.DateTimeFormat.prototype.formatRange, th = (t)=>void 0 === t.main, tl = (t)=>[
                "D",
                "L",
                "M",
                "X",
                "J",
                "V",
                "S"
            ].indexOf(t), td = class {
            constructor(t){
                this.options = {
                    timezone: "UTC"
                }, this.variableTimezone = !1, this.Date = _.Date, this.update(t);
            }
            update(t = {}) {
                this.dTLCache = {}, this.options = t = te(!0, this.options, t);
                let { timezoneOffset: e, useUTC: i } = t;
                this.Date = t.Date || _.Date || Date;
                let s = t.timezone;
                q(i) && (s = i ? "UTC" : void 0), e && e % 60 == 0 && (s = "Etc/GMT" + (e > 0 ? "+" : "") + e / 60), this.variableTimezone = "UTC" !== s && s?.indexOf("Etc/GMT") !== 0, this.timezone = s, [
                    "months",
                    "shortMonths",
                    "weekdays",
                    "shortWeekdays"
                ].forEach((t)=>{
                    let e = /months/i.test(t), i = /short/.test(t), s = {
                        timeZone: "UTC"
                    };
                    s[e ? "month" : "weekday"] = i ? "short" : "long", this[t] = (e ? [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ] : [
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ]).map((t)=>this.dateFormat(s, (e ? 31 : 1) * 24 * 36e5 * t));
                });
            }
            toParts(t) {
                let [e, i, s, o, r, a, n] = this.dateTimeFormat({
                    weekday: "narrow",
                    day: "numeric",
                    month: "numeric",
                    year: "numeric",
                    hour: "numeric",
                    minute: "numeric",
                    second: "numeric"
                }, t, "es").split(/(?:, |\/|:)/g);
                return [
                    o,
                    +s - 1,
                    i,
                    r,
                    a,
                    n,
                    Math.floor(Number(t) || 0) % 1e3,
                    tl(e)
                ].map(Number);
            }
            dateTimeFormat(t, e, i = this.options.locale || V) {
                let s = JSON.stringify(t) + i;
                tt(t) && (t = this.str2dtf(t));
                let o = this.dTLCache[s];
                if (!o) {
                    t.timeZone ?? (t.timeZone = this.timezone);
                    try {
                        o = new Intl.DateTimeFormat(i, t);
                    } catch (e) {
                        /Invalid time zone/i.test(e.message) ? (Z(34), t.timeZone = "UTC", o = new Intl.DateTimeFormat(i, t)) : Z(e.message, !1);
                    }
                }
                return this.dTLCache[s] = o, o?.format(e) || "";
            }
            str2dtf(t, e = {}) {
                let i = {
                    L: {
                        fractionalSecondDigits: 3
                    },
                    S: {
                        second: "2-digit"
                    },
                    M: {
                        minute: "numeric"
                    },
                    H: {
                        hour: "2-digit"
                    },
                    k: {
                        hour: "numeric"
                    },
                    E: {
                        weekday: "narrow"
                    },
                    a: {
                        weekday: "short"
                    },
                    A: {
                        weekday: "long"
                    },
                    d: {
                        day: "2-digit"
                    },
                    e: {
                        day: "numeric"
                    },
                    b: {
                        month: "short"
                    },
                    B: {
                        month: "long"
                    },
                    m: {
                        month: "2-digit"
                    },
                    o: {
                        month: "numeric"
                    },
                    y: {
                        year: "2-digit"
                    },
                    Y: {
                        year: "numeric"
                    }
                };
                return Object.keys(i).forEach((s)=>{
                    -1 !== t.indexOf(s) && K(e, i[s]);
                }), e;
            }
            makeTime(t, e, i = 1, s = 0, o, r, a) {
                let n = this.Date.UTC(t, e, i, s, o || 0, r || 0, a || 0);
                if ("UTC" !== this.timezone) {
                    let t = this.getTimezoneOffset(n);
                    if (n += t, -1 !== [
                        2,
                        3,
                        8,
                        9,
                        10,
                        11
                    ].indexOf(e) && (s < 5 || s > 20)) {
                        let e = this.getTimezoneOffset(n);
                        t !== e ? n += e - t : t - 36e5 !== this.getTimezoneOffset(n - 36e5) || tn || (n -= 36e5);
                    }
                }
                return n;
            }
            parse(t) {
                if (!tt(t)) return t ?? void 0;
                let e = (t = t.replace(/\//g, "-").replace(/(GMT|UTC)/, "")).indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(t), i = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(t);
                e || i || (t += "Z");
                let s = Date.parse(t);
                if (J(s)) return s + (!e || i ? this.getTimezoneOffset(s) : 0);
            }
            getTimezoneOffset(t) {
                if ("UTC" !== this.timezone) {
                    let [e, i, s, o, r = 0] = this.dateTimeFormat({
                        timeZoneName: "shortOffset"
                    }, t, "en").split(/(GMT|:)/).map(Number), a = -(36e5 * (s + r / 60));
                    if (J(a)) return a;
                }
                return 0;
            }
            dateFormat(t, e, i) {
                let s = k.defaultOptions?.lang;
                if (!q(e) || isNaN(e)) return s?.invalidDate || "";
                if (tt(t = t ?? "%Y-%m-%d %H:%M:%S")) {
                    let i;
                    let s = /%\[([a-zA-Z]+)\]/g;
                    for(; i = s.exec(t);)t = t.replace(i[0], this.dateTimeFormat(i[1], e));
                }
                if (tt(t) && -1 !== t.indexOf("%")) {
                    let i = this, [o, r, a, n, h, l, d, c] = this.toParts(e), p = s?.weekdays || this.weekdays, g = s?.shortWeekdays || this.shortWeekdays, u = s?.months || this.months, f = s?.shortMonths || this.shortMonths;
                    ti(K({
                        a: g ? g[c] : p[c].substr(0, 3),
                        A: p[c],
                        d: ts(a),
                        e: ts(a, 2, " "),
                        w: c,
                        b: f[r],
                        B: u[r],
                        m: ts(r + 1),
                        o: r + 1,
                        y: o.toString().substr(2, 2),
                        Y: o,
                        H: ts(n),
                        k: n,
                        I: ts(n % 12 || 12),
                        l: n % 12 || 12,
                        M: ts(h),
                        p: n < 12 ? "AM" : "PM",
                        P: n < 12 ? "am" : "pm",
                        S: ts(l),
                        L: ts(d, 3)
                    }, k.dateFormats), function(s, o) {
                        if (tt(t)) for(; -1 !== t.indexOf("%" + o);)t = t.replace("%" + o, "function" == typeof s ? s.call(i, e) : s);
                    });
                } else if (Q(t)) {
                    let i = (this.getTimezoneOffset(e) || 0) / 36e5, s = this.timezone || "Etc/GMT" + (i >= 0 ? "+" : "") + i, { prefix: o = "", suffix: r = "" } = t;
                    t = o + this.dateTimeFormat(K({
                        timeZone: s
                    }, t), e) + r;
                }
                return i ? ta(t) : t;
            }
            resolveDTLFormat(t) {
                return Q(t, !0) ? Q(t, !0) && th(t) ? {
                    main: t
                } : t : {
                    main: (t = to(t))[0],
                    from: t[1],
                    to: t[2]
                };
            }
            getTimeTicks(t, e, i, s) {
                let o = this, r = [], a = {}, { count: n = 1, unitRange: h } = t, [l, d, c, p, g, u] = o.toParts(e), f = (e || 0) % 1e3, m;
                if (s ?? (s = 1), q(e)) {
                    if (f = h >= tr.second ? 0 : n * Math.floor(f / n), h >= tr.second && (u = h >= tr.minute ? 0 : n * Math.floor(u / n)), h >= tr.minute && (g = h >= tr.hour ? 0 : n * Math.floor(g / n)), h >= tr.hour && (p = h >= tr.day ? 0 : n * Math.floor(p / n)), h >= tr.day && (c = h >= tr.month ? 1 : Math.max(1, n * Math.floor(c / n))), h >= tr.month && (d = h >= tr.year ? 0 : n * Math.floor(d / n)), h >= tr.year && (l -= l % n), h === tr.week) {
                        n && (e = o.makeTime(l, d, c, p, g, u, f));
                        let t = tl(this.dateTimeFormat({
                            timeZone: this.timezone,
                            weekday: "narrow"
                        }, e, "es"));
                        c += -t + s + (t < s ? -7 : 0);
                    }
                    e = o.makeTime(l, d, c, p, g, u, f), o.variableTimezone && q(i) && (m = i - e > 4 * tr.month || o.getTimezoneOffset(e) !== o.getTimezoneOffset(i));
                    let t = e, x = 1;
                    for(; t < i;)r.push(t), h === tr.year ? t = o.makeTime(l + x * n, 0) : h === tr.month ? t = o.makeTime(l, d + x * n) : m && (h === tr.day || h === tr.week) ? t = o.makeTime(l, d, c + x * n * (h === tr.day ? 1 : 7)) : m && h === tr.hour && n > 1 ? t = o.makeTime(l, d, c, p + x * n) : t += h * n, x++;
                    r.push(t), h <= tr.hour && r.length < 1e4 && r.forEach((t)=>{
                        t % 18e5 == 0 && "000000000" === o.dateFormat("%H%M%S%L", t) && (a[t] = "day");
                    });
                }
                return r.info = K(t, {
                    higherRanks: a,
                    totalRange: h * n
                }), r;
            }
            getDateFormat(t, e, i, s) {
                let o = this.dateFormat("%m-%d %H:%M:%S.%L", e), r = "01-01 00:00:00.000", a = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                }, n = "millisecond", h = n;
                for(n in tr){
                    if (t === tr.week && +this.dateFormat("%w", e) === i && o.substr(6) === r.substr(6)) {
                        n = "week";
                        break;
                    }
                    if (tr[n] > t) {
                        n = h;
                        break;
                    }
                    if (a[n] && o.substr(a[n]) !== r.substr(a[n])) break;
                    "week" !== n && (h = n);
                }
                return this.resolveDTLFormat(s[n]).main;
            }
        }, { isTouchDevice: tc } = k, { fireEvent: tp, merge: tg } = $, tu = {
            colors: [
                "#2caffe",
                "#544fc5",
                "#00e272",
                "#fe6a35",
                "#6b8abc",
                "#d568fb",
                "#2ee0ca",
                "#fa4b42",
                "#feb56a",
                "#91e8e1"
            ],
            symbols: [
                "circle",
                "diamond",
                "square",
                "triangle",
                "triangle-down"
            ],
            lang: {
                locale: void 0,
                loading: "Loading...",
                months: void 0,
                shortMonths: void 0,
                weekdays: void 0,
                numericSymbols: [
                    "k",
                    "M",
                    "G",
                    "T",
                    "P",
                    "E"
                ],
                resetZoom: "Reset zoom",
                resetZoomTitle: "Reset zoom level 1:1"
            },
            global: {
                buttonTheme: {
                    fill: "#f7f7f7",
                    padding: 8,
                    r: 2,
                    stroke: "#cccccc",
                    "stroke-width": 1,
                    style: {
                        color: "#333333",
                        cursor: "pointer",
                        fontSize: "0.8em",
                        fontWeight: "normal"
                    },
                    states: {
                        hover: {
                            fill: "#e6e6e6"
                        },
                        select: {
                            fill: "#e6e9ff",
                            style: {
                                color: "#000000",
                                fontWeight: "bold"
                            }
                        },
                        disabled: {
                            style: {
                                color: "#cccccc"
                            }
                        }
                    }
                }
            },
            time: {
                Date: void 0,
                timezone: "UTC",
                timezoneOffset: 0,
                useUTC: void 0
            },
            chart: {
                alignThresholds: !1,
                panning: {
                    enabled: !1,
                    type: "x"
                },
                styledMode: !1,
                borderRadius: 0,
                colorCount: 10,
                allowMutatingData: !0,
                ignoreHiddenSeries: !0,
                spacing: [
                    10,
                    10,
                    15,
                    10
                ],
                resetZoomButton: {
                    theme: {},
                    position: {}
                },
                reflow: !0,
                type: "line",
                zooming: {
                    singleTouch: !1,
                    resetButton: {
                        theme: {
                            zIndex: 6
                        },
                        position: {
                            align: "right",
                            x: -10,
                            y: 10
                        }
                    }
                },
                width: null,
                height: null,
                borderColor: "#334eff",
                backgroundColor: "#ffffff",
                plotBorderColor: "#cccccc"
            },
            title: {
                style: {
                    color: "#333333",
                    fontWeight: "bold"
                },
                text: "Chart title",
                margin: 15,
                minScale: .67
            },
            subtitle: {
                style: {
                    color: "#666666",
                    fontSize: "0.8em"
                },
                text: ""
            },
            caption: {
                margin: 15,
                style: {
                    color: "#666666",
                    fontSize: "0.8em"
                },
                text: "",
                align: "left",
                verticalAlign: "bottom"
            },
            plotOptions: {},
            legend: {
                enabled: !0,
                align: "center",
                alignColumns: !0,
                className: "highcharts-no-tooltip",
                events: {},
                layout: "horizontal",
                itemMarginBottom: 2,
                itemMarginTop: 2,
                labelFormatter: function() {
                    return this.name;
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                    style: {
                        fontSize: "0.8em"
                    },
                    activeColor: "#0022ff",
                    inactiveColor: "#cccccc"
                },
                itemStyle: {
                    color: "#333333",
                    cursor: "pointer",
                    fontSize: "0.8em",
                    textDecoration: "none",
                    textOverflow: "ellipsis"
                },
                itemHoverStyle: {
                    color: "#000000"
                },
                itemHiddenStyle: {
                    color: "#666666",
                    textDecoration: "line-through"
                },
                shadow: !1,
                itemCheckboxStyle: {
                    position: "absolute",
                    width: "13px",
                    height: "13px"
                },
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: {
                    style: {
                        fontSize: "0.8em",
                        fontWeight: "bold"
                    }
                }
            },
            loading: {
                labelStyle: {
                    fontWeight: "bold",
                    position: "relative",
                    top: "45%"
                },
                style: {
                    position: "absolute",
                    backgroundColor: "#ffffff",
                    opacity: .5,
                    textAlign: "center"
                }
            },
            tooltip: {
                enabled: !0,
                animation: {
                    duration: 300,
                    easing: (t)=>Math.sqrt(1 - Math.pow(t - 1, 2))
                },
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: "%[AebHMSL]",
                    second: "%[AebHMS]",
                    minute: "%[AebHM]",
                    hour: "%[AebHM]",
                    day: "%[AebY]",
                    week: "Week from %[AebY]",
                    month: "%[BY]",
                    year: "%Y"
                },
                footerFormat: "",
                headerShape: "callout",
                hideDelay: 500,
                padding: 8,
                shape: "callout",
                shared: !1,
                snap: tc ? 25 : 10,
                headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: "#ffffff",
                borderWidth: void 0,
                shadow: !0,
                stickOnContact: !1,
                style: {
                    color: "#333333",
                    cursor: "default",
                    fontSize: "0.8em"
                },
                useHTML: !1
            },
            credits: {
                enabled: !0,
                href: "https://www.highcharts.com?credits",
                position: {
                    align: "right",
                    x: -10,
                    verticalAlign: "bottom",
                    y: -5
                },
                style: {
                    cursor: "pointer",
                    color: "#999999",
                    fontSize: "0.6em"
                },
                text: "Highcharts.com"
            }
        }, tf = new td(tu.time), tm = {
            defaultOptions: tu,
            defaultTime: tf,
            getOptions: function() {
                return tu;
            },
            setOptions: function(t) {
                return tp(k, "setOptions", {
                    options: t
                }), tg(!0, tu, t), t.time && tf.update(tu.time), t.lang && "locale" in t.lang && tf.update({
                    locale: t.lang.locale
                }), tu;
            }
        }, { isNumber: tx, merge: ty, pInt: tb, defined: tv } = $;
        class tk {
            static parse(t) {
                return t ? new tk(t) : tk.None;
            }
            constructor(t){
                let e, i, s, o;
                this.rgba = [
                    NaN,
                    NaN,
                    NaN,
                    NaN
                ], this.input = t;
                let r = k.Color;
                if (r && r !== tk) return new r(t);
                if ("object" == typeof t && void 0 !== t.stops) this.stops = t.stops.map((t)=>new tk(t[1]));
                else if ("string" == typeof t) for(this.input = t = tk.names[t.toLowerCase()] || t, s = tk.parsers.length; s-- && !i;)(e = (o = tk.parsers[s]).regex.exec(t)) && (i = o.parse(e));
                i && (this.rgba = i);
            }
            get(t) {
                let e = this.input, i = this.rgba;
                if ("object" == typeof e && void 0 !== this.stops) {
                    let i = ty(e);
                    return i.stops = [].slice.call(i.stops), this.stops.forEach((e, s)=>{
                        i.stops[s] = [
                            i.stops[s][0],
                            e.get(t)
                        ];
                    }), i;
                }
                return i && tx(i[0]) ? "rgb" !== t && (t || 1 !== i[3]) ? "a" === t ? `${i[3]}` : "rgba(" + i.join(",") + ")" : "rgb(" + i[0] + "," + i[1] + "," + i[2] + ")" : e;
            }
            brighten(t) {
                let e = this.rgba;
                if (this.stops) this.stops.forEach(function(e) {
                    e.brighten(t);
                });
                else if (tx(t) && 0 !== t) for(let i = 0; i < 3; i++)e[i] += tb(255 * t), e[i] < 0 && (e[i] = 0), e[i] > 255 && (e[i] = 255);
                return this;
            }
            setOpacity(t) {
                return this.rgba[3] = t, this;
            }
            tweenTo(t, e) {
                let i = this.rgba, s = t.rgba;
                if (!tx(i[0]) || !tx(s[0])) return t.input || "none";
                let o = 1 !== s[3] || 1 !== i[3], r = (t, s)=>t + (i[s] - t) * (1 - e), a = s.slice(0, 3).map(r).map(Math.round);
                return o && a.push(r(s[3], 3)), (o ? "rgba(" : "rgb(") + a.join(",") + ")";
            }
        }
        tk.names = {
            white: "#ffffff",
            black: "#000000"
        }, tk.parsers = [
            {
                regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
                parse: function(t) {
                    return [
                        tb(t[1]),
                        tb(t[2]),
                        tb(t[3]),
                        parseFloat(t[4], 10)
                    ];
                }
            },
            {
                regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
                parse: function(t) {
                    return [
                        tb(t[1]),
                        tb(t[2]),
                        tb(t[3]),
                        1
                    ];
                }
            },
            {
                regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,
                parse: function(t) {
                    return [
                        tb(t[1] + t[1], 16),
                        tb(t[2] + t[2], 16),
                        tb(t[3] + t[3], 16),
                        tv(t[4]) ? tb(t[4] + t[4], 16) / 255 : 1
                    ];
                }
            },
            {
                regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,
                parse: function(t) {
                    return [
                        tb(t[1], 16),
                        tb(t[2], 16),
                        tb(t[3], 16),
                        tv(t[4]) ? tb(t[4], 16) / 255 : 1
                    ];
                }
            }
        ], tk.None = new tk("");
        let { parse: tw } = tk, { win: tM } = k, { isNumber: tS, objectEach: tT } = $;
        class tC {
            constructor(t, e, i){
                this.pos = NaN, this.options = e, this.elem = t, this.prop = i;
            }
            dSetter() {
                let t = this.paths, e = t && t[0], i = t && t[1], s = this.now || 0, o = [];
                if (1 !== s && e && i) {
                    if (e.length === i.length && s < 1) for(let t = 0; t < i.length; t++){
                        let r = e[t], a = i[t], n = [];
                        for(let t = 0; t < a.length; t++){
                            let e = r[t], i = a[t];
                            tS(e) && tS(i) && !("A" === a[0] && (4 === t || 5 === t)) ? n[t] = e + s * (i - e) : n[t] = i;
                        }
                        o.push(n);
                    }
                    else o = i;
                } else o = this.toD || [];
                this.elem.attr("d", o, void 0, !0);
            }
            update() {
                let t = this.elem, e = this.prop, i = this.now, s = this.options.step;
                this[e + "Setter"] ? this[e + "Setter"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);
            }
            run(t, e, i) {
                let s = this, o = s.options, r = function(t) {
                    return !r.stopped && s.step(t);
                }, a = tM.requestAnimationFrame || function(t) {
                    setTimeout(t, 13);
                }, n = function() {
                    for(let t = 0; t < tC.timers.length; t++)tC.timers[t]() || tC.timers.splice(t--, 1);
                    tC.timers.length && a(n);
                };
                t !== e || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date, this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, r.elem = this.elem, r.prop = this.prop, r() && 1 === tC.timers.push(r) && a(n)) : (delete o.curAnim[this.prop], o.complete && 0 === Object.keys(o.curAnim).length && o.complete.call(this.elem));
            }
            step(t) {
                let e, i;
                let s = +new Date, o = this.options, r = this.elem, a = o.complete, n = o.duration, h = o.curAnim;
                return r.attr && !r.element ? e = !1 : t || s >= n + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), h[this.prop] = !0, i = !0, tT(h, function(t) {
                    !0 !== t && (i = !1);
                }), i && a && a.call(r), e = !1) : (this.pos = o.easing((s - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;
            }
            initPath(t, e, i) {
                let s = t.startX, o = t.endX, r = i.slice(), a = t.isArea, n = a ? 2 : 1, h = e && i.length > e.length && i.hasStackedCliffs, l, d, c, p, g = e && e.slice();
                if (!g || h) return [
                    r,
                    r
                ];
                function u(t, e) {
                    for(; t.length < d;){
                        let i = t[0], s = e[d - t.length];
                        if (s && "M" === i[0] && ("C" === s[0] ? t[0] = [
                            "C",
                            i[1],
                            i[2],
                            i[1],
                            i[2],
                            i[1],
                            i[2]
                        ] : t[0] = [
                            "L",
                            i[1],
                            i[2]
                        ]), t.unshift(i), a) {
                            let e = t.pop();
                            t.push(t[t.length - 1], e);
                        }
                    }
                }
                function f(t) {
                    for(; t.length < d;){
                        let e = t[Math.floor(t.length / n) - 1].slice();
                        if ("C" === e[0] && (e[1] = e[5], e[2] = e[6]), a) {
                            let i = t[Math.floor(t.length / n)].slice();
                            t.splice(t.length / 2, 0, e, i);
                        } else t.push(e);
                    }
                }
                if (s && o && o.length) {
                    for(c = 0; c < s.length; c++){
                        if (s[c] === o[0]) {
                            l = c;
                            break;
                        }
                        if (s[0] === o[o.length - s.length + c]) {
                            l = c, p = !0;
                            break;
                        }
                        if (s[s.length - 1] === o[o.length - s.length + c]) {
                            l = s.length - c;
                            break;
                        }
                    }
                    void 0 === l && (g = []);
                }
                return g.length && tS(l) && (d = r.length + l * n, p ? (u(g, r), f(r)) : (u(r, g), f(g))), [
                    g,
                    r
                ];
            }
            fillSetter() {
                tC.prototype.strokeSetter.apply(this, arguments);
            }
            strokeSetter() {
                this.elem.attr(this.prop, tw(this.start).tweenTo(tw(this.end), this.pos), void 0, !0);
            }
        }
        tC.timers = [];
        let { defined: tA, getStyle: tP, isArray: tL, isNumber: tO, isObject: tE, merge: tI, objectEach: tD, pick: tB } = $;
        function tN(t) {
            return tE(t) ? tI({
                duration: 500,
                defer: 0
            }, t) : {
                duration: t ? 500 : 0,
                defer: 0
            };
        }
        function tz(t, e) {
            let i = tC.timers.length;
            for(; i--;)tC.timers[i].elem !== t || e && e !== tC.timers[i].prop || (tC.timers[i].stopped = !0);
        }
        let tR = {
            animate: function(t, e, i) {
                let s, o = "", r, a, n;
                tE(i) || (n = arguments, i = {
                    duration: n[2],
                    easing: n[3],
                    complete: n[4]
                }), tO(i.duration) || (i.duration = 400), i.easing = "function" == typeof i.easing ? i.easing : Math[i.easing] || Math.easeInOutSine, i.curAnim = tI(e), tD(e, function(n, h) {
                    tz(t, h), a = new tC(t, i, h), r = void 0, "d" === h && tL(e.d) ? (a.paths = a.initPath(t, t.pathArray, e.d), a.toD = e.d, s = 0, r = 1) : t.attr ? s = t.attr(h) : (s = parseFloat(tP(t, h)) || 0, "opacity" !== h && (o = "px")), r || (r = n), "string" == typeof r && r.match("px") && (r = r.replace(/px/g, "")), a.run(s, r, o);
                });
            },
            animObject: tN,
            getDeferredAnimation: function(t, e, i) {
                let s = tN(e), o = i ? [
                    i
                ] : t.series, r = 0, a = 0;
                return o.forEach((t)=>{
                    let i = tN(t.options.animation);
                    r = tE(e) && tA(e.defer) ? s.defer : Math.max(r, i.duration + i.defer), a = Math.min(s.duration, i.duration);
                }), t.renderer.forExport && (r = 0), {
                    defer: Math.max(0, r - a),
                    duration: Math.min(r, a)
                };
            },
            setAnimation: function(t, e) {
                e.renderer.globalAnimation = tB(t, e.options.chart.animation, !0);
            },
            stop: tz
        }, { SVG_NS: tW, win: tH } = k, { attr: tX, createElement: tF, css: tG, error: tY, isFunction: tj, isString: tU, objectEach: t$, splat: tV } = $, { trustedTypes: t_ } = tH, tq = t_ && tj(t_.createPolicy) && t_.createPolicy("highcharts", {
            createHTML: (t)=>t
        }), tZ = tq ? tq.createHTML("") : "";
        class tK {
            static filterUserAttributes(t) {
                return t$(t, (e, i)=>{
                    let s = !0;
                    -1 === tK.allowedAttributes.indexOf(i) && (s = !1), -1 !== [
                        "background",
                        "dynsrc",
                        "href",
                        "lowsrc",
                        "src"
                    ].indexOf(i) && (s = tU(e) && tK.allowedReferences.some((t)=>0 === e.indexOf(t))), s || (tY(33, !1, void 0, {
                        "Invalid attribute in config": `${i}`
                    }), delete t[i]), tU(e) && t[i] && (t[i] = e.replace(/</g, "&lt;"));
                }), t;
            }
            static parseStyle(t) {
                return t.split(";").reduce((t, e)=>{
                    let i = e.split(":").map((t)=>t.trim()), s = i.shift();
                    return s && i.length && (t[s.replace(/-([a-z])/g, (t)=>t[1].toUpperCase())] = i.join(":")), t;
                }, {});
            }
            static setElementHTML(t, e) {
                t.innerHTML = tK.emptyHTML, e && new tK(e).addToDOM(t);
            }
            constructor(t){
                this.nodes = "string" == typeof t ? this.parseMarkup(t) : t;
            }
            addToDOM(t) {
                return function t(e, i) {
                    let s;
                    return tV(e).forEach(function(e) {
                        let o;
                        let r = e.tagName, a = e.textContent ? k.doc.createTextNode(e.textContent) : void 0, n = tK.bypassHTMLFiltering;
                        if (r) {
                            if ("#text" === r) o = a;
                            else if (-1 !== tK.allowedTags.indexOf(r) || n) {
                                let s = "svg" === r ? tW : i.namespaceURI || tW, h = k.doc.createElementNS(s, r), l = e.attributes || {};
                                t$(e, function(t, e) {
                                    "tagName" !== e && "attributes" !== e && "children" !== e && "style" !== e && "textContent" !== e && (l[e] = t);
                                }), tX(h, n ? l : tK.filterUserAttributes(l)), e.style && tG(h, e.style), a && h.appendChild(a), t(e.children || [], h), o = h;
                            } else tY(33, !1, void 0, {
                                "Invalid tagName in config": r
                            });
                        }
                        o && i.appendChild(o), s = o;
                    }), s;
                }(this.nodes, t);
            }
            parseMarkup(t) {
                let e;
                let i = [];
                t = t.trim().replace(/ style=(["'])/g, " data-style=$1");
                try {
                    e = new DOMParser().parseFromString(tq ? tq.createHTML(t) : t, "text/html");
                } catch (t) {}
                if (!e) {
                    let i = tF("div");
                    i.innerHTML = t, e = {
                        body: i
                    };
                }
                let s = (t, e)=>{
                    let i = t.nodeName.toLowerCase(), o = {
                        tagName: i
                    };
                    "#text" === i && (o.textContent = t.textContent || "");
                    let r = t.attributes;
                    if (r) {
                        let t = {};
                        [].forEach.call(r, (e)=>{
                            "data-style" === e.name ? o.style = tK.parseStyle(e.value) : t[e.name] = e.value;
                        }), o.attributes = t;
                    }
                    if (t.childNodes.length) {
                        let e = [];
                        [].forEach.call(t.childNodes, (t)=>{
                            s(t, e);
                        }), e.length && (o.children = e);
                    }
                    e.push(o);
                };
                return [].forEach.call(e.body.childNodes, (t)=>s(t, i)), i;
            }
        }
        tK.allowedAttributes = [
            "alt",
            "aria-controls",
            "aria-describedby",
            "aria-expanded",
            "aria-haspopup",
            "aria-hidden",
            "aria-label",
            "aria-labelledby",
            "aria-live",
            "aria-pressed",
            "aria-readonly",
            "aria-roledescription",
            "aria-selected",
            "class",
            "clip-path",
            "color",
            "colspan",
            "cx",
            "cy",
            "d",
            "dx",
            "dy",
            "disabled",
            "fill",
            "filterUnits",
            "flood-color",
            "flood-opacity",
            "height",
            "href",
            "id",
            "in",
            "in2",
            "markerHeight",
            "markerWidth",
            "offset",
            "opacity",
            "operator",
            "orient",
            "padding",
            "paddingLeft",
            "paddingRight",
            "patternUnits",
            "r",
            "radius",
            "refX",
            "refY",
            "role",
            "scope",
            "slope",
            "src",
            "startOffset",
            "stdDeviation",
            "stroke",
            "stroke-linecap",
            "stroke-width",
            "style",
            "tableValues",
            "result",
            "rowspan",
            "summary",
            "target",
            "tabindex",
            "text-align",
            "text-anchor",
            "textAnchor",
            "textLength",
            "title",
            "type",
            "valign",
            "width",
            "x",
            "x1",
            "x2",
            "xlink:href",
            "y",
            "y1",
            "y2",
            "zIndex"
        ], tK.allowedReferences = [
            "https://",
            "http://",
            "mailto:",
            "/",
            "../",
            "./",
            "#"
        ], tK.allowedTags = [
            "a",
            "abbr",
            "b",
            "br",
            "button",
            "caption",
            "circle",
            "clipPath",
            "code",
            "dd",
            "defs",
            "div",
            "dl",
            "dt",
            "em",
            "feComponentTransfer",
            "feComposite",
            "feDropShadow",
            "feFlood",
            "feFuncA",
            "feFuncB",
            "feFuncG",
            "feFuncR",
            "feGaussianBlur",
            "feMorphology",
            "feOffset",
            "feMerge",
            "feMergeNode",
            "filter",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "hr",
            "i",
            "img",
            "li",
            "linearGradient",
            "marker",
            "ol",
            "p",
            "path",
            "pattern",
            "pre",
            "rect",
            "small",
            "span",
            "stop",
            "strong",
            "style",
            "sub",
            "sup",
            "svg",
            "table",
            "text",
            "textPath",
            "thead",
            "title",
            "tbody",
            "tspan",
            "td",
            "th",
            "tr",
            "u",
            "ul",
            "#text"
        ], tK.emptyHTML = tZ, tK.bypassHTMLFiltering = !1;
        let { defaultOptions: tJ, defaultTime: tQ } = tm, { pageLang: t0 } = k, { extend: t1, getNestedProperty: t2, isArray: t3, isNumber: t5, isObject: t6, isString: t9, pick: t4, ucfirst: t8 } = $, t7 = {
            add: (t, e)=>t + e,
            divide: (t, e)=>0 !== e ? t / e : "",
            eq: (t, e)=>t == e,
            each: function(t) {
                let e = arguments[arguments.length - 1];
                return !!t3(t) && t.map((i, s)=>ei(e.body, t1(t6(i) ? i : {
                        "@this": i
                    }, {
                        "@index": s,
                        "@first": 0 === s,
                        "@last": s === t.length - 1
                    }))).join("");
            },
            ge: (t, e)=>t >= e,
            gt: (t, e)=>t > e,
            if: (t)=>!!t,
            le: (t, e)=>t <= e,
            lt: (t, e)=>t < e,
            multiply: (t, e)=>t * e,
            ne: (t, e)=>t != e,
            subtract: (t, e)=>t - e,
            ucfirst: t8,
            unless: (t)=>!t
        }, et = {}, ee = (t)=>/^["'].+["']$/.test(t);
        function ei(t = "", e, i) {
            let s = /\{([\p{L}\d:\.,;\-\/<>\[\]%_@+"'= #\(\)]+)\}/gu, o = /\(([\p{L}\d:\.,;\-\/<>\[\]%_@+"'= ]+)\)/gu, r = [], a = /f$/, n = /\.(\d)/, h = i?.options.lang || tJ.lang, l = i && i.time || tQ, d = i && i.numberFormatter || es, c = (t = "")=>{
                let i;
                return "true" === t || "false" !== t && ((i = Number(t)).toString() === t ? i : ee(t) ? t.slice(1, -1) : t2(t, e));
            }, p, g, u = 0, f;
            for(; null !== (p = s.exec(t));){
                let i = p, s = o.exec(p[1]);
                s && (p = s, f = !0), g && g.isBlock || (g = {
                    ctx: e,
                    expression: p[1],
                    find: p[0],
                    isBlock: "#" === p[1].charAt(0),
                    start: p.index,
                    startInner: p.index + p[0].length,
                    length: p[0].length
                });
                let a = (g.isBlock ? i : p)[1].split(" ")[0].replace("#", "");
                t7[a] && (g.isBlock && a === g.fn && u++, g.fn || (g.fn = a));
                let n = "else" === p[1];
                if (g.isBlock && g.fn && (p[1] === `/${g.fn}` || n)) {
                    if (u) !n && u--;
                    else {
                        let e = g.startInner, i = t.substr(e, p.index - e);
                        void 0 === g.body ? (g.body = i, g.startInner = p.index + p[0].length) : g.elseBody = i, g.find += i + p[0], n || (r.push(g), g = void 0);
                    }
                } else g.isBlock || r.push(g);
                if (s && !g?.isBlock) break;
            }
            return r.forEach((s)=>{
                let r, p;
                let { body: g, elseBody: u, expression: f, fn: m } = s;
                if (m) {
                    let t = [
                        s
                    ], o = [], a = f.length, n = 0, h;
                    for(p = 0; p <= a; p++){
                        let t = f.charAt(p);
                        h || '"' !== t && "'" !== t ? h === t && (h = "") : h = t, h || " " !== t && p !== a || (o.push(f.substr(n, p - n)), n = p + 1);
                    }
                    for(p = t7[m].length; p--;)t.unshift(c(o[p + 1]));
                    r = t7[m].apply(e, t), s.isBlock && "boolean" == typeof r && (r = ei(r ? g : u, e, i));
                } else {
                    let t = ee(f) ? [
                        f
                    ] : f.split(":");
                    if (r = c(t.shift() || ""), t.length && "number" == typeof r) {
                        let e = t.join(":");
                        if (a.test(e)) {
                            let t = parseInt((e.match(n) || [
                                "",
                                "-1"
                            ])[1], 10);
                            null !== r && (r = d(r, t, h.decimalPoint, e.indexOf(",") > -1 ? h.thousandsSep : ""));
                        } else r = l.dateFormat(e, r);
                    }
                    o.lastIndex = 0, o.test(s.find) && t9(r) && (r = `"${r}"`);
                }
                t = t.replace(s.find, t4(r, ""));
            }), f ? ei(t, e, i) : t;
        }
        function es(t, e, i, s) {
            e = +e;
            let o, r, [a, n] = (t = +t || 0).toString().split("e").map(Number), h = this?.options?.lang || tJ.lang, l = (t.toString().split(".")[1] || "").split("e")[0].length, d = e, c = {};
            i ?? (i = h.decimalPoint), s ?? (s = h.thousandsSep), -1 === e ? e = Math.min(l, 20) : t5(e) ? e && n < 0 && ((r = e + n) >= 0 ? (a = +a.toExponential(r).split("e")[0], e = r) : (a = Math.floor(a), t = e < 20 ? +(a * Math.pow(10, n)).toFixed(e) : 0, n = 0)) : e = 2, n && (e ?? (e = 2), t = a), t5(e) && e >= 0 && (c.minimumFractionDigits = e, c.maximumFractionDigits = e), "" === s && (c.useGrouping = !1);
            let p = s || i, g = p ? "en" : this?.locale || h.locale || t0, u = JSON.stringify(c) + g;
            return o = (et[u] ?? (et[u] = new Intl.NumberFormat(g, c))).format(t), p && (o = o.replace(/([,\.])/g, "_$1").replace(/_\,/g, s ?? ",").replace("_.", i ?? ".")), (e || 0 != +o) && (!(n < 0) || d) || (o = "0"), n && 0 != +o && (o += "e" + (n < 0 ? "" : "+") + n), o;
        }
        let eo = {
            dateFormat: function(t, e, i) {
                return tQ.dateFormat(t, e, i);
            },
            format: ei,
            helpers: t7,
            numberFormat: es
        };
        !function(t) {
            let e;
            t.rendererTypes = {}, t.getRendererType = function(i = e) {
                return t.rendererTypes[i] || t.rendererTypes[e];
            }, t.registerRendererType = function(i, s, o) {
                t.rendererTypes[i] = s, (!e || o) && (e = i, k.Renderer = s);
            };
        }(s || (s = {}));
        let er = s, { clamp: ea, pick: en, pushUnique: eh, stableSort: el } = $;
        (o || (o = {})).distribute = function t(e, i, s) {
            let o = e, r = o.reducedLen || i, a = (t, e)=>t.target - e.target, n = [], h = e.length, l = [], d = n.push, c, p, g, u = !0, f, m, x = 0, y;
            for(c = h; c--;)x += e[c].size;
            if (x > r) {
                for(el(e, (t, e)=>(e.rank || 0) - (t.rank || 0)), g = (y = e[0].rank === e[e.length - 1].rank) ? h / 2 : -1, p = y ? g : h - 1; g && x > r;)f = e[c = Math.floor(p)], eh(l, c) && (x -= f.size), p += g, y && p >= e.length && (g /= 2, p = g);
                l.sort((t, e)=>e - t).forEach((t)=>d.apply(n, e.splice(t, 1)));
            }
            for(el(e, a), e = e.map((t)=>({
                    size: t.size,
                    targets: [
                        t.target
                    ],
                    align: en(t.align, .5)
                })); u;){
                for(c = e.length; c--;)f = e[c], m = (Math.min.apply(0, f.targets) + Math.max.apply(0, f.targets)) / 2, f.pos = ea(m - f.size * f.align, 0, i - f.size);
                for(c = e.length, u = !1; c--;)c > 0 && e[c - 1].pos + e[c - 1].size > e[c].pos && (e[c - 1].size += e[c].size, e[c - 1].targets = e[c - 1].targets.concat(e[c].targets), e[c - 1].align = .5, e[c - 1].pos + e[c - 1].size > i && (e[c - 1].pos = i - e[c - 1].size), e.splice(c, 1), u = !0);
            }
            return d.apply(o, n), c = 0, e.some((e)=>{
                let r = 0;
                return (e.targets || []).some(()=>(o[c].pos = e.pos + r, void 0 !== s && Math.abs(o[c].pos - o[c].target) > s) ? (o.slice(0, c + 1).forEach((t)=>delete t.pos), o.reducedLen = (o.reducedLen || i) - .1 * i, o.reducedLen > .1 * i && t(o, i, s), !0) : (r += o[c].size, c++, !1));
            }), el(o, a), o;
        };
        let ed = o, { animate: ec, animObject: ep, stop: eg } = tR, { deg2rad: eu, doc: ef, svg: em, SVG_NS: ex, win: ey, isFirefox: eb } = k, { addEvent: ev, attr: ek, createElement: ew, crisp: eM, css: eS, defined: eT, erase: eC, extend: eA, fireEvent: eP, getAlignFactor: eL, isArray: eO, isFunction: eE, isNumber: eI, isObject: eD, isString: eB, merge: eN, objectEach: ez, pick: eR, pInt: eW, pushUnique: eH, replaceNested: eX, syncTimeout: eF, uniqueKey: eG } = $;
        class eY {
            _defaultGetter(t) {
                let e = eR(this[t + "Value"], this[t], this.element ? this.element.getAttribute(t) : null, 0);
                return /^-?[\d\.]+$/.test(e) && (e = parseFloat(e)), e;
            }
            _defaultSetter(t, e, i) {
                i.setAttribute(e, t);
            }
            add(t) {
                let e;
                let i = this.renderer, s = this.element;
                return t && (this.parentGroup = t), void 0 !== this.textStr && "text" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;
            }
            addClass(t, e) {
                let i = e ? "" : this.attr("class") || "";
                return (t = (t || "").split(/ /g).reduce(function(t, e) {
                    return -1 === i.indexOf(e) && t.push(e), t;
                }, i ? [
                    i
                ] : []).join(" ")) !== i && this.attr("class", t), this;
            }
            afterSetters() {
                this.doTransform && (this.updateTransform(), this.doTransform = !1);
            }
            align(t, e, i, s = !0) {
                let o = this.renderer, r = o.alignedObjects, a = !!t;
                t ? (this.alignOptions = t, this.alignByTranslate = e, this.alignTo = i) : (t = this.alignOptions || {}, e = this.alignByTranslate, i = this.alignTo);
                let n = !i || eB(i) ? i || "renderer" : void 0;
                n && (a && eH(r, this), i = void 0);
                let h = eR(i, o[n], o), l = (h.x || 0) + (t.x || 0) + ((h.width || 0) - (t.width || 0)) * eL(t.align), d = (h.y || 0) + (t.y || 0) + ((h.height || 0) - (t.height || 0)) * eL(t.verticalAlign), c = {
                    "text-align": t?.align
                };
                return c[e ? "translateX" : "x"] = Math.round(l), c[e ? "translateY" : "y"] = Math.round(d), s && (this[this.placed ? "animate" : "attr"](c), this.placed = !0), this.alignAttr = c, this;
            }
            alignSetter(t) {
                let e = {
                    left: "start",
                    center: "middle",
                    right: "end"
                };
                e[t] && (this.alignValue = t, this.element.setAttribute("text-anchor", e[t]));
            }
            animate(t, e, i) {
                let s = ep(eR(e, this.renderer.globalAnimation, !0)), o = s.defer;
                return ef.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), eF(()=>{
                    this.element && ec(this, t, s);
                }, o)) : (this.attr(t, void 0, i || s.complete), ez(t, function(t, e) {
                    s.step && s.step.call(this, t, {
                        prop: e,
                        pos: 1,
                        elem: this
                    });
                }, this)), this;
            }
            applyTextOutline(t) {
                let e = this.element;
                -1 !== t.indexOf("contrast") && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));
                let i = t.split(" "), s = i[i.length - 1], o = i[0];
                if (o && "none" !== o && k.svg) {
                    this.fakeTS = !0, o = o.replace(/(^[\d\.]+)(.*?)$/g, function(t, e, i) {
                        return 2 * Number(e) + i;
                    }), this.removeTextOutline();
                    let t = ef.createElementNS(ex, "tspan");
                    ek(t, {
                        class: "highcharts-text-outline",
                        fill: s,
                        stroke: s,
                        "stroke-width": o,
                        "stroke-linejoin": "round"
                    });
                    let i = e.querySelector("textPath") || e;
                    [].forEach.call(i.childNodes, (e)=>{
                        let i = e.cloneNode(!0);
                        i.removeAttribute && [
                            "fill",
                            "stroke",
                            "stroke-width",
                            "stroke"
                        ].forEach((t)=>i.removeAttribute(t)), t.appendChild(i);
                    });
                    let r = 0;
                    [].forEach.call(i.querySelectorAll("text tspan"), (t)=>{
                        r += Number(t.getAttribute("dy"));
                    });
                    let a = ef.createElementNS(ex, "tspan");
                    a.textContent = "", ek(a, {
                        x: Number(e.getAttribute("x")),
                        dy: -r
                    }), t.appendChild(a), i.insertBefore(t, i.firstChild);
                }
            }
            attr(t, e, i, s) {
                let { element: o } = this, r = eY.symbolCustomAttribs, a, n, h = this, l;
                return "string" == typeof t && void 0 !== e && (a = t, (t = {})[a] = e), "string" == typeof t ? h = (this[t + "Getter"] || this._defaultGetter).call(this, t, o) : (ez(t, function(e, i) {
                    l = !1, s || eg(this, i), this.symbolName && -1 !== r.indexOf(i) && (n || (this.symbolAttr(t), n = !0), l = !0), this.rotation && ("x" === i || "y" === i) && (this.doTransform = !0), l || (this[i + "Setter"] || this._defaultSetter).call(this, e, i, o);
                }, this), this.afterSetters()), i && i.call(this), h;
            }
            clip(t) {
                if (t && !t.clipPath) {
                    let e = eG() + "-", i = this.renderer.createElement("clipPath").attr({
                        id: e
                    }).add(this.renderer.defs);
                    eA(t, {
                        clipPath: i,
                        id: e,
                        count: 0
                    }), t.add(i);
                }
                return this.attr("clip-path", t ? `url(${this.renderer.url}#${t.id})` : "none");
            }
            crisp(t, e) {
                e = Math.round(e || t.strokeWidth || 0);
                let i = t.x || this.x || 0, s = t.y || this.y || 0, o = (t.width || this.width || 0) + i, r = (t.height || this.height || 0) + s, a = eM(i, e), n = eM(s, e);
                return eA(t, {
                    x: a,
                    y: n,
                    width: eM(o, e) - a,
                    height: eM(r, e) - n
                }), eT(t.strokeWidth) && (t.strokeWidth = e), t;
            }
            complexColor(t, e, i) {
                let s = this.renderer, o, r, a, n, h, l, d, c, p, g, u = [], f;
                eP(this.renderer, "complexColor", {
                    args: arguments
                }, function() {
                    if (t.radialGradient ? r = "radialGradient" : t.linearGradient && (r = "linearGradient"), r) {
                        if (a = t[r], h = s.gradients, l = t.stops, p = i.radialReference, eO(a) && (t[r] = a = {
                            x1: a[0],
                            y1: a[1],
                            x2: a[2],
                            y2: a[3],
                            gradientUnits: "userSpaceOnUse"
                        }), "radialGradient" === r && p && !eT(a.gradientUnits) && (n = a, a = eN(a, s.getRadialAttr(p, n), {
                            gradientUnits: "userSpaceOnUse"
                        })), ez(a, function(t, e) {
                            "id" !== e && u.push(e, t);
                        }), ez(l, function(t) {
                            u.push(t);
                        }), h[u = u.join(",")]) g = h[u].attr("id");
                        else {
                            a.id = g = eG();
                            let t = h[u] = s.createElement(r).attr(a).add(s.defs);
                            t.radAttr = n, t.stops = [], l.forEach(function(e) {
                                0 === e[1].indexOf("rgba") ? (d = (o = tk.parse(e[1])).get("rgb"), c = o.get("a")) : (d = e[1], c = 1);
                                let i = s.createElement("stop").attr({
                                    offset: e[0],
                                    "stop-color": d,
                                    "stop-opacity": c
                                }).add(t);
                                t.stops.push(i);
                            });
                        }
                        f = "url(" + s.url + "#" + g + ")", i.setAttribute(e, f), i.gradient = u, t.toString = function() {
                            return f;
                        };
                    }
                });
            }
            css(t) {
                let e = this.styles, i = {}, s = this.element, o, r = !e;
                if (e && ez(t, function(t, s) {
                    e && e[s] !== t && (i[s] = t, r = !0);
                }), r) {
                    e && (t = eA(e, i)), null === t.width || "auto" === t.width ? delete this.textWidth : "text" === s.nodeName.toLowerCase() && t.width && (o = this.textWidth = eW(t.width)), eA(this.styles, t), o && !em && this.renderer.forExport && delete t.width;
                    let r = eb && t.fontSize || null;
                    r && (eI(r) || /^\d+$/.test(r)) && (t.fontSize += "px");
                    let a = eN(t);
                    s.namespaceURI === this.SVG_NS && ([
                        "textOutline",
                        "textOverflow",
                        "whiteSpace",
                        "width"
                    ].forEach((t)=>a && delete a[t]), a.color && (a.fill = a.color)), eS(s, a);
                }
                return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;
            }
            dashstyleSetter(t) {
                let e, i = this["stroke-width"];
                if ("inherit" === i && (i = 1), t = t && t.toLowerCase()) {
                    let s = t.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                    for(e = s.length; e--;)s[e] = "" + eW(s[e]) * eR(i, NaN);
                    t = s.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t);
                }
            }
            destroy() {
                let t = this, e = t.element || {}, i = t.renderer, s = e.ownerSVGElement, o = "SPAN" === e.nodeName && t.parentGroup || void 0, r, a;
                if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, eg(t), t.clipPath && s) {
                    let e = t.clipPath;
                    [].forEach.call(s.querySelectorAll("[clip-path],[CLIP-PATH]"), function(t) {
                        t.getAttribute("clip-path").indexOf(e.element.id) > -1 && t.removeAttribute("clip-path");
                    }), t.clipPath = e.destroy();
                }
                if (t.connector = t.connector?.destroy(), t.stops) {
                    for(a = 0; a < t.stops.length; a++)t.stops[a].destroy();
                    t.stops.length = 0, t.stops = void 0;
                }
                for(t.safeRemoveChild(e); o && o.div && 0 === o.div.childNodes.length;)r = o.parentGroup, t.safeRemoveChild(o.div), delete o.div, o = r;
                t.alignOptions && eC(i.alignedObjects, t), ez(t, function(e, i) {
                    t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i];
                });
            }
            dSetter(t, e, i) {
                eO(t) && ("string" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce((t, e, i)=>e && e.join ? (i ? t + " " : "") + e.join(" ") : (e || "").toString(), "")), /(NaN| {2}|^$)/.test(t) && (t = "M 0 0"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);
            }
            fillSetter(t, e, i) {
                "string" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);
            }
            hrefSetter(t, e, i) {
                i.setAttributeNS("http://www.w3.org/1999/xlink", e, t);
            }
            getBBox(t, e) {
                let i, s, o, r;
                let { alignValue: a, element: n, renderer: h, styles: l, textStr: d } = this, { cache: c, cacheKeys: p } = h, g = n.namespaceURI === this.SVG_NS, u = eR(e, this.rotation, 0), f = h.styledMode ? n && eY.prototype.getStyle.call(n, "font-size") : l.fontSize;
                if (eT(d) && (-1 === (r = d.toString()).indexOf("<") && (r = r.replace(/\d/g, "0")), r += [
                    "",
                    h.rootFontSize,
                    f,
                    u,
                    this.textWidth,
                    a,
                    l.lineClamp,
                    l.textOverflow,
                    l.fontWeight
                ].join(",")), r && !t && (i = c[r]), !i || i.polygon) {
                    if (g || h.forExport) {
                        try {
                            o = this.fakeTS && function(t) {
                                let e = n.querySelector(".highcharts-text-outline");
                                e && eS(e, {
                                    display: t
                                });
                            }, eE(o) && o("none"), i = n.getBBox ? eA({}, n.getBBox()) : {
                                width: n.offsetWidth,
                                height: n.offsetHeight,
                                x: 0,
                                y: 0
                            }, eE(o) && o("");
                        } catch (t) {}
                        (!i || i.width < 0) && (i = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        });
                    } else i = this.htmlGetBBox();
                    s = i.height, g && (i.height = s = ({
                        "11px,17": 14,
                        "13px,20": 16
                    })[`${f || ""},${Math.round(s)}`] || s), u && (i = this.getRotatedBox(i, u));
                    let t = {
                        bBox: i
                    };
                    eP(this, "afterGetBBox", t), i = t.bBox;
                }
                if (r && ("" === d || i.height > 0)) {
                    for(; p.length > 250;)delete c[p.shift()];
                    c[r] || p.push(r), c[r] = i;
                }
                return i;
            }
            getRotatedBox(t, e) {
                let { x: i, y: s, width: o, height: r } = t, { alignValue: a, translateY: n, rotationOriginX: h = 0, rotationOriginY: l = 0 } = this, d = eL(a), c = Number(this.element.getAttribute("y") || 0) - (n ? 0 : s), p = e * eu, g = (e - 90) * eu, u = Math.cos(p), f = Math.sin(p), m = o * u, x = o * f, y = Math.cos(g), b = Math.sin(g), [[v, k], [w, M]] = [
                    h,
                    l
                ].map((t)=>[
                        t - t * u,
                        t * f
                    ]), S = i + d * (o - m) + v + M + c * y, T = S + m, C = T - r * y, A = C - m, P = s + c - d * x - k + w + c * b, L = P + x, O = L - r * b, E = O - x, I = Math.min(S, T, C, A), D = Math.min(P, L, O, E), B = Math.max(S, T, C, A) - I, N = Math.max(P, L, O, E) - D;
                return {
                    x: I,
                    y: D,
                    width: B,
                    height: N,
                    polygon: [
                        [
                            S,
                            P
                        ],
                        [
                            T,
                            L
                        ],
                        [
                            C,
                            O
                        ],
                        [
                            A,
                            E
                        ]
                    ]
                };
            }
            getStyle(t) {
                return ey.getComputedStyle(this.element || this, "").getPropertyValue(t);
            }
            hasClass(t) {
                return -1 !== ("" + this.attr("class")).split(" ").indexOf(t);
            }
            hide() {
                return this.attr({
                    visibility: "hidden"
                });
            }
            htmlGetBBox() {
                return {
                    height: 0,
                    width: 0,
                    x: 0,
                    y: 0
                };
            }
            constructor(t, e){
                this.onEvents = {}, this.opacity = 1, this.SVG_NS = ex, this.element = "span" === e || "body" === e ? ew(e) : ef.createElementNS(this.SVG_NS, e), this.renderer = t, this.styles = {}, eP(this, "afterInit");
            }
            on(t, e) {
                let { onEvents: i } = this;
                return i[t] && i[t](), i[t] = ev(this.element, t, e), this;
            }
            opacitySetter(t, e, i) {
                let s = Number(Number(t).toFixed(3));
                this.opacity = s, i.setAttribute(e, s);
            }
            reAlign() {
                this.alignOptions?.width && "left" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = !1, this.align());
            }
            removeClass(t) {
                return this.attr("class", ("" + this.attr("class")).replace(eB(t) ? RegExp(`(^| )${t}( |$)`) : t, " ").replace(/ +/g, " ").trim());
            }
            removeTextOutline() {
                let t = this.element.querySelector("tspan.highcharts-text-outline");
                t && this.safeRemoveChild(t);
            }
            safeRemoveChild(t) {
                let e = t.parentNode;
                e && e.removeChild(t);
            }
            setRadialReference(t) {
                let e = this.element.gradient && this.renderer.gradients[this.element.gradient];
                return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;
            }
            shadow(t) {
                let { renderer: e } = this, i = eN(this.parentGroup?.rotation === 90 ? {
                    offsetX: -1,
                    offsetY: -1
                } : {}, eD(t) ? t : {}), s = e.shadowDefinition(i);
                return this.attr({
                    filter: t ? `url(${e.url}#${s})` : "none"
                });
            }
            show(t = !0) {
                return this.attr({
                    visibility: t ? "inherit" : "visible"
                });
            }
            "stroke-widthSetter"(t, e, i) {
                this[e] = t, i.setAttribute(e, t);
            }
            strokeWidth() {
                if (!this.renderer.styledMode) return this["stroke-width"] || 0;
                let t = this.getStyle("stroke-width"), e = 0, i;
                return /px$/.test(t) ? e = eW(t) : "" !== t && (ek(i = ef.createElementNS(ex, "rect"), {
                    width: t,
                    "stroke-width": 0
                }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;
            }
            symbolAttr(t) {
                let e = this;
                eY.symbolCustomAttribs.forEach(function(i) {
                    e[i] = eR(t[i], e[i]);
                }), e.attr({
                    d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)
                });
            }
            textSetter(t) {
                t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this), this.reAlign());
            }
            titleSetter(t) {
                let e = this.element, i = e.getElementsByTagName("title")[0] || ef.createElementNS(this.SVG_NS, "title");
                e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = eX(eR(t, ""), [
                    /<[^>]*>/g,
                    ""
                ]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            }
            toFront() {
                let t = this.element;
                return t.parentNode.appendChild(t), this;
            }
            translate(t, e) {
                return this.attr({
                    translateX: t,
                    translateY: e
                });
            }
            updateTransform(t = "transform") {
                let { element: e, matrix: i, rotation: s = 0, rotationOriginX: o, rotationOriginY: r, scaleX: a, scaleY: n, translateX: h = 0, translateY: l = 0 } = this, d = [
                    "translate(" + h + "," + l + ")"
                ];
                eT(i) && d.push("matrix(" + i.join(",") + ")"), s && (d.push("rotate(" + s + " " + eR(o, e.getAttribute("x"), 0) + " " + eR(r, e.getAttribute("y") || 0) + ")"), this.text?.element.tagName === "SPAN" && this.text.attr({
                    rotation: s,
                    rotationOriginX: (o || 0) - this.padding,
                    rotationOriginY: (r || 0) - this.padding
                })), (eT(a) || eT(n)) && d.push("scale(" + eR(a, 1) + " " + eR(n, 1) + ")"), d.length && !(this.text || this).textPath && e.setAttribute(t, d.join(" "));
            }
            visibilitySetter(t, e, i) {
                "inherit" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;
            }
            xGetter(t) {
                return "circle" === this.element.nodeName && ("x" === t ? t = "cx" : "y" === t && (t = "cy")), this._defaultGetter(t);
            }
            zIndexSetter(t, e) {
                let i = this.renderer, s = this.parentGroup, o = (s || i).element || i.box, r = this.element, a = o === i.box, n, h, l, d = !1, c, p = this.added, g;
                if (eT(t) ? (r.setAttribute("data-z-index", t), t = +t, this[e] === t && (p = !1)) : eT(this[e]) && r.removeAttribute("data-z-index"), this[e] = t, p) {
                    for((t = this.zIndex) && s && (s.handleZ = !0), g = (n = o.childNodes).length - 1; g >= 0 && !d; g--)c = !eT(l = (h = n[g]).getAttribute("data-z-index")), h !== r && (t < 0 && c && !a && !g ? (o.insertBefore(r, n[g]), d = !0) : (eW(l) <= t || c && (!eT(t) || t >= 0)) && (o.insertBefore(r, n[g + 1]), d = !0));
                    d || (o.insertBefore(r, n[a ? 3 : 0]), d = !0);
                }
                return d;
            }
        }
        eY.symbolCustomAttribs = [
            "anchorX",
            "anchorY",
            "clockwise",
            "end",
            "height",
            "innerR",
            "r",
            "start",
            "width",
            "x",
            "y"
        ], eY.prototype.strokeSetter = eY.prototype.fillSetter, eY.prototype.yGetter = eY.prototype.xGetter, eY.prototype.matrixSetter = eY.prototype.rotationOriginXSetter = eY.prototype.rotationOriginYSetter = eY.prototype.rotationSetter = eY.prototype.scaleXSetter = eY.prototype.scaleYSetter = eY.prototype.translateXSetter = eY.prototype.translateYSetter = eY.prototype.verticalAlignSetter = function(t, e) {
            this[e] = t, this.doTransform = !0;
        };
        let ej = eY, { defined: eU, extend: e$, getAlignFactor: eV, isNumber: e_, merge: eq, pick: eZ, removeEvent: eK } = $;
        class eJ extends ej {
            constructor(t, e, i, s, o, r, a, n, h, l){
                let d;
                super(t, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = !1, this.textStr = e, this.x = i, this.y = s, this.anchorX = r, this.anchorY = a, this.baseline = h, this.className = l, this.addClass("button" === l ? "highcharts-no-tooltip" : "highcharts-label"), l && this.addClass("highcharts-" + l), this.text = t.text(void 0, 0, 0, n).attr({
                    zIndex: 1
                }), "string" == typeof o && ((d = /^url\((.*?)\)$/.test(o)) || this.renderer.symbols[o]) && (this.symbolKey = o), this.bBox = eJ.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t.styledMode || d, this.deferredAttr = {}, this.alignFactor = 0;
            }
            alignSetter(t) {
                let e = eV(t);
                this.textAlign = t, e !== this.alignFactor && (this.alignFactor = e, this.bBox && e_(this.xSetting) && this.attr({
                    x: this.xSetting
                }));
            }
            anchorXSetter(t, e) {
                this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);
            }
            anchorYSetter(t, e) {
                this.anchorY = t, this.boxAttr(e, t - this.ySetting);
            }
            boxAttr(t, e) {
                this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;
            }
            css(t) {
                if (t) {
                    let e = {};
                    t = eq(t), eJ.textProps.forEach((i)=>{
                        void 0 !== t[i] && (e[i] = t[i], delete t[i]);
                    }), this.text.css(e), "fontSize" in e || "fontWeight" in e ? this.updateTextPadding() : ("width" in e || "textOverflow" in e) && this.updateBoxSize();
                }
                return ej.prototype.css.call(this, t);
            }
            destroy() {
                eK(this.element, "mouseenter"), eK(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), ej.prototype.destroy.call(this);
            }
            fillSetter(t, e) {
                t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);
            }
            getBBox(t, e) {
                this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
                let { padding: i, height: s = 0, translateX: o = 0, translateY: r = 0, width: a = 0 } = this, n = eZ(this.paddingLeft, i), h = e ?? (this.rotation || 0), l = {
                    width: a,
                    height: s,
                    x: o + this.bBox.x - n,
                    y: r + this.bBox.y - i + this.baselineOffset
                };
                return h && (l = this.getRotatedBox(l, h)), l;
            }
            getCrispAdjust() {
                return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            }
            heightSetter(t) {
                this.heightSetting = t, this.doUpdate = !0;
            }
            afterSetters() {
                super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = !1);
            }
            onAdd() {
                this.text.add(this), this.attr({
                    text: eZ(this.textStr, ""),
                    x: this.x || 0,
                    y: this.y || 0
                }), this.box && eU(this.anchorX) && this.attr({
                    anchorX: this.anchorX,
                    anchorY: this.anchorY
                });
            }
            paddingSetter(t, e) {
                e_(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;
            }
            rSetter(t, e) {
                this.boxAttr(e, t);
            }
            strokeSetter(t, e) {
                this.stroke = t, this.boxAttr(e, t);
            }
            "stroke-widthSetter"(t, e) {
                t && (this.needsBox = !0), this["stroke-width"] = t, this.boxAttr(e, t);
            }
            "text-alignSetter"(t) {
                this.textAlign = this["text-align"] = t, this.updateTextPadding();
            }
            textSetter(t) {
                void 0 !== t && this.text.attr({
                    text: t
                }), this.updateTextPadding(), this.reAlign();
            }
            updateBoxSize() {
                let t;
                let e = this.text, i = {}, s = this.padding, o = this.bBox = (!e_(this.widthSetting) || !e_(this.heightSetting) || this.textAlign) && eU(e.textStr) ? e.getBBox(void 0, 0) : eJ.emptyBBox;
                this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o.height || 0) + 2 * s;
                let r = this.renderer.fontMetrics(e);
                if (this.baselineOffset = s + Math.min((this.text.firstLineMetrics || r).b, o.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r.h) / 2), this.needsBox && !e.textPath) {
                    if (!this.box) {
                        let t = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
                        t.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t.add(this);
                    }
                    t = this.getCrispAdjust(), i.x = t, i.y = (this.baseline ? -this.baselineOffset : 0) + t, i.width = Math.round(this.width), i.height = Math.round(this.height), this.box.attr(e$(i, this.deferredAttr)), this.deferredAttr = {};
                }
            }
            updateTextPadding() {
                let t = this.text, e = t.styles.textAlign || this.textAlign;
                if (!t.textPath) {
                    this.updateBoxSize();
                    let i = this.baseline ? 0 : this.baselineOffset, s = (this.paddingLeft ?? this.padding) + eV(e) * (this.widthSetting ?? this.bBox.width);
                    (s !== t.x || i !== t.y) && (t.attr({
                        align: e,
                        x: s
                    }), void 0 !== i && t.attr("y", i)), t.x = s, t.y = i;
                }
            }
            widthSetter(t) {
                this.widthSetting = e_(t) ? t : void 0, this.doUpdate = !0;
            }
            getPaddedWidth() {
                let t = this.padding, e = eZ(this.paddingLeft, t), i = eZ(this.paddingRight, t);
                return (this.widthSetting || this.bBox.width || 0) + e + i;
            }
            xSetter(t) {
                this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0), this.xSetting = Math.round(t), this.attr("translateX", this.xSetting);
            }
            ySetter(t) {
                this.ySetting = this.y = Math.round(t), this.attr("translateY", this.ySetting);
            }
        }
        eJ.emptyBBox = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        }, eJ.textProps = [
            "color",
            "direction",
            "fontFamily",
            "fontSize",
            "fontStyle",
            "fontWeight",
            "lineClamp",
            "lineHeight",
            "textAlign",
            "textDecoration",
            "textOutline",
            "textOverflow",
            "whiteSpace",
            "width"
        ];
        let { defined: eQ, isNumber: e0, pick: e1 } = $;
        function e2(t, e, i, s, o) {
            let r = [];
            if (o) {
                let a = o.start || 0, n = e1(o.r, i), h = e1(o.r, s || i), l = 2e-4 / (o.borderRadius ? 1 : Math.max(n, 1)), d = Math.abs((o.end || 0) - a - 2 * Math.PI) < l, c = (o.end || 0) - (d ? l : 0), p = o.innerR, g = e1(o.open, d), u = Math.cos(a), f = Math.sin(a), m = Math.cos(c), x = Math.sin(c), y = e1(o.longArc, c - a - Math.PI < l ? 0 : 1), b = [
                    "A",
                    n,
                    h,
                    0,
                    y,
                    e1(o.clockwise, 1),
                    t + n * m,
                    e + h * x
                ];
                b.params = {
                    start: a,
                    end: c,
                    cx: t,
                    cy: e
                }, r.push([
                    "M",
                    t + n * u,
                    e + h * f
                ], b), eQ(p) && ((b = [
                    "A",
                    p,
                    p,
                    0,
                    y,
                    eQ(o.clockwise) ? 1 - o.clockwise : 0,
                    t + p * u,
                    e + p * f
                ]).params = {
                    start: c,
                    end: a,
                    cx: t,
                    cy: e
                }, r.push(g ? [
                    "M",
                    t + p * m,
                    e + p * x
                ] : [
                    "L",
                    t + p * m,
                    e + p * x
                ], b)), g || r.push([
                    "Z"
                ]);
            }
            return r;
        }
        function e3(t, e, i, s, o) {
            return o && o.r ? e5(t, e, i, s, o) : [
                [
                    "M",
                    t,
                    e
                ],
                [
                    "L",
                    t + i,
                    e
                ],
                [
                    "L",
                    t + i,
                    e + s
                ],
                [
                    "L",
                    t,
                    e + s
                ],
                [
                    "Z"
                ]
            ];
        }
        function e5(t, e, i, s, o) {
            let r = o?.r || 0;
            return [
                [
                    "M",
                    t + r,
                    e
                ],
                [
                    "L",
                    t + i - r,
                    e
                ],
                [
                    "A",
                    r,
                    r,
                    0,
                    0,
                    1,
                    t + i,
                    e + r
                ],
                [
                    "L",
                    t + i,
                    e + s - r
                ],
                [
                    "A",
                    r,
                    r,
                    0,
                    0,
                    1,
                    t + i - r,
                    e + s
                ],
                [
                    "L",
                    t + r,
                    e + s
                ],
                [
                    "A",
                    r,
                    r,
                    0,
                    0,
                    1,
                    t,
                    e + s - r
                ],
                [
                    "L",
                    t,
                    e + r
                ],
                [
                    "A",
                    r,
                    r,
                    0,
                    0,
                    1,
                    t + r,
                    e
                ],
                [
                    "Z"
                ]
            ];
        }
        let e6 = {
            arc: e2,
            callout: function(t, e, i, s, o) {
                let r = Math.min(o && o.r || 0, i, s), a = r + 6, n = o && o.anchorX, h = o && o.anchorY || 0, l = e5(t, e, i, s, {
                    r
                });
                if (!e0(n) || n < i && n > 0 && h < s && h > 0) return l;
                if (t + n > i - a) {
                    if (h > e + a && h < e + s - a) l.splice(3, 1, [
                        "L",
                        t + i,
                        h - 6
                    ], [
                        "L",
                        t + i + 6,
                        h
                    ], [
                        "L",
                        t + i,
                        h + 6
                    ], [
                        "L",
                        t + i,
                        e + s - r
                    ]);
                    else if (n < i) {
                        let o = h < e + a, d = o ? e : e + s;
                        l.splice(o ? 2 : 5, 0, [
                            "L",
                            n,
                            h
                        ], [
                            "L",
                            t + i - r,
                            d
                        ]);
                    } else l.splice(3, 1, [
                        "L",
                        t + i,
                        s / 2
                    ], [
                        "L",
                        n,
                        h
                    ], [
                        "L",
                        t + i,
                        s / 2
                    ], [
                        "L",
                        t + i,
                        e + s - r
                    ]);
                } else if (t + n < a) {
                    if (h > e + a && h < e + s - a) l.splice(7, 1, [
                        "L",
                        t,
                        h + 6
                    ], [
                        "L",
                        t - 6,
                        h
                    ], [
                        "L",
                        t,
                        h - 6
                    ], [
                        "L",
                        t,
                        e + r
                    ]);
                    else if (n > 0) {
                        let i = h < e + a, o = i ? e : e + s;
                        l.splice(i ? 1 : 6, 0, [
                            "L",
                            n,
                            h
                        ], [
                            "L",
                            t + r,
                            o
                        ]);
                    } else l.splice(7, 1, [
                        "L",
                        t,
                        s / 2
                    ], [
                        "L",
                        n,
                        h
                    ], [
                        "L",
                        t,
                        s / 2
                    ], [
                        "L",
                        t,
                        e + r
                    ]);
                } else h > s && n < i - a ? l.splice(5, 1, [
                    "L",
                    n + 6,
                    e + s
                ], [
                    "L",
                    n,
                    e + s + 6
                ], [
                    "L",
                    n - 6,
                    e + s
                ], [
                    "L",
                    t + r,
                    e + s
                ]) : h < 0 && n > a && l.splice(1, 1, [
                    "L",
                    n - 6,
                    e
                ], [
                    "L",
                    n,
                    e - 6
                ], [
                    "L",
                    n + 6,
                    e
                ], [
                    "L",
                    i - r,
                    e
                ]);
                return l;
            },
            circle: function(t, e, i, s) {
                return e2(t + i / 2, e + s / 2, i / 2, s / 2, {
                    start: .5 * Math.PI,
                    end: 2.5 * Math.PI,
                    open: !1
                });
            },
            diamond: function(t, e, i, s) {
                return [
                    [
                        "M",
                        t + i / 2,
                        e
                    ],
                    [
                        "L",
                        t + i,
                        e + s / 2
                    ],
                    [
                        "L",
                        t + i / 2,
                        e + s
                    ],
                    [
                        "L",
                        t,
                        e + s / 2
                    ],
                    [
                        "Z"
                    ]
                ];
            },
            rect: e3,
            roundedRect: e5,
            square: e3,
            triangle: function(t, e, i, s) {
                return [
                    [
                        "M",
                        t + i / 2,
                        e
                    ],
                    [
                        "L",
                        t + i,
                        e + s
                    ],
                    [
                        "L",
                        t,
                        e + s
                    ],
                    [
                        "Z"
                    ]
                ];
            },
            "triangle-down": function(t, e, i, s) {
                return [
                    [
                        "M",
                        t,
                        e
                    ],
                    [
                        "L",
                        t + i,
                        e
                    ],
                    [
                        "L",
                        t + i / 2,
                        e + s
                    ],
                    [
                        "Z"
                    ]
                ];
            }
        }, { doc: e9, SVG_NS: e4, win: e8 } = k, { attr: e7, extend: it, fireEvent: ie, isString: ii, objectEach: is, pick: io } = $, ir = (t, e)=>t.substring(0, e) + "", ia = class {
            constructor(t){
                let e = t.styles;
                this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e && e.lineHeight, this.textOutline = e && e.textOutline, this.ellipsis = !!(e && "ellipsis" === e.textOverflow), this.lineClamp = e?.lineClamp, this.noWrap = !!(e && "nowrap" === e.whiteSpace);
            }
            buildSVG() {
                let t = this.svgElement, e = t.element, i = t.renderer, s = io(t.textStr, "").toString(), o = -1 !== s.indexOf("<"), r = e.childNodes, a = !t.added && i.box, n = [
                    s,
                    this.ellipsis,
                    this.noWrap,
                    this.textLineHeight,
                    this.textOutline,
                    t.getStyle("font-size"),
                    t.styles.lineClamp,
                    this.width
                ].join(",");
                if (n !== t.textCache) {
                    t.textCache = n, delete t.actualWidth;
                    for(let t = r.length; t--;)e.removeChild(r[t]);
                    if (o || this.ellipsis || this.width || t.textPath || -1 !== s.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(s))) {
                        if ("" !== s) {
                            a && a.appendChild(e);
                            let i = new tK(s);
                            this.modifyTree(i.nodes), i.addToDOM(e), this.modifyDOM(), this.ellipsis && -1 !== (e.textContent || "").indexOf("") && t.attr("title", this.unescapeEntities(t.textStr || "", [
                                "&lt;",
                                "&gt;"
                            ])), a && a.removeChild(e);
                        }
                    } else e.appendChild(e9.createTextNode(this.unescapeEntities(s)));
                    ii(this.textOutline) && t.applyTextOutline && t.applyTextOutline(this.textOutline);
                }
            }
            modifyDOM() {
                let t;
                let e = this.svgElement, i = e7(e.element, "x");
                for(e.firstLineMetrics = void 0; t = e.element.firstChild;)if (/^[\s\u200B]*$/.test(t.textContent || " ")) e.element.removeChild(t);
                else break;
                [].forEach.call(e.element.querySelectorAll("tspan.highcharts-br"), (t, s)=>{
                    t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), e7(t, {
                        dy: this.getLineHeight(t.nextSibling),
                        x: i
                    }));
                });
                let s = this.width || 0;
                if (!s) return;
                let o = (t, o)=>{
                    let r = t.textContent || "", a = r.replace(/([^\^])-/g, "$1- ").split(" "), n = !this.noWrap && (a.length > 1 || e.element.childNodes.length > 1), h = this.getLineHeight(o), l = Math.max(0, s - .8 * h), d = 0, c = e.actualWidth;
                    if (n) {
                        let r = [], n = [];
                        for(; o.firstChild && o.firstChild !== t;)n.push(o.firstChild), o.removeChild(o.firstChild);
                        for(; a.length;)if (a.length && !this.noWrap && d > 0 && (r.push(t.textContent || ""), t.textContent = a.join(" ").replace(/- /g, "-")), this.truncate(t, void 0, a, 0 === d && c || 0, s, l, (t, e)=>a.slice(0, e).join(" ").replace(/- /g, "-")), c = e.actualWidth, d++, this.lineClamp && d >= this.lineClamp) {
                            a.length && (this.truncate(t, t.textContent || "", void 0, 0, s, l, ir), t.textContent = t.textContent?.replace("", "") + "");
                            break;
                        }
                        n.forEach((e)=>{
                            o.insertBefore(e, t);
                        }), r.forEach((e)=>{
                            o.insertBefore(e9.createTextNode(e), t);
                            let s = e9.createElementNS(e4, "tspan");
                            s.textContent = "", e7(s, {
                                dy: h,
                                x: i
                            }), o.insertBefore(s, t);
                        });
                    } else this.ellipsis && r && this.truncate(t, r, void 0, 0, s, l, ir);
                }, r = (t)=>{
                    [].slice.call(t.childNodes).forEach((i)=>{
                        i.nodeType === e8.Node.TEXT_NODE ? o(i, t) : (-1 !== i.className.baseVal.indexOf("highcharts-br") && (e.actualWidth = 0), r(i));
                    });
                };
                r(e.element);
            }
            getLineHeight(t) {
                let e = t.nodeType === e8.Node.TEXT_NODE ? t.parentElement : t;
                return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;
            }
            modifyTree(t) {
                let e = (i, s)=>{
                    let { attributes: o = {}, children: r, style: a = {}, tagName: n } = i, h = this.renderer.styledMode;
                    if ("b" === n || "strong" === n ? h ? o.class = "highcharts-strong" : a.fontWeight = "bold" : ("i" === n || "em" === n) && (h ? o.class = "highcharts-emphasized" : a.fontStyle = "italic"), a && a.color && (a.fill = a.color), "br" === n) {
                        o.class = "highcharts-br", i.textContent = "";
                        let e = t[s + 1];
                        e && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, ""));
                    } else "a" === n && r && r.some((t)=>"#text" === t.tagName) && (i.children = [
                        {
                            children: r,
                            tagName: "tspan"
                        }
                    ]);
                    "#text" !== n && "a" !== n && (i.tagName = "tspan"), it(i, {
                        attributes: o,
                        style: a
                    }), r && r.filter((t)=>"#text" !== t.tagName).forEach(e);
                };
                t.forEach(e), ie(this.svgElement, "afterModifyTree", {
                    nodes: t
                });
            }
            truncate(t, e, i, s, o, r, a) {
                let n, h;
                let l = this.svgElement, { rotation: d } = l, c = [], p = i && !s ? 1 : 0, g = (e || i || "").length, u = g;
                i || (o = r);
                let f = function(e, o) {
                    let r = o || e, a = t.parentNode;
                    if (a && void 0 === c[r] && a.getSubStringLength) try {
                        c[r] = s + a.getSubStringLength(0, i ? r + 1 : r);
                    } catch (t) {}
                    return c[r];
                };
                if (l.rotation = 0, s + (h = f(t.textContent.length)) > o) {
                    for(; p <= g;)u = Math.ceil((p + g) / 2), i && (n = a(i, u)), h = f(u, n && n.length - 1), p === g ? p = g + 1 : h > o ? g = u - 1 : p = u;
                    0 === g ? t.textContent = "" : e && g === e.length - 1 || (t.textContent = n || a(e || i, u)), this.ellipsis && h > o && this.truncate(t, t.textContent || "", void 0, 0, o, r, ir);
                }
                i && i.splice(0, u), l.actualWidth = h, l.rotation = d;
            }
            unescapeEntities(t, e) {
                return is(this.renderer.escapes, function(i, s) {
                    e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, "g"), s));
                }), t;
            }
        }, { defaultOptions: ih } = tm, { charts: il, deg2rad: id, doc: ic, isFirefox: ip, isMS: ig, isWebKit: iu, noop: im, SVG_NS: ix, symbolSizes: iy, win: ib } = k, { addEvent: iv, attr: ik, createElement: iw, crisp: iM, css: iS, defined: iT, destroyObjectProperties: iC, extend: iA, isArray: iP, isNumber: iL, isObject: iO, isString: iE, merge: iI, pick: iD, pInt: iB, replaceNested: iN, uniqueKey: iz } = $;
        class iR {
            constructor(t, e, i, s, o, r, a){
                let n, h;
                let l = this.createElement("svg").attr({
                    version: "1.1",
                    class: "highcharts-root"
                }), d = l.element;
                a || l.css(this.getStyle(s || {})), t.appendChild(d), ik(t, "dir", "ltr"), -1 === t.innerHTML.indexOf("xmlns") && ik(d, "xmlns", this.SVG_NS), this.box = d, this.boxWrapper = l, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(ic.createTextNode("Created with Highcharts 12.1.2")), this.defs = this.createElement("defs").add(), this.allowHTML = r, this.forExport = o, this.styledMode = a, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l.getStyle("font-size"), this.setSize(e, i, !1), ip && t.getBoundingClientRect && ((n = function() {
                    iS(t, {
                        left: 0,
                        top: 0
                    }), h = t.getBoundingClientRect(), iS(t, {
                        left: Math.ceil(h.left) - h.left + "px",
                        top: Math.ceil(h.top) - h.top + "px"
                    });
                })(), this.unSubPixelFix = iv(ib, "resize", n));
            }
            definition(t) {
                return new tK([
                    t
                ]).addToDOM(this.defs.element);
            }
            getReferenceURL() {
                if ((ip || iu) && ic.getElementsByTagName("base").length) {
                    if (!iT(e)) {
                        let t = iz(), i = new tK([
                            {
                                tagName: "svg",
                                attributes: {
                                    width: 8,
                                    height: 8
                                },
                                children: [
                                    {
                                        tagName: "defs",
                                        children: [
                                            {
                                                tagName: "clipPath",
                                                attributes: {
                                                    id: t
                                                },
                                                children: [
                                                    {
                                                        tagName: "rect",
                                                        attributes: {
                                                            width: 4,
                                                            height: 4
                                                        }
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        tagName: "rect",
                                        attributes: {
                                            id: "hitme",
                                            width: 8,
                                            height: 8,
                                            "clip-path": `url(#${t})`,
                                            fill: "rgba(0,0,0,0.001)"
                                        }
                                    }
                                ]
                            }
                        ]).addToDOM(ic.body);
                        iS(i, {
                            position: "fixed",
                            top: 0,
                            left: 0,
                            zIndex: 9e5
                        });
                        let s = ic.elementFromPoint(6, 6);
                        e = "hitme" === (s && s.id), ic.body.removeChild(i);
                    }
                    if (e) return iN(ib.location.href.split("#")[0], [
                        /<[^>]*>/g,
                        ""
                    ], [
                        /([\('\)])/g,
                        "\\$1"
                    ], [
                        / /g,
                        "%20"
                    ]);
                }
                return "";
            }
            getStyle(t) {
                return this.style = iA({
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif',
                    fontSize: "1rem"
                }, t), this.style;
            }
            setStyle(t) {
                this.boxWrapper.css(this.getStyle(t));
            }
            isHidden() {
                return !this.boxWrapper.getBBox().width;
            }
            destroy() {
                let t = this.defs;
                return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), iC(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
            }
            createElement(t) {
                return new this.Element(this, t);
            }
            getRadialAttr(t, e) {
                return {
                    cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],
                    cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],
                    r: (e.r || 0) * t[2]
                };
            }
            shadowDefinition(t) {
                let e = [
                    `highcharts-drop-shadow-${this.chartIndex}`,
                    ...Object.keys(t).map((e)=>`${e}-${t[e]}`)
                ].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i = iI({
                    color: "#000000",
                    offsetX: 1,
                    offsetY: 1,
                    opacity: .15,
                    width: 5
                }, t);
                return this.defs.element.querySelector(`#${e}`) || this.definition({
                    tagName: "filter",
                    attributes: {
                        id: e,
                        filterUnits: i.filterUnits
                    },
                    children: this.getShadowFilterContent(i)
                }), e;
            }
            getShadowFilterContent(t) {
                return [
                    {
                        tagName: "feDropShadow",
                        attributes: {
                            dx: t.offsetX,
                            dy: t.offsetY,
                            "flood-color": t.color,
                            "flood-opacity": Math.min(5 * t.opacity, 1),
                            stdDeviation: t.width / 2
                        }
                    }
                ];
            }
            buildText(t) {
                new ia(t).buildSVG();
            }
            getContrast(t) {
                let e = tk.parse(t).rgba.map((t)=>{
                    let e = t / 255;
                    return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
                }), i = .2126 * e[0] + .7152 * e[1] + .0722 * e[2];
                return 1.05 / (i + .05) > (i + .05) / .05 ? "#FFFFFF" : "#000000";
            }
            button(t, e, i, s, o = {}, r, a, n, h, l) {
                let d = this.label(t, e, i, h, void 0, void 0, l, void 0, "button"), c = this.styledMode, p = arguments, g = 0;
                o = iI(ih.global.buttonTheme, o), c && (delete o.fill, delete o.stroke, delete o["stroke-width"]);
                let u = o.states || {}, f = o.style || {};
                delete o.states, delete o.style;
                let m = [
                    tK.filterUserAttributes(o)
                ], x = [
                    f
                ];
                return c || [
                    "hover",
                    "select",
                    "disabled"
                ].forEach((t, e)=>{
                    m.push(iI(m[0], tK.filterUserAttributes(p[e + 5] || u[t] || {}))), x.push(m[e + 1].style), delete m[e + 1].style;
                }), iv(d.element, ig ? "mouseover" : "mouseenter", function() {
                    3 !== g && d.setState(1);
                }), iv(d.element, ig ? "mouseout" : "mouseleave", function() {
                    3 !== g && d.setState(g);
                }), d.setState = (t = 0)=>{
                    if (1 !== t && (d.state = g = t), d.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + [
                        "normal",
                        "hover",
                        "pressed",
                        "disabled"
                    ][t]), !c) {
                        d.attr(m[t]);
                        let e = x[t];
                        iO(e) && d.css(e);
                    }
                }, d.attr(m[0]), !c && (d.css(iA({
                    cursor: "default"
                }, f)), l && d.text.css({
                    pointerEvents: "none"
                })), d.on("touchstart", (t)=>t.stopPropagation()).on("click", function(t) {
                    3 !== g && s.call(d, t);
                });
            }
            crispLine(t, e) {
                let [i, s] = t;
                return iT(i[1]) && i[1] === s[1] && (i[1] = s[1] = iM(i[1], e)), iT(i[2]) && i[2] === s[2] && (i[2] = s[2] = iM(i[2], e)), t;
            }
            path(t) {
                let e = this.styledMode ? {} : {
                    fill: "none"
                };
                return iP(t) ? e.d = t : iO(t) && iA(e, t), this.createElement("path").attr(e);
            }
            circle(t, e, i) {
                let s = iO(t) ? t : void 0 === t ? {} : {
                    x: t,
                    y: e,
                    r: i
                }, o = this.createElement("circle");
                return o.xSetter = o.ySetter = function(t, e, i) {
                    i.setAttribute("c" + e, t);
                }, o.attr(s);
            }
            arc(t, e, i, s, o, r) {
                let a;
                iO(t) ? (e = (a = t).y, i = a.r, s = a.innerR, o = a.start, r = a.end, t = a.x) : a = {
                    innerR: s,
                    start: o,
                    end: r
                };
                let n = this.symbol("arc", t, e, i, i, a);
                return n.r = i, n;
            }
            rect(t, e, i, s, o, r) {
                let a = iO(t) ? t : void 0 === t ? {} : {
                    x: t,
                    y: e,
                    r: o,
                    width: Math.max(i || 0, 0),
                    height: Math.max(s || 0, 0)
                }, n = this.createElement("rect");
                return this.styledMode || (void 0 !== r && (a["stroke-width"] = r, iA(a, n.crisp(a))), a.fill = "none"), n.rSetter = function(t, e, i) {
                    n.r = t, ik(i, {
                        rx: t,
                        ry: t
                    });
                }, n.rGetter = function() {
                    return n.r || 0;
                }, n.attr(a);
            }
            roundedRect(t) {
                return this.symbol("roundedRect").attr(t);
            }
            setSize(t, e, i) {
                this.width = t, this.height = e, this.boxWrapper.animate({
                    width: t,
                    height: e
                }, {
                    step: function() {
                        this.attr({
                            viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                        });
                    },
                    duration: iD(i, !0) ? void 0 : 0
                }), this.alignElements();
            }
            g(t) {
                let e = this.createElement("g");
                return t ? e.attr({
                    class: "highcharts-" + t
                }) : e;
            }
            image(t, e, i, s, o, r) {
                let a = {
                    preserveAspectRatio: "none"
                };
                iL(e) && (a.x = e), iL(i) && (a.y = i), iL(s) && (a.width = s), iL(o) && (a.height = o);
                let n = this.createElement("image").attr(a), h = function(e) {
                    n.attr({
                        href: t
                    }), r.call(n, e);
                };
                if (r) {
                    n.attr({
                        href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                    });
                    let e = new ib.Image;
                    iv(e, "load", h), e.src = t, e.complete && h({});
                } else n.attr({
                    href: t
                });
                return n;
            }
            symbol(t, e, i, s, o, r) {
                let a, n, h, l;
                let d = this, c = /^url\((.*?)\)$/, p = c.test(t), g = !p && (this.symbols[t] ? t : "circle"), u = g && this.symbols[g];
                if (u) "number" == typeof e && (n = u.call(this.symbols, e || 0, i || 0, s || 0, o || 0, r)), a = this.path(n), d.styledMode || a.attr("fill", "none"), iA(a, {
                    symbolName: g || void 0,
                    x: e,
                    y: i,
                    width: s,
                    height: o
                }), r && iA(a, r);
                else if (p) {
                    h = t.match(c)[1];
                    let s = a = this.image(h);
                    s.imgwidth = iD(r && r.width, iy[h] && iy[h].width), s.imgheight = iD(r && r.height, iy[h] && iy[h].height), l = (t)=>t.attr({
                            width: t.width,
                            height: t.height
                        }), [
                        "width",
                        "height"
                    ].forEach((t)=>{
                        s[`${t}Setter`] = function(t, e) {
                            this[e] = t;
                            let { alignByTranslate: i, element: s, width: o, height: a, imgwidth: n, imgheight: h } = this, l = "width" === e ? n : h, d = 1;
                            r && "within" === r.backgroundSize && o && a && n && h ? (d = Math.min(o / n, a / h), ik(s, {
                                width: Math.round(n * d),
                                height: Math.round(h * d)
                            })) : s && l && s.setAttribute(e, l), !i && n && h && this.translate(((o || 0) - n * d) / 2, ((a || 0) - h * d) / 2);
                        };
                    }), iT(e) && s.attr({
                        x: e,
                        y: i
                    }), s.isImg = !0, s.symbolUrl = t, iT(s.imgwidth) && iT(s.imgheight) ? l(s) : (s.attr({
                        width: 0,
                        height: 0
                    }), iw("img", {
                        onload: function() {
                            let t = il[d.chartIndex];
                            0 === this.width && (iS(this, {
                                position: "absolute",
                                top: "-999em"
                            }), ic.body.appendChild(this)), iy[h] = {
                                width: this.width,
                                height: this.height
                            }, s.imgwidth = this.width, s.imgheight = this.height, s.element && l(s), this.parentNode && this.parentNode.removeChild(this), d.imgCount--, d.imgCount || !t || t.hasLoaded || t.onload();
                        },
                        src: h
                    }), this.imgCount++);
                }
                return a;
            }
            clipRect(t, e, i, s) {
                return this.rect(t, e, i, s, 0);
            }
            text(t, e, i, s) {
                let o = {};
                if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);
                o.x = Math.round(e || 0), i && (o.y = Math.round(i)), iT(t) && (o.text = t);
                let r = this.createElement("text").attr(o);
                return s && (!this.forExport || this.allowHTML) || (r.xSetter = function(t, e, i) {
                    let s = i.getElementsByTagName("tspan"), o = i.getAttribute(e);
                    for(let i = 0, r; i < s.length; i++)(r = s[i]).getAttribute(e) === o && r.setAttribute(e, t);
                    i.setAttribute(e, t);
                }), r;
            }
            fontMetrics(t) {
                let e = iB(ej.prototype.getStyle.call(t, "font-size") || 0), i = e < 24 ? e + 3 : Math.round(1.2 * e), s = Math.round(.8 * i);
                return {
                    h: i,
                    b: s,
                    f: e
                };
            }
            rotCorr(t, e, i) {
                let s = t;
                return e && i && (s = Math.max(s * Math.cos(e * id), 4)), {
                    x: -t / 3 * Math.sin(e * id),
                    y: s
                };
            }
            pathToSegments(t) {
                let e = [], i = [], s = {
                    A: 8,
                    C: 7,
                    H: 2,
                    L: 3,
                    M: 3,
                    Q: 5,
                    S: 5,
                    T: 3,
                    V: 2
                };
                for(let o = 0; o < t.length; o++)iE(i[0]) && iL(t[o]) && i.length === s[i[0].toUpperCase()] && t.splice(o, 0, i[0].replace("M", "L").replace("m", "l")), "string" == typeof t[o] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[o]);
                return e.push(i.slice(0)), e;
            }
            label(t, e, i, s, o, r, a, n, h) {
                return new eJ(this, t, e, i, s, o, r, a, n, h);
            }
            alignElements() {
                this.alignedObjects.forEach((t)=>t.align());
            }
        }
        iA(iR.prototype, {
            Element: ej,
            SVG_NS: ix,
            escapes: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "'": "&#39;",
                '"': "&quot;"
            },
            symbols: e6,
            draw: im
        }), er.registerRendererType("svg", iR, !0);
        let { composed: iW } = k, { attr: iH, css: iX, createElement: iF, defined: iG, extend: iY, getAlignFactor: ij, isNumber: iU, pInt: i$, pushUnique: iV } = $;
        function i_(t, e, i) {
            let s = this.div?.style || i.style;
            ej.prototype[`${e}Setter`].call(this, t, e, i), s && (s[e] = t);
        }
        let iq = (t, e)=>{
            if (!t.div) {
                let i = iH(t.element, "class"), s = t.css, o = iF("div", i ? {
                    className: i
                } : void 0, {
                    position: "absolute",
                    left: `${t.translateX || 0}px`,
                    top: `${t.translateY || 0}px`,
                    ...t.styles,
                    display: t.display,
                    opacity: t.opacity,
                    visibility: t.visibility
                }, t.parentGroup?.div || e);
                t.classSetter = (t, e, i)=>{
                    i.setAttribute("class", t), o.className = t;
                }, t.translateXSetter = t.translateYSetter = (e, i)=>{
                    t[i] = e, o.style["translateX" === i ? "left" : "top"] = `${e}px`, t.doTransform = !0;
                }, t.opacitySetter = t.visibilitySetter = i_, t.css = (e)=>(s.call(t, e), e.cursor && (o.style.cursor = e.cursor), e.pointerEvents && (o.style.pointerEvents = e.pointerEvents), t), t.on = function() {
                    return ej.prototype.on.apply({
                        element: o,
                        onEvents: t.onEvents
                    }, arguments), t;
                }, t.div = o;
            }
            return t.div;
        };
        class iZ extends ej {
            static compose(t) {
                iV(iW, this.compose) && (t.prototype.html = function(t, e, i) {
                    return new iZ(this, "span").attr({
                        text: t,
                        x: Math.round(e),
                        y: Math.round(i)
                    });
                });
            }
            constructor(t, e){
                super(t, e), this.css({
                    position: "absolute",
                    ...t.styledMode ? {} : {
                        fontFamily: t.style.fontFamily,
                        fontSize: t.style.fontSize
                    }
                });
            }
            getSpanCorrection(t, e, i) {
                this.xCorr = -t * i, this.yCorr = -e;
            }
            css(t) {
                let e;
                let { element: i } = this, s = "SPAN" === i.tagName && t && "width" in t, o = s && t.width;
                return s && (delete t.width, this.textWidth = i$(o) || void 0, e = !0), t?.textOverflow === "ellipsis" && (t.overflow = "hidden"), t?.lineClamp && (t.display = "-webkit-box", t.WebkitLineClamp = t.lineClamp, t.WebkitBoxOrient = "vertical", t.overflow = "hidden"), iU(Number(t?.fontSize)) && (t.fontSize = t.fontSize + "px"), iY(this.styles, t), iX(i, t), e && this.updateTransform(), this;
            }
            htmlGetBBox() {
                let { element: t } = this;
                return {
                    x: t.offsetLeft,
                    y: t.offsetTop,
                    width: t.offsetWidth,
                    height: t.offsetHeight
                };
            }
            updateTransform() {
                if (!this.added) {
                    this.alignOnAdd = !0;
                    return;
                }
                let { element: t, renderer: e, rotation: i, rotationOriginX: s, rotationOriginY: o, scaleX: r, scaleY: a, styles: n, textAlign: h = "left", textWidth: l, translateX: d = 0, translateY: c = 0, x: p = 0, y: g = 0 } = this, { display: u = "block", whiteSpace: f } = n;
                if (iX(t, {
                    marginLeft: `${d}px`,
                    marginTop: `${c}px`
                }), "SPAN" === t.tagName) {
                    let n;
                    let d = [
                        i,
                        h,
                        t.innerHTML,
                        l,
                        this.textAlign
                    ].join(","), c = -(this.parentGroup?.padding * 1) || 0;
                    if (l !== this.oldTextWidth) {
                        let e = this.textPxLength ? this.textPxLength : (iX(t, {
                            width: "",
                            whiteSpace: f || "nowrap"
                        }), t.offsetWidth), s = l || 0;
                        (s > this.oldTextWidth || e > s) && (/[ \-]/.test(t.textContent || t.innerText) || "ellipsis" === t.style.textOverflow) && (iX(t, {
                            width: e > s || i || r ? l + "px" : "auto",
                            display: u,
                            whiteSpace: f || "normal"
                        }), this.oldTextWidth = l);
                    }
                    d !== this.cTT && (n = e.fontMetrics(t).b, iG(i) && (i !== (this.oldRotation || 0) || h !== this.oldAlign) && this.setSpanRotation(i, c, c), this.getSpanCorrection(!iG(i) && !this.textWidth && this.textPxLength || t.offsetWidth, n, ij(h)));
                    let { xCorr: m = 0, yCorr: x = 0 } = this, y = {
                        left: `${p + m}px`,
                        top: `${g + x}px`,
                        textAlign: h,
                        transformOrigin: `${(s ?? p) - m - p - c}px ${(o ?? g) - x - g - c}px`
                    };
                    (r || a) && (y.transform = `scale(${r ?? 1},${a ?? 1})`), iX(t, y), this.cTT = d, this.oldRotation = i, this.oldAlign = h;
                }
            }
            setSpanRotation(t, e, i) {
                iX(this.element, {
                    transform: `rotate(${t}deg)`,
                    transformOrigin: `${e}% ${i}px`
                });
            }
            add(t) {
                let e;
                let i = this.renderer.box.parentNode, s = [];
                if (this.parentGroup = t, t && !(e = t.div)) {
                    let o = t;
                    for(; o;)s.push(o), o = o.parentGroup;
                    for (let t of s.reverse())e = iq(t, i);
                }
                return (e || i).appendChild(this.element), this.added = !0, this.alignOnAdd && this.updateTransform(), this;
            }
            textSetter(t) {
                t !== this.textStr && (delete this.bBox, delete this.oldTextWidth, tK.setElementHTML(this.element, t ?? ""), this.textStr = t, this.doTransform = !0);
            }
            alignSetter(t) {
                this.alignValue = this.textAlign = t, this.doTransform = !0;
            }
            xSetter(t, e) {
                this[e] = t, this.doTransform = !0;
            }
        }
        let iK = iZ.prototype;
        iK.visibilitySetter = iK.opacitySetter = i_, iK.ySetter = iK.rotationSetter = iK.rotationOriginXSetter = iK.rotationOriginYSetter = iK.xSetter, function(t) {
            t.xAxis = {
                alignTicks: !0,
                allowDecimals: void 0,
                panningEnabled: !0,
                zIndex: 2,
                zoomEnabled: !0,
                dateTimeLabelFormats: {
                    millisecond: {
                        main: "%[HMSL]",
                        range: !1
                    },
                    second: {
                        main: "%[HMS]",
                        range: !1
                    },
                    minute: {
                        main: "%[HM]",
                        range: !1
                    },
                    hour: {
                        main: "%[HM]",
                        range: !1
                    },
                    day: {
                        main: "%[eb]"
                    },
                    week: {
                        main: "%[eb]"
                    },
                    month: {
                        main: "%[bY]"
                    },
                    year: {
                        main: "%Y"
                    }
                },
                endOnTick: !1,
                gridLineDashStyle: "Solid",
                gridZIndex: 1,
                labels: {
                    autoRotationLimit: 80,
                    distance: 15,
                    enabled: !0,
                    indentation: 10,
                    overflow: "justify",
                    reserveSpace: void 0,
                    rotation: void 0,
                    staggerLines: 0,
                    step: 0,
                    useHTML: !1,
                    zIndex: 7,
                    style: {
                        color: "#333333",
                        cursor: "default",
                        fontSize: "0.8em",
                        textOverflow: "ellipsis"
                    }
                },
                maxPadding: .01,
                minorGridLineDashStyle: "Solid",
                minorTickLength: 2,
                minorTickPosition: "outside",
                minorTicksPerMajor: 5,
                minPadding: .01,
                offset: void 0,
                reversed: void 0,
                reversedStacks: !1,
                showEmpty: !0,
                showFirstLabel: !0,
                showLastLabel: !0,
                startOfWeek: 1,
                startOnTick: !1,
                tickLength: 10,
                tickPixelInterval: 100,
                tickmarkPlacement: "between",
                tickPosition: "outside",
                title: {
                    align: "middle",
                    useHTML: !1,
                    x: 0,
                    y: 0,
                    style: {
                        color: "#666666",
                        fontSize: "0.8em"
                    }
                },
                visible: !0,
                minorGridLineColor: "#f2f2f2",
                minorGridLineWidth: 1,
                minorTickColor: "#999999",
                lineColor: "#333333",
                lineWidth: 1,
                gridLineColor: "#e6e6e6",
                gridLineWidth: void 0,
                tickColor: "#333333"
            }, t.yAxis = {
                reversedStacks: !0,
                endOnTick: !0,
                maxPadding: .05,
                minPadding: .05,
                tickPixelInterval: 72,
                showLastLabel: !0,
                labels: {
                    x: void 0
                },
                startOnTick: !0,
                title: {
                    text: "Values"
                },
                stackLabels: {
                    animation: {},
                    allowOverlap: !1,
                    enabled: !1,
                    crop: !0,
                    overflow: "justify",
                    formatter: function() {
                        let { numberFormatter: t } = this.axis.chart;
                        return t(this.total || 0, -1);
                    },
                    style: {
                        color: "#000000",
                        fontSize: "0.7em",
                        fontWeight: "bold",
                        textOutline: "1px contrast"
                    }
                },
                gridLineWidth: 1,
                lineWidth: 0
            };
        }(r || (r = {}));
        let iJ = r, { addEvent: iQ, isFunction: i0, objectEach: i1, removeEvent: i2 } = $;
        (a || (a = {})).registerEventOptions = function(t, e) {
            t.eventOptions = t.eventOptions || {}, i1(e.events, function(e, i) {
                t.eventOptions[i] !== e && (t.eventOptions[i] && (i2(t, i, t.eventOptions[i]), delete t.eventOptions[i]), i0(e) && (t.eventOptions[i] = e, iQ(t, i, e, {
                    order: 0
                })));
            });
        };
        let i3 = a, { deg2rad: i5 } = k, { clamp: i6, correctFloat: i9, defined: i4, destroyObjectProperties: i8, extend: i7, fireEvent: st, getAlignFactor: se, isNumber: si, merge: ss, objectEach: so, pick: sr } = $, sa = class {
            constructor(t, e, i, s, o){
                this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || "", this.parameters = o || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, st(this, "init"), i || s || this.addLabel();
            }
            addLabel() {
                let t = this, e = t.axis, i = e.options, s = e.chart, o = e.categories, r = e.logarithmic, a = e.names, n = t.pos, h = sr(t.options && t.options.labels, i.labels), l = e.tickPositions, d = n === l[0], c = n === l[l.length - 1], p = (!h.step || 1 === h.step) && 1 === e.tickInterval, g = l.info, u = t.label, f, m, x, y = this.parameters.category || (o ? sr(o[n], a[n], n) : n);
                r && si(y) && (y = i9(r.lin2log(y))), e.dateTime && (g ? f = (m = s.time.resolveDTLFormat(i.dateTimeLabelFormats[!i.grid && g.higherRanks[n] || g.unitName])).main : si(y) && (f = e.dateTime.getXDateFormat(y, i.dateTimeLabelFormats || {}))), t.isFirst = d, t.isLast = c;
                let b = {
                    axis: e,
                    chart: s,
                    dateTimeLabelFormat: f,
                    isFirst: d,
                    isLast: c,
                    pos: n,
                    tick: t,
                    tickPositionInfo: g,
                    value: y
                };
                st(this, "labelFormat", b);
                let v = (t)=>h.formatter ? h.formatter.call(t, t) : h.format ? (t.text = e.defaultLabelFormatter.call(t), eo.format(h.format, t, s)) : e.defaultLabelFormatter.call(t), k = v.call(b, b), w = m && m.list;
                w ? t.shortenLabel = function() {
                    for(x = 0; x < w.length; x++)if (i7(b, {
                        dateTimeLabelFormat: w[x]
                    }), u.attr({
                        text: v.call(b, b)
                    }), u.getBBox().width < e.getSlotWidth(t) - 2 * (h.padding || 0)) return;
                    u.attr({
                        text: ""
                    });
                } : t.shortenLabel = void 0, p && e._addedPlotLB && t.moveLabel(k, h), i4(u) || t.movedLabel ? u && u.textStr !== k && !p && (!u.textWidth || h.style.width || u.styles.width || u.css({
                    width: null
                }), u.attr({
                    text: k
                }), u.textPxLength = u.getBBox().width) : (t.label = u = t.createLabel(k, h), t.rotation = 0);
            }
            createLabel(t, e, i) {
                let s = this.axis, { renderer: o, styledMode: r } = s.chart, a = i4(t) && e.enabled ? o.text(t, i?.x, i?.y, e.useHTML).add(s.labelGroup) : void 0;
                if (a) {
                    let t = e.style.whiteSpace || "normal";
                    r || a.css(ss(e.style, {
                        whiteSpace: "nowrap"
                    })), a.textPxLength = a.getBBox().width, r || a.css({
                        whiteSpace: t
                    });
                }
                return a;
            }
            destroy() {
                i8(this, this.axis);
            }
            getPosition(t, e, i, s) {
                let o = this.axis, r = o.chart, a = s && r.oldChartHeight || r.chartHeight, n = {
                    x: t ? i9(o.translate(e + i, void 0, void 0, s) + o.transB) : o.left + o.offset + (o.opposite ? (s && r.oldChartWidth || r.chartWidth) - o.right - o.left : 0),
                    y: t ? a - o.bottom + o.offset - (o.opposite ? o.height : 0) : i9(a - o.translate(e + i, void 0, void 0, s) - o.transB)
                };
                return n.y = i6(n.y, -1e9, 1e9), st(this, "afterGetPosition", {
                    pos: n
                }), n;
            }
            getLabelPosition(t, e, i, s, o, r, a, n) {
                let h, l;
                let d = this.axis, c = d.transA, p = d.isLinked && d.linkedParent ? d.linkedParent.reversed : d.reversed, g = d.staggerLines, u = d.tickRotCorr || {
                    x: 0,
                    y: 0
                }, f = s || d.reserveSpaceDefault ? 0 : -d.labelOffset * ("center" === d.labelAlign ? .5 : 1), m = o.distance, x = {};
                return h = 0 === d.side ? i.rotation ? -m : -i.getBBox().height : 2 === d.side ? u.y + m : Math.cos(i.rotation * i5) * (u.y - i.getBBox(!1, 0).height / 2), i4(o.y) && (h = 0 === d.side && d.horiz ? o.y + h : o.y), t = t + sr(o.x, [
                    0,
                    1,
                    0,
                    -1
                ][d.side] * m) + f + u.x - (r && s ? r * c * (p ? -1 : 1) : 0), e = e + h - (r && !s ? r * c * (p ? 1 : -1) : 0), g && (l = a / (n || 1) % g, d.opposite && (l = g - l - 1), e += l * (d.labelOffset / g)), x.x = t, x.y = Math.round(e), st(this, "afterGetLabelPosition", {
                    pos: x,
                    tickmarkOffset: r,
                    index: a
                }), x;
            }
            getLabelSize() {
                return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            }
            getMarkPath(t, e, i, s, o = !1, r) {
                return r.crispLine([
                    [
                        "M",
                        t,
                        e
                    ],
                    [
                        "L",
                        t + (o ? 0 : -i),
                        e + (o ? i : 0)
                    ]
                ], s);
            }
            handleOverflow(t) {
                let e = this.axis, i = e.options.labels, s = t.x, o = e.chart.chartWidth, r = e.chart.spacing, a = sr(e.labelLeft, Math.min(e.pos, r[3])), n = sr(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, o - r[1])), h = this.label, l = this.rotation, d = se(e.labelAlign || h.attr("align")), c = h.getBBox().width, p = e.getSlotWidth(this), g = p, u = 1, f, m, x;
                l || "justify" !== i.overflow ? l < 0 && s - d * c < a ? x = Math.round(s / Math.cos(l * i5) - a) : l > 0 && s + d * c > n && (x = Math.round((o - s) / Math.cos(l * i5))) : (f = s - d * c, m = s + (1 - d) * c, f < a ? g = t.x + g * (1 - d) - a : m > n && (g = n - t.x + g * d, u = -1), (g = Math.min(p, g)) < p && "center" === e.labelAlign && (t.x += u * (p - g - d * (p - Math.min(c, g)))), (c > g || e.autoRotation && (h.styles || {}).width) && (x = g)), x && h && (this.shortenLabel ? this.shortenLabel() : h.css(i7({}, {
                    width: Math.floor(x) + "px",
                    lineClamp: e.isRadial ? 0 : 1
                })));
            }
            moveLabel(t, e) {
                let i = this, s = i.label, o = i.axis, r = !1, a;
                s && s.textStr === t ? (i.movedLabel = s, r = !0, delete i.label) : so(o.ticks, function(e) {
                    r || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, r = !0, e.labelPos = i.movedLabel.xy, delete e.label);
                }), !r && (i.labelPos || s) && (a = i.labelPos || s.xy, i.movedLabel = i.createLabel(t, e, a), i.movedLabel && i.movedLabel.attr({
                    opacity: 0
                }));
            }
            render(t, e, i) {
                let s = this.axis, o = s.horiz, r = this.pos, a = sr(this.tickmarkOffset, s.tickmarkOffset), n = this.getPosition(o, r, a, e), h = n.x, l = n.y, d = s.pos, c = d + s.len, p = o ? h : l;
                !s.chart.polar && this.isNew && (i9(p) < d || p > c) && (i = 0);
                let g = sr(i, this.label && this.label.newOpacity, 1);
                i = sr(i, 1), this.isActive = !0, this.renderGridLine(e, i), this.renderMark(n, i), this.renderLabel(n, e, g, t), this.isNew = !1, st(this, "afterRender");
            }
            renderGridLine(t, e) {
                let i = this.axis, s = i.options, o = {}, r = this.pos, a = this.type, n = sr(this.tickmarkOffset, i.tickmarkOffset), h = i.chart.renderer, l = this.gridLine, d, c = s.gridLineWidth, p = s.gridLineColor, g = s.gridLineDashStyle;
                "minor" === this.type && (c = s.minorGridLineWidth, p = s.minorGridLineColor, g = s.minorGridLineDashStyle), l || (i.chart.styledMode || (o.stroke = p, o["stroke-width"] = c || 0, o.dashstyle = g), a || (o.zIndex = 1), t && (e = 0), this.gridLine = l = h.path().attr(o).addClass("highcharts-" + (a ? a + "-" : "") + "grid-line").add(i.gridGroup)), l && (d = i.getPlotLinePath({
                    value: r + n,
                    lineWidth: l.strokeWidth(),
                    force: "pass",
                    old: t,
                    acrossPanes: !1
                })) && l[t || this.isNew ? "attr" : "animate"]({
                    d: d,
                    opacity: e
                });
            }
            renderMark(t, e) {
                let i = this.axis, s = i.options, o = i.chart.renderer, r = this.type, a = i.tickSize(r ? r + "Tick" : "tick"), n = t.x, h = t.y, l = sr(s["minor" !== r ? "tickWidth" : "minorTickWidth"], !r && i.isXAxis ? 1 : 0), d = s["minor" !== r ? "tickColor" : "minorTickColor"], c = this.mark, p = !c;
                a && (i.opposite && (a[0] = -a[0]), c || (this.mark = c = o.path().addClass("highcharts-" + (r ? r + "-" : "") + "tick").add(i.axisGroup), i.chart.styledMode || c.attr({
                    stroke: d,
                    "stroke-width": l
                })), c[p ? "attr" : "animate"]({
                    d: this.getMarkPath(n, h, a[0], c.strokeWidth(), i.horiz, o),
                    opacity: e
                }));
            }
            renderLabel(t, e, i, s) {
                let o = this.axis, r = o.horiz, a = o.options, n = this.label, h = a.labels, l = h.step, d = sr(this.tickmarkOffset, o.tickmarkOffset), c = t.x, p = t.y, g = !0;
                n && si(c) && (n.xy = t = this.getLabelPosition(c, p, n, r, h, d, s, l), (!this.isFirst || this.isLast || a.showFirstLabel) && (!this.isLast || this.isFirst || a.showLastLabel) ? !r || h.step || h.rotation || e || 0 === i || this.handleOverflow(t) : g = !1, l && s % l && (g = !1), g && si(t.y) ? (t.opacity = i, n[this.isNewLabel ? "attr" : "animate"](t).show(!0), this.isNewLabel = !1) : (n.hide(), this.isNewLabel = !0));
            }
            replaceMovedLabel() {
                let t = this.label, e = this.axis;
                t && !this.isNew && (t.animate({
                    opacity: 0
                }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;
            }
        }, { animObject: sn } = tR, { xAxis: sh, yAxis: sl } = iJ, { defaultOptions: sd } = tm, { registerEventOptions: sc } = i3, { deg2rad: sp } = k, { arrayMax: sg, arrayMin: su, clamp: sf, correctFloat: sm, defined: sx, destroyObjectProperties: sy, erase: sb, error: sv, extend: sk, fireEvent: sw, getClosestDistance: sM, insertItem: sS, isArray: sT, isNumber: sC, isString: sA, merge: sP, normalizeTickInterval: sL, objectEach: sO, pick: sE, relativeLength: sI, removeEvent: sD, splat: sB, syncTimeout: sN } = $, sz = (t, e)=>sL(e, void 0, void 0, sE(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);
        sk(sd, {
            xAxis: sh,
            yAxis: sP(sh, sl)
        });
        class sR {
            constructor(t, e, i){
                this.init(t, e, i);
            }
            init(t, e, i = this.coll) {
                let s = "xAxis" === i, o = this.isZAxis || (t.inverted ? !s : s);
                this.chart = t, this.horiz = o, this.isXAxis = s, this.coll = i, sw(this, "init", {
                    userOptions: e
                }), this.opposite = sE(e.opposite, this.opposite), this.side = sE(e.side, this.side, o ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e);
                let r = this.options, a = r.labels;
                this.type ?? (this.type = r.type || "linear"), this.uniqueNames ?? (this.uniqueNames = r.uniqueNames ?? !0), sw(this, "afterSetType"), this.userOptions = e, this.minPixelPadding = 0, this.reversed = sE(r.reversed, this.reversed), this.visible = r.visible, this.zoomEnabled = r.zoomEnabled, this.hasNames = "category" === this.type || !0 === r.categories, this.categories = sT(r.categories) && r.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = sx(r.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r.minRange || r.maxZoom, this.range = r.range, this.offset = r.offset || 0, this.max = void 0, this.min = void 0;
                let n = sE(r.crosshair, sB(t.options.tooltip.crosshairs)[s ? 0 : 1]);
                this.crosshair = !0 === n ? {} : n, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), sS(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !sx(this.reversed) && (this.reversed = !0), this.labelRotation = sC(a.rotation) ? a.rotation : void 0, sc(this, r), sw(this, "afterInit");
            }
            setOptions(t) {
                let e = this.horiz ? {
                    labels: {
                        autoRotation: [
                            -45
                        ],
                        padding: 3
                    },
                    margin: 15
                } : {
                    labels: {
                        padding: 1
                    },
                    title: {
                        rotation: 90 * this.side
                    }
                };
                this.options = sP(e, sd[this.coll], t), sw(this, "afterSetOptions", {
                    userOptions: t
                });
            }
            defaultLabelFormatter() {
                let t = this.axis, { numberFormatter: e } = this.chart, i = sC(this.value) ? this.value : NaN, s = t.chart.time, o = t.categories, r = this.dateTimeLabelFormat, a = sd.lang, n = a.numericSymbols, h = a.numericSymbolMagnitude || 1e3, l = t.logarithmic ? Math.abs(i) : t.tickInterval, d = n && n.length, c, p;
                if (o) p = `${this.value}`;
                else if (r) p = s.dateFormat(r, i, !0);
                else if (d && n && l >= 1e3) for(; d-- && void 0 === p;)l >= (c = Math.pow(h, d + 1)) && 10 * i % c == 0 && null !== n[d] && 0 !== i && (p = e(i / c, -1) + n[d]);
                return void 0 === p && (p = Math.abs(i) >= 1e4 ? e(i, -1) : e(i, -1, void 0, "")), p;
            }
            getSeriesExtremes() {
                let t;
                let e = this;
                sw(this, "getSeriesExtremes", null, function() {
                    e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach((i)=>{
                        if (i.reserveSpace()) {
                            let s = i.options, o, r = s.threshold, a, n;
                            if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (r || 0) && (r = void 0), e.isXAxis) (o = i.getColumn("x")).length && (o = e.logarithmic ? o.filter((t)=>t > 0) : o, a = (t = i.getXExtremes(o)).min, n = t.max, sC(a) || a instanceof Date || (o = o.filter(sC), a = (t = i.getXExtremes(o)).min, n = t.max), o.length && (e.dataMin = Math.min(sE(e.dataMin, a), a), e.dataMax = Math.max(sE(e.dataMax, n), n)));
                            else {
                                let t = i.applyExtremes();
                                sC(t.dataMin) && (a = t.dataMin, e.dataMin = Math.min(sE(e.dataMin, a), a)), sC(t.dataMax) && (n = t.dataMax, e.dataMax = Math.max(sE(e.dataMax, n), n)), sx(r) && (e.threshold = r), (!s.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);
                            }
                        }
                    });
                }), sw(this, "afterGetSeriesExtremes");
            }
            translate(t, e, i, s, o, r) {
                let a = this.linkedParent || this, n = s && a.old ? a.old.min : a.min;
                if (!sC(n)) return NaN;
                let h = a.minPixelPadding, l = (a.isOrdinal || a.brokenAxis?.hasBreaks || a.logarithmic && o) && a.lin2val, d = 1, c = 0, p = s && a.old ? a.old.transA : a.transA, g = 0;
                return p || (p = a.transA), i && (d *= -1, c = a.len), a.reversed && (d *= -1, c -= d * (a.sector || a.len)), e ? (g = (t = t * d + c - h) / p + n, l && (g = a.lin2val(g))) : (l && (t = a.val2lin(t)), g = d * (t - n) * p + c + d * h + (sC(r) ? p * r : 0), a.isRadial || (g = sm(g))), g;
            }
            toPixels(t, e) {
                return this.translate(this.chart?.time.parse(t) ?? NaN, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);
            }
            toValue(t, e) {
                return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);
            }
            getPlotLinePath(t) {
                let e = this, i = e.chart, s = e.left, o = e.top, r = t.old, a = t.value, n = t.lineWidth, h = r && i.oldChartHeight || i.chartHeight, l = r && i.oldChartWidth || i.chartWidth, d = e.transB, c = t.translatedValue, p = t.force, g, u, f, m, x;
                function y(t, e, i) {
                    return "pass" !== p && (t < e || t > i) && (p ? t = sf(t, e, i) : x = !0), t;
                }
                let b = {
                    value: a,
                    lineWidth: n,
                    old: r,
                    force: p,
                    acrossPanes: t.acrossPanes,
                    translatedValue: c
                };
                return sw(this, "getPlotLinePath", b, function(t) {
                    g = f = (c = sf(c = sE(c, e.translate(a, void 0, void 0, r)), -1e9, 1e9)) + d, u = m = h - c - d, sC(c) ? e.horiz ? (u = o, m = h - e.bottom + (e.options.isInternal ? 0 : i.scrollablePixelsY || 0), g = f = y(g, s, s + e.width)) : (g = s, f = l - e.right + (i.scrollablePixelsX || 0), u = m = y(u, o, o + e.height)) : (x = !0, p = !1), t.path = x && !p ? void 0 : i.renderer.crispLine([
                        [
                            "M",
                            g,
                            u
                        ],
                        [
                            "L",
                            f,
                            m
                        ]
                    ], n || 1);
                }), b.path;
            }
            getLinearTickPositions(t, e, i) {
                let s, o, r;
                let a = sm(Math.floor(e / t) * t), n = sm(Math.ceil(i / t) * t), h = [];
                if (sm(a + t) === a && (r = 20), this.single) return [
                    e
                ];
                for(s = a; s <= n && (h.push(s), (s = sm(s + t, r)) !== o);)o = s;
                return h;
            }
            getMinorTickInterval() {
                let { minorTicks: t, minorTickInterval: e } = this.options;
                return !0 === t ? sE(e, "auto") : !1 !== t ? e : void 0;
            }
            getMinorTickPositions() {
                let t = this.options, e = this.tickPositions, i = this.minorTickInterval, s = this.pointRangePadding || 0, o = (this.min || 0) - s, r = (this.max || 0) + s, a = this.brokenAxis?.hasBreaks ? this.brokenAxis.unitLength : r - o, n = [], h;
                if (a && a / i < this.len / 3) {
                    let s = this.logarithmic;
                    if (s) this.paddedTicks.forEach(function(t, e, o) {
                        e && n.push.apply(n, s.getLogTickPositions(i, o[e - 1], o[e], !0));
                    });
                    else if (this.dateTime && "auto" === this.getMinorTickInterval()) n = n.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), o, r, t.startOfWeek));
                    else for(h = o + (e[0] - o) % i; h <= r && h !== n[0]; h += i)n.push(h);
                }
                return 0 !== n.length && this.trimTicks(n), n;
            }
            adjustForMinRange() {
                let t = this.options, e = this.logarithmic, i = this.chart.time, { max: s, min: o, minRange: r } = this, a, n, h, l;
                this.isXAxis && void 0 === r && !e && (r = sx(t.min) || sx(t.max) || sx(t.floor) || sx(t.ceiling) ? null : Math.min(5 * (sM(this.series.map((t)=>{
                    let e = t.getColumn("x");
                    return t.xIncrement ? e.slice(0, 2) : e;
                })) || 0), this.dataMax - this.dataMin)), sC(s) && sC(o) && sC(r) && s - o < r && (n = this.dataMax - this.dataMin >= r, a = (r - s + o) / 2, h = [
                    o - a,
                    i.parse(t.min) ?? o - a
                ], n && (h[2] = e ? e.log2lin(this.dataMin) : this.dataMin), l = [
                    (o = sg(h)) + r,
                    i.parse(t.max) ?? o + r
                ], n && (l[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (s = su(l)) - o < r && (h[0] = s - r, h[1] = i.parse(t.min) ?? s - r, o = sg(h))), this.minRange = r, this.min = o, this.max = s;
            }
            getClosest() {
                let t, e;
                if (this.categories) e = 1;
                else {
                    let i = [];
                    this.series.forEach(function(t) {
                        let s = t.closestPointRange, o = t.getColumn("x");
                        1 === o.length ? i.push(o[0]) : t.sorted && sx(s) && t.reserveSpace() && (e = sx(e) ? Math.min(e, s) : s);
                    }), i.length && (i.sort((t, e)=>t - e), t = sM([
                        i
                    ]));
                }
                return t && e ? Math.min(t, e) : t || e;
            }
            nameToX(t) {
                let e = sT(this.options.categories), i = e ? this.categories : this.names, s = t.options.x, o;
                return t.series.requireSorting = !1, sx(s) || (s = this.uniqueNames && i ? e ? i.indexOf(t.name) : sE(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (o = i.length) : sC(s) && (o = s), void 0 !== o ? (this.names[o] = t.name, this.names.keys[t.name] = o) : t.x && (o = t.x), o;
            }
            updateNames() {
                let t = this, e = this.names;
                e.length > 0 && (Object.keys(e.keys).forEach(function(t) {
                    delete e.keys[t];
                }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((e)=>{
                    e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max || 0, e.dataTable.rowCount - 1), e.processData(), e.generatePoints());
                    let i = e.getColumn("x").slice();
                    e.data.forEach((e, s)=>{
                        let o = i[s];
                        e?.options && void 0 !== e.name && void 0 !== (o = t.nameToX(e)) && o !== e.x && (i[s] = e.x = o);
                    }), e.dataTable.setColumn("x", i);
                }));
            }
            setAxisTranslation() {
                let t = this, e = t.max - t.min, i = t.linkedParent, s = !!t.categories, o = t.isXAxis, r = t.axisPointRange || 0, a, n = 0, h = 0, l, d = t.transA;
                (o || s || r) && (a = t.getClosest(), i ? (n = i.minPointOffset, h = i.pointRangePadding) : t.series.forEach(function(e) {
                    let i = s ? 1 : o ? sE(e.options.pointRange, a, 0) : t.axisPointRange || 0, l = e.options.pointPlacement;
                    if (r = Math.max(r, i), !t.single || s) {
                        let t = e.is("xrange") ? !o : o;
                        n = Math.max(n, t && sA(l) ? 0 : i / 2), h = Math.max(h, t && "on" === l ? 0 : i);
                    }
                }), l = t.ordinal && t.ordinal.slope && a ? t.ordinal.slope / a : 1, t.minPointOffset = n *= l, t.pointRangePadding = h *= l, t.pointRange = Math.min(r, t.single && s ? 1 : e), o && a && (t.closestPointRange = a)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + h || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * n, sw(this, "afterSetAxisTranslation");
            }
            minFromRange() {
                let { max: t, min: e } = this;
                return sC(t) && sC(e) && t - e || void 0;
            }
            setTickInterval(t) {
                let { categories: e, chart: i, dataMax: s, dataMin: o, dateTime: r, isXAxis: a, logarithmic: n, options: h, softThreshold: l } = this, d = i.time, c = sC(this.threshold) ? this.threshold : void 0, p = this.minRange || 0, { ceiling: g, floor: u, linkedTo: f, softMax: m, softMin: x } = h, y = sC(f) && i[this.coll]?.[f], b = h.tickPixelInterval, v = h.maxPadding, k = h.minPadding, w = 0, M, S = sC(h.tickInterval) && h.tickInterval >= 0 ? h.tickInterval : void 0, T, C, A, P;
                if (r || e || y || this.getTickAmount(), A = sE(this.userMin, d.parse(h.min)), P = sE(this.userMax, d.parse(h.max)), y ? (this.linkedParent = y, M = y.getExtremes(), this.min = sE(M.min, M.dataMin), this.max = sE(M.max, M.dataMax), this.type !== y.type && sv(11, !0, i)) : (l && sx(c) && sC(s) && sC(o) && (o >= c ? (T = c, k = 0) : s <= c && (C = c, v = 0)), this.min = sE(A, T, o), this.max = sE(P, C, s)), sC(this.max) && sC(this.min) && (n && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, sE(o, this.min)) && sv(10, !0, i), this.min = sm(n.log2lin(this.min), 16), this.max = sm(n.log2lin(this.max), 16)), this.range && sC(o) && (this.userMin = this.min = A = Math.max(o, this.minFromRange() || 0), this.userMax = P = this.max, this.range = void 0)), sw(this, "foundExtremes"), this.adjustForMinRange(), sC(this.min) && sC(this.max)) {
                    if (!sC(this.userMin) && sC(x) && x < this.min && (this.min = A = x), !sC(this.userMax) && sC(m) && m > this.max && (this.max = P = m), e || this.axisPointRange || this.stacking?.usePercentage || y || !(w = this.max - this.min) || (!sx(A) && k && (this.min -= w * k), sx(P) || !v || (this.max += w * v)), !sC(this.userMin) && sC(u) && (this.min = Math.max(this.min, u)), !sC(this.userMax) && sC(g) && (this.max = Math.min(this.max, g)), l && sC(o) && sC(s)) {
                        let t = c || 0;
                        !sx(A) && this.min < t && o >= t ? this.min = h.minRange ? Math.min(t, this.max - p) : t : !sx(P) && this.max > t && s <= t && (this.max = h.minRange ? Math.max(t, this.min + p) : t);
                    }
                    !i.polar && this.min > this.max && (sx(h.min) ? this.max = this.min : sx(h.max) && (this.min = this.max)), w = this.max - this.min;
                }
                if (this.min !== this.max && sC(this.min) && sC(this.max) ? y && !S && b === y.options.tickPixelInterval ? this.tickInterval = S = y.tickInterval : this.tickInterval = sE(S, this.tickAmount ? w / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : w * b / Math.max(this.len, b)) : this.tickInterval = 1, a && !t) {
                    let t = this.min !== this.old?.min || this.max !== this.old?.max;
                    this.series.forEach(function(e) {
                        e.forceCrop = e.forceCropping?.(), e.processData(t);
                    }), sw(this, "postProcessData", {
                        hasExtremesChanged: t
                    });
                }
                this.setAxisTranslation(), sw(this, "initialAxisTranslation"), this.pointRange && !S && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
                let L = sE(h.minTickInterval, r && !this.series.some((t)=>!t.sorted) ? this.closestPointRange : 0);
                !S && this.tickInterval < L && (this.tickInterval = L), r || n || S || (this.tickInterval = sz(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
            }
            setTickPositions() {
                let t = this.options, e = t.tickPositions, i = t.tickPositioner, s = this.getMinorTickInterval(), o = !this.isPanning, r = o && t.startOnTick, a = o && t.endOnTick, n = [], h;
                if (this.tickmarkOffset = this.categories && "between" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.single = this.min === this.max && sx(this.min) && !this.tickAmount && (this.min % 1 == 0 || !1 !== t.allowDecimals), e) n = e.slice();
                else if (sC(this.min) && sC(this.max)) {
                    if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) n = [
                        this.min,
                        this.max
                    ], sv(19, !1, this.chart);
                    else if (this.dateTime) n = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, this.ordinal?.positions, this.closestPointRange, !0);
                    else if (this.logarithmic) n = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                    else {
                        let t = this.tickInterval, e = t;
                        for(; e <= 2 * t;)if (n = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && n.length > this.tickAmount) this.tickInterval = sz(this, e *= 1.1);
                        else break;
                    }
                    n.length > this.len && (n = [
                        n[0],
                        n[n.length - 1]
                    ])[0] === n[1] && (n.length = 1), i && (this.tickPositions = n, (h = i.apply(this, [
                        this.min,
                        this.max
                    ])) && (n = h));
                }
                this.tickPositions = n, this.minorTickInterval = "auto" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.paddedTicks = n.slice(0), this.trimTicks(n, r, a), !this.isLinked && sC(this.min) && sC(this.max) && (this.single && n.length < 2 && !this.categories && !this.series.some((t)=>t.is("heatmap") && "between" === t.options.pointPlacement) && (this.min -= .5, this.max += .5), e || h || this.adjustTickAmount()), sw(this, "afterSetTickPositions");
            }
            trimTicks(t, e, i) {
                let s = t[0], o = t[t.length - 1], r = !this.isOrdinal && this.minPointOffset || 0;
                if (sw(this, "trimTicks"), !this.isLinked) {
                    if (e && s !== -1 / 0) this.min = s;
                    else for(; this.min - r > t[0];)t.shift();
                    if (i) this.max = o;
                    else for(; this.max + r < t[t.length - 1];)t.pop();
                    0 === t.length && sx(s) && !this.options.tickPositions && t.push((o + s) / 2);
                }
            }
            alignToOthers() {
                let t;
                let e = this, i = e.chart, s = [
                    this
                ], o = e.options, r = i.options.chart, a = "yAxis" === this.coll && r.alignThresholds, n = [];
                if (e.thresholdAlignment = void 0, (!1 !== r.alignTicks && o.alignTicks || a) && !1 !== o.startOnTick && !1 !== o.endOnTick && !e.logarithmic) {
                    let o = (t)=>{
                        let { horiz: e, options: i } = t;
                        return [
                            e ? i.left : i.top,
                            i.width,
                            i.height,
                            i.pane
                        ].join(",");
                    }, r = o(this);
                    i[this.coll].forEach(function(i) {
                        let { series: a } = i;
                        a.length && a.some((t)=>t.visible) && i !== e && o(i) === r && (t = !0, s.push(i));
                    });
                }
                if (t && a) {
                    s.forEach((t)=>{
                        let i = t.getThresholdAlignment(e);
                        sC(i) && n.push(i);
                    });
                    let t = n.length > 1 ? n.reduce((t, e)=>t += e, 0) / n.length : void 0;
                    s.forEach((e)=>{
                        e.thresholdAlignment = t;
                    });
                }
                return t;
            }
            getThresholdAlignment(t) {
                if ((!sC(this.dataMin) || this !== t && this.series.some((t)=>t.isDirty || t.isDirtyData)) && this.getSeriesExtremes(), sC(this.threshold)) {
                    let t = sf((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
                    return this.options.reversed && (t = 1 - t), t;
                }
            }
            getTickAmount() {
                let t = this.options, e = t.tickPixelInterval, i = t.tickAmount;
                sx(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;
            }
            adjustTickAmount() {
                let t = this, { finalTickAmt: e, max: i, min: s, options: o, tickPositions: r, tickAmount: a, thresholdAlignment: n } = t, h = r?.length, l = sE(t.threshold, t.softThreshold ? 0 : null), d, c, p = t.tickInterval, g, u = ()=>r.push(sm(r[r.length - 1] + p)), f = ()=>r.unshift(sm(r[0] - p));
                if (sC(n) && (g = n < .5 ? Math.ceil(n * (a - 1)) : Math.floor(n * (a - 1)), o.reversed && (g = a - 1 - g)), t.hasData() && sC(s) && sC(i)) {
                    let n = ()=>{
                        t.transA *= (h - 1) / (a - 1), t.min = o.startOnTick ? r[0] : Math.min(s, r[0]), t.max = o.endOnTick ? r[r.length - 1] : Math.max(i, r[r.length - 1]);
                    };
                    if (sC(g) && sC(t.threshold)) {
                        for(; r[g] !== l || r.length !== a || r[0] > s || r[r.length - 1] < i;){
                            for(r.length = 0, r.push(t.threshold); r.length < a;)void 0 === r[g] || r[g] > t.threshold ? f() : u();
                            if (p > 8 * t.tickInterval) break;
                            p *= 2;
                        }
                        n();
                    } else if (h < a) {
                        for(; r.length < a;)r.length % 2 || s === l ? u() : f();
                        n();
                    }
                    if (sx(e)) {
                        for(c = d = r.length; c--;)(3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && r.splice(c, 1);
                        t.finalTickAmt = void 0;
                    }
                }
            }
            setScale() {
                let { coll: t, stacking: e } = this, i = !1, s = !1;
                this.series.forEach((t)=>{
                    i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis && t.xAxis.isDirty || !1;
                }), this.setAxisSize();
                let o = this.len !== (this.old && this.old.len);
                o || i || s || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e && "yAxis" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && "xAxis" === t && e.buildStacks(), this.isDirty || (this.isDirty = o || this.min !== this.old?.min || this.max !== this.old?.max)) : e && e.cleanStacks(), i && delete this.allExtremes, sw(this, "afterSetScale");
            }
            setExtremes(t, e, i = !0, s, o) {
                let r = this.chart;
                this.series.forEach((t)=>{
                    delete t.kdTree;
                }), t = r.time.parse(t), e = r.time.parse(e), sw(this, "setExtremes", o = sk(o, {
                    min: t,
                    max: e
                }), (t)=>{
                    this.userMin = t.min, this.userMax = t.max, this.eventArgs = t, i && r.redraw(s);
                });
            }
            setAxisSize() {
                let t = this.chart, e = this.options, i = e.offsets || [
                    0,
                    0,
                    0,
                    0
                ], s = this.horiz, o = this.width = Math.round(sI(sE(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)), r = this.height = Math.round(sI(sE(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)), a = this.top = Math.round(sI(sE(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)), n = this.left = Math.round(sI(sE(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));
                this.bottom = t.chartHeight - r - a, this.right = t.chartWidth - o - n, this.len = Math.max(s ? o : r, 0), this.pos = s ? n : a;
            }
            getExtremes() {
                let t = this.logarithmic;
                return {
                    min: t ? sm(t.lin2log(this.min)) : this.min,
                    max: t ? sm(t.lin2log(this.max)) : this.max,
                    dataMin: this.dataMin,
                    dataMax: this.dataMax,
                    userMin: this.userMin,
                    userMax: this.userMax
                };
            }
            getThreshold(t) {
                let e = this.logarithmic, i = e ? e.lin2log(this.min) : this.min, s = e ? e.lin2log(this.max) : this.max;
                return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);
            }
            autoLabelAlign(t) {
                let e = (sE(t, 0) - 90 * this.side + 720) % 360, i = {
                    align: "center"
                };
                return sw(this, "autoLabelAlign", i, function(t) {
                    e > 15 && e < 165 ? t.align = "right" : e > 195 && e < 345 && (t.align = "left");
                }), i.align;
            }
            tickSize(t) {
                let e = this.options, i = sE(e["tick" === t ? "tickWidth" : "minorTickWidth"], "tick" === t && this.isXAxis && !this.categories ? 1 : 0), s = e["tick" === t ? "tickLength" : "minorTickLength"], o;
                i && s && ("inside" === e[t + "Position"] && (s = -s), o = [
                    s,
                    i
                ]);
                let r = {
                    tickSize: o
                };
                return sw(this, "afterTickSize", r), r.tickSize;
            }
            labelMetrics() {
                let t = this.chart.renderer, e = this.ticks, i = e[Object.keys(e)[0]] || {};
                return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);
            }
            unsquish() {
                let t = this.options.labels, e = t.padding || 0, i = this.horiz, s = this.tickInterval, o = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s), r = t.rotation, a = sm(.8 * this.labelMetrics().h), n = Math.max(this.max - this.min, 0), h = function(t) {
                    let i = (t + 2 * e) / (o || 1);
                    return (i = i > 1 ? Math.ceil(i) : 1) * s > n && t !== 1 / 0 && o !== 1 / 0 && n && (i = Math.ceil(n / s)), sm(i * s);
                }, l = s, d, c = Number.MAX_VALUE, p;
                if (i) {
                    if (!t.staggerLines && (sC(r) ? p = [
                        r
                    ] : o < t.autoRotationLimit && (p = t.autoRotation)), p) {
                        let t, e;
                        for (let i of p)(i === r || i && i >= -90 && i <= 90) && (e = (t = h(Math.abs(a / Math.sin(sp * i)))) + Math.abs(i / 360)) < c && (c = e, d = i, l = t);
                    }
                } else l = h(.75 * a);
                return this.autoRotation = p, this.labelRotation = sE(d, sC(r) ? r : 0), t.step ? s : l;
            }
            getSlotWidth(t) {
                let e = this.chart, i = this.horiz, s = this.options.labels, o = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), r = e.margin[3];
                if (t && sC(t.slotWidth)) return t.slotWidth;
                if (i && s.step < 2 && !this.isRadial) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / o;
                if (!i) {
                    let t = s.style.width;
                    if (void 0 !== t) return parseInt(String(t), 10);
                    if (r) return r - e.spacing[3];
                }
                return .33 * e.chartWidth;
            }
            renderUnsquish() {
                let t = this.chart, e = t.renderer, i = this.tickPositions, s = this.ticks, o = this.options.labels, r = o.style, a = this.horiz, n = this.getSlotWidth(), h = Math.max(1, Math.round(n - (a ? 2 * (o.padding || 0) : o.distance || 0))), l = {}, d = this.labelMetrics(), c = r.lineClamp, p, g = c ?? (Math.floor(this.len / (i.length * d.h)) || 1), u = 0;
                sA(o.rotation) || (l.rotation = o.rotation || 0), i.forEach(function(t) {
                    let e = s[t];
                    e.movedLabel && e.replaceMovedLabel();
                    let i = e.label?.textPxLength || 0;
                    i > u && (u = i);
                }), this.maxLabelLength = u, this.autoRotation ? u > h && u > d.h ? l.rotation = this.labelRotation : this.labelRotation = 0 : n && (p = h), l.rotation && (p = u > .5 * t.chartHeight ? .33 * t.chartHeight : u, c || (g = 1)), this.labelAlign = o.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l.align = this.labelAlign), i.forEach(function(t) {
                    let e = s[t], i = e && e.label, o = r.width, a = {};
                    i && (i.attr(l), e.shortenLabel ? e.shortenLabel() : p && !o && "nowrap" !== r.whiteSpace && (p < (i.textPxLength || 0) || "SPAN" === i.element.tagName) ? i.css(sk(a, {
                        width: `${p}px`,
                        lineClamp: g
                    })) : !i.styles.width || a.width || o || i.css({
                        width: "auto"
                    }), e.rotation = l.rotation);
                }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);
            }
            hasData() {
                return this.series.some(function(t) {
                    return t.hasData();
                }) || this.options.showEmpty && sx(this.min) && sx(this.max);
            }
            addTitle(t) {
                let e;
                let i = this.chart.renderer, s = this.horiz, o = this.opposite, r = this.options.title, a = this.chart.styledMode;
                this.axisTitle || ((e = r.textAlign) || (e = (s ? {
                    low: "left",
                    middle: "center",
                    high: "right"
                } : {
                    low: o ? "right" : "left",
                    middle: "center",
                    high: o ? "left" : "right"
                })[r.align]), this.axisTitle = i.text(r.text || "", 0, 0, r.useHTML).attr({
                    zIndex: 7,
                    rotation: r.rotation || 0,
                    align: e
                }).addClass("highcharts-axis-title"), a || this.axisTitle.css(sP(r.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), a || r.style.width || this.isRadial || this.axisTitle.css({
                    width: this.len + "px"
                }), this.axisTitle[t ? "show" : "hide"](t);
            }
            generateTick(t) {
                let e = this.ticks;
                e[t] ? e[t].addLabel() : e[t] = new sa(this, t);
            }
            createGroups() {
                let { axisParent: t, chart: e, coll: i, options: s } = this, o = e.renderer, r = (e, r, a)=>o.g(e).attr({
                        zIndex: a
                    }).addClass(`highcharts-${i.toLowerCase()}${r} ` + (this.isRadial ? `highcharts-radial-axis${r} ` : "") + (s.className || "")).add(t);
                this.axisGroup || (this.gridGroup = r("grid", "-grid", s.gridZIndex), this.axisGroup = r("axis", "", s.zIndex), this.labelGroup = r("axis-labels", "-labels", s.labels.zIndex));
            }
            getOffset() {
                let t = this, { chart: e, horiz: i, options: s, side: o, ticks: r, tickPositions: a, coll: n } = t, h = e.inverted && !t.isZAxis ? [
                    1,
                    0,
                    3,
                    2
                ][o] : o, l = t.hasData(), d = s.title, c = s.labels, p = sC(s.crossing), g = e.axisOffset, u = e.clipOffset, f = [
                    -1,
                    1,
                    1,
                    -1
                ][o], m, x = 0, y, b = 0, v = 0, k, w;
                if (t.showAxis = m = l || s.showEmpty, t.staggerLines = t.horiz && c.staggerLines || void 0, t.createGroups(), l || t.isLinked ? (a.forEach(function(e) {
                    t.generateTick(e);
                }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === o || 2 === o || ({
                    1: "left",
                    3: "right"
                })[o] === t.labelAlign, sE(c.reserveSpace, !p && null, "center" === t.labelAlign || null, t.reserveSpaceDefault) && a.forEach(function(t) {
                    v = Math.max(r[t].getLabelSize(), v);
                }), t.staggerLines && (v *= t.staggerLines), t.labelOffset = v * (t.opposite ? -1 : 1)) : sO(r, function(t, e) {
                    t.destroy(), delete r[e];
                }), d?.text && !1 !== d.enabled && (t.addTitle(m), m && !p && !1 !== d.reserveSpace && (t.titleOffset = x = t.axisTitle.getBBox()[i ? "height" : "width"], b = sx(y = d.offset) ? 0 : sE(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * sE(s.offset, g[o] ? g[o] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {
                    x: 0,
                    y: 0
                }, w = 0 === o ? -t.labelMetrics().h : 2 === o ? t.tickRotCorr.y : 0, k = Math.abs(v) + b, v && (k -= w, k += f * (i ? sE(c.y, t.tickRotCorr.y + f * c.distance) : sE(c.x, f * c.distance))), t.axisTitleMargin = sE(y, k), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(r, a)), "colorAxis" !== n && u) {
                    let e = this.tickSize("tick");
                    g[o] = Math.max(g[o], (t.axisTitleMargin || 0) + x + f * t.offset, k, a && a.length && e ? e[0] + f * t.offset : 0);
                    let i = !t.axisLine || s.offset ? 0 : t.axisLine.strokeWidth() / 2;
                    u[h] = Math.max(u[h], i);
                }
                sw(this, "afterGetOffset");
            }
            getLinePath(t) {
                let e = this.chart, i = this.opposite, s = this.offset, o = this.horiz, r = this.left + (i ? this.width : 0) + s, a = e.chartHeight - this.bottom - (i ? this.height : 0) + s;
                return i && (t *= -1), e.renderer.crispLine([
                    [
                        "M",
                        o ? this.left : r,
                        o ? a : this.top
                    ],
                    [
                        "L",
                        o ? e.chartWidth - this.right : r,
                        o ? a : e.chartHeight - this.bottom
                    ]
                ], t);
            }
            renderLine() {
                this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                    stroke: this.options.lineColor,
                    "stroke-width": this.options.lineWidth,
                    zIndex: 7
                }));
            }
            getTitlePosition(t) {
                let e = this.horiz, i = this.left, s = this.top, o = this.len, r = this.options.title, a = e ? i : s, n = this.opposite, h = this.offset, l = r.x, d = r.y, c = this.chart.renderer.fontMetrics(t), p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0, g = {
                    low: a + (e ? 0 : o),
                    middle: a + o / 2,
                    high: a + (e ? o : 0)
                }[r.align], u = (e ? s + this.height : i) + (e ? 1 : -1) * (n ? -1 : 1) * (this.axisTitleMargin || 0) + [
                    -p,
                    p,
                    c.f,
                    -p
                ][this.side], f = {
                    x: e ? g + l : u + (n ? this.width : 0) + h + l,
                    y: e ? u + d - (n ? this.height : 0) + h : g + d
                };
                return sw(this, "afterGetTitlePosition", {
                    titlePosition: f
                }), f;
            }
            renderMinorTick(t, e) {
                let i = this.minorTicks;
                i[t] || (i[t] = new sa(this, t, "minor")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);
            }
            renderTick(t, e, i) {
                let s = this.isLinked, o = this.ticks;
                (!s || t >= this.min && t <= this.max || this.grid && this.grid.isColumn) && (o[t] || (o[t] = new sa(this, t)), i && o[t].isNew && o[t].render(e, !0, -1), o[t].render(e));
            }
            render() {
                let t, e;
                let i = this, s = i.chart, o = i.logarithmic, r = s.renderer, a = i.options, n = i.isLinked, h = i.tickPositions, l = i.axisTitle, d = i.ticks, c = i.minorTicks, p = i.alternateBands, g = a.stackLabels, u = a.alternateGridColor, f = a.crossing, m = i.tickmarkOffset, x = i.axisLine, y = i.showAxis, b = sn(r.globalAnimation);
                if (i.labelEdge.length = 0, i.overlap = !1, [
                    d,
                    c,
                    p
                ].forEach(function(t) {
                    sO(t, function(t) {
                        t.isActive = !1;
                    });
                }), sC(f)) {
                    let t = this.isXAxis ? s.yAxis[0] : s.xAxis[0], e = [
                        1,
                        -1,
                        -1,
                        1
                    ][this.side];
                    if (t) {
                        let s = t.toPixels(f, !0);
                        i.horiz && (s = t.len - s), i.offset = e * s;
                    }
                }
                if (i.hasData() || n) {
                    let r = i.chart.hasRendered && i.old && sC(i.old.min);
                    i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function(t) {
                        i.renderMinorTick(t, r);
                    }), h.length && (h.forEach(function(t, e) {
                        i.renderTick(t, e, r);
                    }), m && (0 === i.min || i.single) && (d[-1] || (d[-1] = new sa(i, -1, null, !0)), d[-1].render(-1))), u && h.forEach(function(r, a) {
                        e = void 0 !== h[a + 1] ? h[a + 1] + m : i.max - m, a % 2 == 0 && r < i.max && e <= i.max + (s.polar ? -m : m) && (p[r] || (p[r] = new k.PlotLineOrBand(i, {})), t = r + m, p[r].options = {
                            from: o ? o.lin2log(t) : t,
                            to: o ? o.lin2log(e) : e,
                            color: u,
                            className: "highcharts-alternate-grid"
                        }, p[r].render(), p[r].isActive = !0);
                    }), i._addedPlotLB || (i._addedPlotLB = !0, (a.plotLines || []).concat(a.plotBands || []).forEach(function(t) {
                        i.addPlotBandOrLine(t);
                    }));
                }
                [
                    d,
                    c,
                    p
                ].forEach(function(t) {
                    let e = [], i = b.duration;
                    sO(t, function(t, i) {
                        t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));
                    }), sN(function() {
                        let i = e.length;
                        for(; i--;)t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);
                    }, t !== p && s.hasRendered && i ? i : 0);
                }), x && (x[x.isPlaced ? "animate" : "attr"]({
                    d: this.getLinePath(x.strokeWidth())
                }), x.isPlaced = !0, x[y ? "show" : "hide"](y)), l && y && (l[l.isNew ? "attr" : "animate"](i.getTitlePosition(l)), l.isNew = !1), g && g.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {
                    len: i.len,
                    max: i.max,
                    min: i.min,
                    transA: i.transA,
                    userMax: i.userMax,
                    userMin: i.userMin
                }, i.isDirty = !1, sw(this, "afterRender");
            }
            redraw() {
                this.visible && (this.render(), this.plotLinesAndBands.forEach(function(t) {
                    t.render();
                })), this.series.forEach(function(t) {
                    t.isDirty = !0;
                });
            }
            getKeepProps() {
                return this.keepProps || sR.keepProps;
            }
            destroy(t) {
                let e = this, i = e.plotLinesAndBands, s = this.eventOptions;
                if (sw(this, "destroy", {
                    keepEvents: t
                }), t || sD(e), [
                    e.ticks,
                    e.minorTicks,
                    e.alternateBands
                ].forEach(function(t) {
                    sy(t);
                }), i) {
                    let t = i.length;
                    for(; t--;)i[t].destroy();
                }
                for(let t in [
                    "axisLine",
                    "axisTitle",
                    "axisGroup",
                    "gridGroup",
                    "labelGroup",
                    "cross",
                    "scrollbar"
                ].forEach(function(t) {
                    e[t] && (e[t] = e[t].destroy());
                }), e.plotLinesAndBandsGroups)e.plotLinesAndBandsGroups[t] = e.plotLinesAndBandsGroups[t].destroy();
                sO(e, function(t, i) {
                    -1 === e.getKeepProps().indexOf(i) && delete e[i];
                }), this.eventOptions = s;
            }
            drawCrosshair(t, e) {
                let i = this.crosshair, s = sE(i && i.snap, !0), o = this.chart, r, a, n, h = this.cross, l;
                if (sw(this, "drawCrosshair", {
                    e: t,
                    point: e
                }), t || (t = this.cross && this.cross.e), i && !1 !== (sx(e) || !s)) {
                    if (s ? sx(e) && (a = sE("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : a = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), sx(a) && (l = {
                        value: e && (this.isXAxis ? e.x : sE(e.stackY, e.y)),
                        translatedValue: a
                    }, o.polar && sk(l, {
                        isCrosshair: !0,
                        chartX: t && t.chartX,
                        chartY: t && t.chartY,
                        point: e
                    }), r = this.getPlotLinePath(l) || null), !sx(r)) {
                        this.hideCrosshair();
                        return;
                    }
                    n = this.categories && !this.isRadial, h || (this.cross = h = o.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (n ? "category " : "thin ") + (i.className || "")).attr({
                        zIndex: sE(i.zIndex, 2)
                    }).add(), !o.styledMode && (h.attr({
                        stroke: i.color || (n ? tk.parse("#ccd3ff").setOpacity(.25).get() : "#cccccc"),
                        "stroke-width": sE(i.width, 1)
                    }).css({
                        "pointer-events": "none"
                    }), i.dashStyle && h.attr({
                        dashstyle: i.dashStyle
                    }))), h.show().attr({
                        d: r
                    }), n && !i.width && h.attr({
                        "stroke-width": this.transA
                    }), this.cross.e = t;
                } else this.hideCrosshair();
                sw(this, "afterDrawCrosshair", {
                    e: t,
                    point: e
                });
            }
            hideCrosshair() {
                this.cross && this.cross.hide(), sw(this, "afterHideCrosshair");
            }
            update(t, e) {
                let i = this.chart;
                t = sP(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, sE(e, !0) && i.redraw();
            }
            remove(t) {
                let e = this.chart, i = this.coll, s = this.series, o = s.length;
                for(; o--;)s[o] && s[o].remove(!1);
                sb(e.axes, this), sb(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, sE(t, !0) && e.redraw();
            }
            setTitle(t, e) {
                this.update({
                    title: t
                }, e);
            }
            setCategories(t, e) {
                this.update({
                    categories: t
                }, e);
            }
        }
        sR.keepProps = [
            "coll",
            "extKey",
            "hcEvents",
            "len",
            "names",
            "series",
            "userMax",
            "userMin"
        ];
        let { addEvent: sW, getMagnitude: sH, normalizeTickInterval: sX, timeUnits: sF } = $;
        !function(t) {
            function e() {
                return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }
            function i() {
                if ("datetime" !== this.type) {
                    this.dateTime = void 0;
                    return;
                }
                this.dateTime || (this.dateTime = new s(this));
            }
            t.compose = function(t) {
                return t.keepProps.includes("dateTime") || (t.keepProps.push("dateTime"), t.prototype.getTimeTicks = e, sW(t, "afterSetType", i)), t;
            };
            class s {
                constructor(t){
                    this.axis = t;
                }
                normalizeTimeTickInterval(t, e) {
                    let i = e || [
                        [
                            "millisecond",
                            [
                                1,
                                2,
                                5,
                                10,
                                20,
                                25,
                                50,
                                100,
                                200,
                                500
                            ]
                        ],
                        [
                            "second",
                            [
                                1,
                                2,
                                5,
                                10,
                                15,
                                30
                            ]
                        ],
                        [
                            "minute",
                            [
                                1,
                                2,
                                5,
                                10,
                                15,
                                30
                            ]
                        ],
                        [
                            "hour",
                            [
                                1,
                                2,
                                3,
                                4,
                                6,
                                8,
                                12
                            ]
                        ],
                        [
                            "day",
                            [
                                1,
                                2
                            ]
                        ],
                        [
                            "week",
                            [
                                1,
                                2
                            ]
                        ],
                        [
                            "month",
                            [
                                1,
                                2,
                                3,
                                4,
                                6
                            ]
                        ],
                        [
                            "year",
                            null
                        ]
                    ], s = i[i.length - 1], o = sF[s[0]], r = s[1], a;
                    for(a = 0; a < i.length && (o = sF[(s = i[a])[0]], r = s[1], !i[a + 1] || !(t <= (o * r[r.length - 1] + sF[i[a + 1][0]]) / 2)); a++);
                    o === sF.year && t < 5 * o && (r = [
                        1,
                        2,
                        5
                    ]);
                    let n = sX(t / o, r, "year" === s[0] ? Math.max(sH(t / o), 1) : 1);
                    return {
                        unitRange: o,
                        count: n,
                        unitName: s[0]
                    };
                }
                getXDateFormat(t, e) {
                    let { axis: i } = this, s = i.chart.time;
                    return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;
                }
            }
            t.Additions = s;
        }(n || (n = {}));
        let sG = n, { addEvent: sY, normalizeTickInterval: sj, pick: sU } = $;
        !function(t) {
            function e() {
                "logarithmic" !== this.type ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new s(this));
            }
            function i() {
                let t = this.logarithmic;
                t && (this.lin2val = function(e) {
                    return t.lin2log(e);
                }, this.val2lin = function(e) {
                    return t.log2lin(e);
                });
            }
            t.compose = function(t) {
                return t.keepProps.includes("logarithmic") || (t.keepProps.push("logarithmic"), sY(t, "afterSetType", e), sY(t, "afterInit", i)), t;
            };
            class s {
                constructor(t){
                    this.axis = t;
                }
                getLogTickPositions(t, e, i, s) {
                    let o = this.axis, r = o.len, a = o.options, n = [];
                    if (s || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), n = o.getLinearTickPositions(t, e, i);
                    else if (t >= .08) {
                        let o, r, a, h, l, d, c;
                        let p = Math.floor(e);
                        for(o = t > .3 ? [
                            1,
                            2,
                            4
                        ] : t > .15 ? [
                            1,
                            2,
                            4,
                            6,
                            8
                        ] : [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9
                        ], r = p; r < i + 1 && !c; r++)for(a = 0, h = o.length; a < h && !c; a++)(l = this.log2lin(this.lin2log(r) * o[a])) > e && (!s || d <= i) && void 0 !== d && n.push(d), d > i && (c = !0), d = l;
                    } else {
                        let h = this.lin2log(e), l = this.lin2log(i), d = s ? o.getMinorTickInterval() : a.tickInterval, c = a.tickPixelInterval / (s ? 5 : 1), p = s ? r / o.tickPositions.length : r;
                        t = sj(t = sU("auto" === d ? null : d, this.minorAutoInterval, (l - h) * c / (p || 1))), n = o.getLinearTickPositions(t, h, l).map(this.log2lin), s || (this.minorAutoInterval = t / 5);
                    }
                    return s || (o.tickInterval = t), n;
                }
                lin2log(t) {
                    return Math.pow(10, t);
                }
                log2lin(t) {
                    return Math.log(t) / Math.LN10;
                }
            }
            t.Additions = s;
        }(h || (h = {}));
        let s$ = h, { erase: sV, extend: s_, isNumber: sq } = $;
        !function(t) {
            let e;
            function i(t) {
                return this.addPlotBandOrLine(t, "plotBands");
            }
            function s(t, i) {
                let s = this.userOptions, o = new e(this, t);
                if (this.visible && (o = o.render()), o) {
                    if (this._addedPlotLB || (this._addedPlotLB = !0, (s.plotLines || []).concat(s.plotBands || []).forEach((t)=>{
                        this.addPlotBandOrLine(t);
                    })), i) {
                        let e = s[i] || [];
                        e.push(t), s[i] = e;
                    }
                    this.plotLinesAndBands.push(o);
                }
                return o;
            }
            function o(t) {
                return this.addPlotBandOrLine(t, "plotLines");
            }
            function r(t, e, i) {
                i = i || this.options;
                let s = this.getPlotLinePath({
                    value: e,
                    force: !0,
                    acrossPanes: i.acrossPanes
                }), o = [], r = this.horiz, a = !sq(this.min) || !sq(this.max) || t < this.min && e < this.min || t > this.max && e > this.max, n = this.getPlotLinePath({
                    value: t,
                    force: !0,
                    acrossPanes: i.acrossPanes
                }), h, l = 1, d;
                if (n && s) for(a && (d = n.toString() === s.toString(), l = 0), h = 0; h < n.length; h += 2){
                    let t = n[h], e = n[h + 1], i = s[h], a = s[h + 1];
                    ("M" === t[0] || "L" === t[0]) && ("M" === e[0] || "L" === e[0]) && ("M" === i[0] || "L" === i[0]) && ("M" === a[0] || "L" === a[0]) && (r && i[1] === t[1] ? (i[1] += l, a[1] += l) : r || i[2] !== t[2] || (i[2] += l, a[2] += l), o.push([
                        "M",
                        t[1],
                        t[2]
                    ], [
                        "L",
                        e[1],
                        e[2]
                    ], [
                        "L",
                        a[1],
                        a[2]
                    ], [
                        "L",
                        i[1],
                        i[2]
                    ], [
                        "Z"
                    ])), o.isFlat = d;
                }
                return o;
            }
            function a(t) {
                this.removePlotBandOrLine(t);
            }
            function n(t) {
                let e = this.plotLinesAndBands, i = this.options, s = this.userOptions;
                if (e) {
                    let o = e.length;
                    for(; o--;)e[o].id === t && e[o].destroy();
                    [
                        i.plotLines || [],
                        s.plotLines || [],
                        i.plotBands || [],
                        s.plotBands || []
                    ].forEach(function(e) {
                        for(o = e.length; o--;)(e[o] || {}).id === t && sV(e, e[o]);
                    });
                }
            }
            function h(t) {
                this.removePlotBandOrLine(t);
            }
            t.compose = function(t, l) {
                let d = l.prototype;
                return d.addPlotBand || (e = t, s_(d, {
                    addPlotBand: i,
                    addPlotLine: o,
                    addPlotBandOrLine: s,
                    getPlotBandPath: r,
                    removePlotBand: a,
                    removePlotLine: h,
                    removePlotBandOrLine: n
                })), l;
            };
        }(l || (l = {}));
        let sZ = l, { addEvent: sK, arrayMax: sJ, arrayMin: sQ, defined: s0, destroyObjectProperties: s1, erase: s2, fireEvent: s3, merge: s5, objectEach: s6, pick: s9 } = $;
        class s4 {
            static compose(t, e) {
                return sK(t, "afterInit", function() {
                    this.labelCollectors.push(()=>{
                        let t = [];
                        for (let e of this.axes)for (let { label: i, options: s } of e.plotLinesAndBands)i && !s?.label?.allowOverlap && t.push(i);
                        return t;
                    });
                }), sZ.compose(s4, e);
            }
            constructor(t, e){
                this.axis = t, this.options = e, this.id = e.id;
            }
            render() {
                s3(this, "render");
                let { axis: t, options: e } = this, { horiz: i, logarithmic: s } = t, { color: o, events: r, zIndex: a = 0 } = e, { renderer: n, time: h } = t.chart, l = {}, d = h.parse(e.to), c = h.parse(e.from), p = h.parse(e.value), g = e.borderWidth, u = e.label, { label: f, svgElem: m } = this, x = [], y, b = s0(c) && s0(d), v = s0(p), k = !m, w = {
                    class: "highcharts-plot-" + (b ? "band " : "line ") + (e.className || "")
                }, M = b ? "bands" : "lines";
                if (!t.chart.styledMode && (v ? (w.stroke = o || "#999999", w["stroke-width"] = s9(e.width, 1), e.dashStyle && (w.dashstyle = e.dashStyle)) : b && (w.fill = o || "#e6e9ff", g && (w.stroke = e.borderColor, w["stroke-width"] = g))), l.zIndex = a, M += "-" + a, (y = t.plotLinesAndBandsGroups[M]) || (t.plotLinesAndBandsGroups[M] = y = n.g("plot-" + M).attr(l).add()), m || (this.svgElem = m = n.path().attr(w).add(y)), s0(p)) x = t.getPlotLinePath({
                    value: s?.log2lin(p) ?? p,
                    lineWidth: m.strokeWidth(),
                    acrossPanes: e.acrossPanes
                });
                else {
                    if (!(s0(c) && s0(d))) return;
                    x = t.getPlotBandPath(s?.log2lin(c) ?? c, s?.log2lin(d) ?? d, e);
                }
                return !this.eventsAdded && r && (s6(r, (t, e)=>{
                    m?.on(e, (t)=>{
                        r[e].apply(this, [
                            t
                        ]);
                    });
                }), this.eventsAdded = !0), (k || !m.d) && x?.length ? m.attr({
                    d: x
                }) : m && (x ? (m.show(), m.animate({
                    d: x
                })) : m.d && (m.hide(), f && (this.label = f = f.destroy()))), u && (s0(u.text) || s0(u.formatter)) && x?.length && t.width > 0 && t.height > 0 && !x.isFlat ? (u = s5({
                    align: i && b ? "center" : void 0,
                    x: i ? !b && 4 : 10,
                    verticalAlign: !i && b ? "middle" : void 0,
                    y: i ? b ? 16 : 10 : b ? 6 : -4,
                    rotation: i && !b ? 90 : 0,
                    ...b ? {
                        inside: !0
                    } : {}
                }, u), this.renderLabel(u, x, b, a)) : f && f.hide(), this;
            }
            renderLabel(t, e, i, s) {
                let o = this.axis, r = o.chart.renderer, a = t.inside, n = this.label;
                n || (this.label = n = r.text(this.getLabelText(t), 0, 0, t.useHTML).attr({
                    align: t.textAlign || t.align,
                    rotation: t.rotation,
                    class: "highcharts-plot-" + (i ? "band" : "line") + "-label " + (t.className || ""),
                    zIndex: s
                }), o.chart.styledMode || n.css(s5({
                    fontSize: "0.8em",
                    textOverflow: i && !a ? "" : "ellipsis"
                }, t.style)), n.add());
                let h = e.xBounds || [
                    e[0][1],
                    e[1][1],
                    i ? e[2][1] : e[0][1]
                ], l = e.yBounds || [
                    e[0][2],
                    e[1][2],
                    i ? e[2][2] : e[0][2]
                ], d = sQ(h), c = sQ(l), p = sJ(h) - d;
                n.align(t, !1, {
                    x: d,
                    y: c,
                    width: p,
                    height: sJ(l) - c
                }), (!n.alignValue || "left" === n.alignValue || s0(a)) && n.css({
                    width: (t.style?.width || (i && a ? p : 90 === n.rotation ? o.height - (n.alignAttr.y - o.top) : (t.clip ? o.width : o.chart.chartWidth) - (n.alignAttr.x - o.left))) + "px"
                }), n.show(!0);
            }
            getLabelText(t) {
                return s0(t.formatter) ? t.formatter.call(this) : t.text;
            }
            destroy() {
                s2(this.axis.plotLinesAndBands, this), delete this.axis, s1(this);
            }
        }
        let { animObject: s8 } = tR, { format: s7 } = eo, { composed: ot, dateFormats: oe, doc: oi, isSafari: os } = k, { distribute: oo } = ed, { addEvent: or, clamp: oa, css: on, discardElement: oh, extend: ol, fireEvent: od, isArray: oc, isNumber: op, isObject: og, isString: ou, merge: of, pick: om, pushUnique: ox, splat: oy, syncTimeout: ob } = $;
        class ov {
            constructor(t, e, i){
                this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e), this.pointer = i;
            }
            bodyFormatter(t) {
                return t.map((t)=>{
                    let e = t.series.tooltipOptions, i = t.formatPrefix || "point";
                    return (e[i + "Formatter"] || t.tooltipFormatter).call(t, e[i + "Format"] || "");
                });
            }
            cleanSplit(t) {
                this.chart.series.forEach(function(e) {
                    let i = e && e.tt;
                    i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);
                });
            }
            defaultFormatter(t) {
                let e;
                let i = this.points || oy(this);
                return (e = (e = [
                    t.headerFooterFormatter(i[0])
                ]).concat(t.bodyFormatter(i))).push(t.headerFooterFormatter(i[0], !0)), e;
            }
            destroy() {
                this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), oh(this.container)), $.clearTimeout(this.hideTimer);
            }
            getAnchor(t, e) {
                let i;
                let { chart: s, pointer: o } = this, r = s.inverted, a = s.plotTop, n = s.plotLeft;
                if ((t = oy(t))[0].series && t[0].series.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = o.normalize(e)), i = [
                    e.chartX - n,
                    e.chartY - a
                ];
                else if (t[0].tooltipPos) i = t[0].tooltipPos;
                else {
                    let s = 0, o = 0;
                    t.forEach(function(t) {
                        let e = t.pos(!0);
                        e && (s += e[0], o += e[1]);
                    }), s /= t.length, o /= t.length, this.shared && t.length > 1 && e && (r ? s = e.chartX : o = e.chartY), i = [
                        s - n,
                        o - a
                    ];
                }
                return i.map(Math.round);
            }
            getClassName(t, e, i) {
                let s = this.options, o = t.series, r = o.options;
                return [
                    s.className,
                    "highcharts-label",
                    i && "highcharts-tooltip-header",
                    e ? "highcharts-tooltip-box" : "highcharts-tooltip",
                    !i && "highcharts-color-" + om(t.colorIndex, o.colorIndex),
                    r && r.className
                ].filter(ou).join(" ");
            }
            getLabel({ anchorX: t, anchorY: e } = {
                anchorX: 0,
                anchorY: 0
            }) {
                let i = this, s = this.chart.styledMode, o = this.options, r = this.split && this.allowShared, a = this.container, n = this.chart.renderer;
                if (this.label) {
                    let t = !this.label.hasClass("highcharts-label");
                    (!r && t || r && !t) && this.destroy();
                }
                if (!this.label) {
                    if (this.outside) {
                        let t = this.chart, e = t.options.chart.style, i = er.getRendererType();
                        this.container = a = k.doc.createElement("div"), a.className = "highcharts-tooltip-container " + (t.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || ""), on(a, {
                            position: "absolute",
                            top: "1px",
                            pointerEvents: "none",
                            zIndex: Math.max(this.options.style.zIndex || 0, (e && e.zIndex || 0) + 3)
                        }), this.renderer = n = new i(a, 0, 0, e, void 0, void 0, n.styledMode);
                    }
                    if (r ? this.label = n.g("tooltip") : (this.label = n.label("", t, e, o.shape, void 0, void 0, o.useHTML, void 0, "tooltip").attr({
                        padding: o.padding,
                        r: o.borderRadius
                    }), s || this.label.attr({
                        fill: o.backgroundColor,
                        "stroke-width": o.borderWidth || 0
                    }).css(o.style).css({
                        pointerEvents: o.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
                    })), i.outside) {
                        let t = this.label;
                        [
                            t.xSetter,
                            t.ySetter
                        ].forEach((e, s)=>{
                            t[s ? "ySetter" : "xSetter"] = (o)=>{
                                e.call(t, i.distance), t[s ? "y" : "x"] = o, a && (a.style[s ? "top" : "left"] = `${o}px`);
                            };
                        });
                    }
                    this.label.attr({
                        zIndex: 8
                    }).shadow(o.shadow).add();
                }
                return a && !a.parentElement && k.doc.body.appendChild(a), this.label;
            }
            getPlayingField() {
                let { body: t, documentElement: e } = oi, { chart: i, distance: s, outside: o } = this;
                return {
                    width: o ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s - 2 : i.chartWidth,
                    height: o ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight
                };
            }
            getPosition(t, e, i) {
                let { distance: s, chart: o, outside: r, pointer: a } = this, { inverted: n, plotLeft: h, plotTop: l, polar: d } = o, { plotX: c = 0, plotY: p = 0 } = i, g = {}, u = n && i.h || 0, { height: f, width: m } = this.getPlayingField(), x = a.getChartPosition(), y = (t)=>t * x.scaleX, b = (t)=>t * x.scaleY, v = (i)=>{
                    let a = "x" === i;
                    return [
                        i,
                        a ? m : f,
                        a ? t : e
                    ].concat(r ? [
                        a ? y(t) : b(e),
                        a ? x.left - s + y(c + h) : x.top - s + b(p + l),
                        0,
                        a ? m : f
                    ] : [
                        a ? t : e,
                        a ? c + h : p + l,
                        a ? h : l,
                        a ? h + o.plotWidth : l + o.plotHeight
                    ]);
                }, k = v("y"), w = v("x"), M, S = !!i.negative;
                !d && o.hoverSeries?.yAxis?.reversed && (S = !S);
                let T = !this.followPointer && om(i.ttBelow, !d && !n === S), C = function(t, e, i, o, a, n, h) {
                    let l = r ? "y" === t ? b(s) : y(s) : s, d = (i - o) / 2, c = o < a - s, p = a + s + o < e, f = a - l - i + d, m = a + l - d;
                    if (T && p) g[t] = m;
                    else if (!T && c) g[t] = f;
                    else if (c) g[t] = Math.min(h - o, f - u < 0 ? f : f - u);
                    else {
                        if (!p) return !1;
                        g[t] = Math.max(n, m + u + i > e ? m : m + u);
                    }
                }, A = function(t, e, i, o, r) {
                    if (r < s || r > e - s) return !1;
                    r < i / 2 ? g[t] = 1 : r > e - o / 2 ? g[t] = e - o - 2 : g[t] = r - i / 2;
                }, P = function(t) {
                    [k, w] = [
                        w,
                        k
                    ], M = t;
                }, L = ()=>{
                    !1 !== C.apply(0, k) ? !1 !== A.apply(0, w) || M || (P(!0), L()) : M ? g.x = g.y = 0 : (P(!0), L());
                };
                return (n && !d || this.len > 1) && P(), L(), g;
            }
            hide(t) {
                let e = this;
                $.clearTimeout(this.hideTimer), t = om(t, this.options.hideDelay), this.isHidden || (this.hideTimer = ob(function() {
                    let i = e.getLabel();
                    e.getLabel().animate({
                        opacity: 0
                    }, {
                        duration: t ? 150 : t,
                        complete: ()=>{
                            i.hide(), e.container && e.container.remove();
                        }
                    }), e.isHidden = !0;
                }, t));
            }
            init(t, e) {
                this.chart = t, this.options = e, this.crosshairs = [], this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = om(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));
            }
            shouldStickOnContact(t) {
                return !!(!this.followPointer && this.options.stickOnContact && (!t || this.pointer.inClass(t.target, "highcharts-tooltip")));
            }
            move(t, e, i, s) {
                let o = this, r = s8(!o.isHidden && o.options.animation), a = o.followPointer || (o.len || 0) > 1, n = {
                    x: t,
                    y: e
                };
                a || (n.anchorX = i, n.anchorY = s), r.step = ()=>o.drawTracker(), o.getLabel().animate(n, r);
            }
            refresh(t, e) {
                let { chart: i, options: s, pointer: o, shared: r } = this, a = oy(t), n = a[0], h = s.format, l = s.formatter || this.defaultFormatter, d = i.styledMode, c = this.allowShared;
                if (!s.enabled || !n.series) return;
                $.clearTimeout(this.hideTimer), this.allowShared = !(!oc(t) && t.series && t.series.noSharedTooltip), c = c && !this.allowShared, this.followPointer = !this.split && n.series.tooltipOptions.followPointer;
                let p = this.getAnchor(t, e), g = p[0], u = p[1];
                r && this.allowShared && (o.applyInactiveState(a), a.forEach((t)=>t.setState("hover")), n.points = a), this.len = a.length;
                let f = ou(h) ? s7(h, n, i) : l.call(n, this);
                n.points = void 0;
                let m = n.series;
                if (this.distance = om(m.tooltipOptions.distance, 16), !1 === f) this.hide();
                else {
                    if (this.split && this.allowShared) this.renderSplit(f, a);
                    else {
                        let t = g, r = u;
                        if (e && o.isDirectTouch && (t = e.chartX - i.plotLeft, r = e.chartY - i.plotTop), i.polar || !1 === m.options.clip || a.some((e)=>o.isDirectTouch || e.series.shouldShowTooltip(t, r))) {
                            let t = this.getLabel(c && this.tt || {});
                            (!s.style.width || d) && t.css({
                                width: (this.outside ? this.getPlayingField() : i.spacingBox).width + "px"
                            }), t.attr({
                                class: this.getClassName(n),
                                text: f && f.join ? f.join("") : f
                            }), this.outside && t.attr({
                                x: oa(t.x || 0, 0, this.getPlayingField().width - (t.width || 0) - 1)
                            }), d || t.attr({
                                stroke: s.borderColor || n.color || m.color || "#666666"
                            }), this.updatePosition({
                                plotX: g,
                                plotY: u,
                                negative: n.negative,
                                ttBelow: n.ttBelow,
                                h: p[2] || 0
                            });
                        } else {
                            this.hide();
                            return;
                        }
                    }
                    this.isHidden && this.label && this.label.attr({
                        opacity: 1
                    }).show(), this.isHidden = !1;
                }
                od(this, "refresh");
            }
            renderSplit(t, e) {
                let i = this, { chart: s, chart: { chartWidth: o, chartHeight: r, plotHeight: a, plotLeft: n, plotTop: h, scrollablePixelsY: l = 0, scrollablePixelsX: d, styledMode: c }, distance: p, options: g, options: { positioner: u }, pointer: f } = i, { scrollLeft: m = 0, scrollTop: x = 0 } = s.scrollablePlotArea?.scrollingContainer || {}, y = i.outside && "number" != typeof d ? oi.documentElement.getBoundingClientRect() : {
                    left: m,
                    right: m + o,
                    top: x,
                    bottom: x + r
                }, b = i.getLabel(), v = this.renderer || s.renderer, k = !!(s.xAxis[0] && s.xAxis[0].opposite), { left: w, top: M } = f.getChartPosition(), S = h + x, T = 0, C = a - l;
                function A(t, e, s, o, r = !0) {
                    let a, n;
                    return s ? (a = k ? 0 : C, n = oa(t - o / 2, y.left, y.right - o - (i.outside ? w : 0))) : (a = e - S, n = oa(n = r ? t - o - p : t + p, r ? n : y.left, y.right)), {
                        x: n,
                        y: a
                    };
                }
                ou(t) && (t = [
                    !1,
                    t
                ]);
                let P = t.slice(0, e.length + 1).reduce(function(t, s, o) {
                    if (!1 !== s && "" !== s) {
                        let r = e[o - 1] || {
                            isHeader: !0,
                            plotX: e[0].plotX,
                            plotY: a,
                            series: {}
                        }, l = r.isHeader, d = l ? i : r.series, f = d.tt = function(t, e, s) {
                            let o = t, { isHeader: r, series: a } = e;
                            if (!o) {
                                let t = {
                                    padding: g.padding,
                                    r: g.borderRadius
                                };
                                c || (t.fill = g.backgroundColor, t["stroke-width"] = g.borderWidth ?? 1), o = v.label("", 0, 0, g[r ? "headerShape" : "shape"], void 0, void 0, g.useHTML).addClass(i.getClassName(e, !0, r)).attr(t).add(b);
                            }
                            return o.isActive = !0, o.attr({
                                text: s
                            }), c || o.css(g.style).attr({
                                stroke: g.borderColor || e.color || a.color || "#333333"
                            }), o;
                        }(d.tt, r, s.toString()), m = f.getBBox(), x = m.width + f.strokeWidth();
                        l && (T = m.height, C += T, k && (S -= T));
                        let { anchorX: w, anchorY: M } = function(t) {
                            let e, i;
                            let { isHeader: s, plotX: o = 0, plotY: r = 0, series: l } = t;
                            if (s) e = Math.max(n + o, n), i = h + a / 2;
                            else {
                                let { xAxis: t, yAxis: s } = l;
                                e = t.pos + oa(o, -p, t.len + p), l.shouldShowTooltip(0, s.pos - h + r, {
                                    ignoreX: !0
                                }) && (i = s.pos + r);
                            }
                            return {
                                anchorX: e = oa(e, y.left - p, y.right + p),
                                anchorY: i
                            };
                        }(r);
                        if ("number" == typeof M) {
                            let e = m.height + 1, s = u ? u.call(i, x, e, r) : A(w, M, l, x);
                            t.push({
                                align: u ? 0 : void 0,
                                anchorX: w,
                                anchorY: M,
                                boxWidth: x,
                                point: r,
                                rank: om(s.rank, l ? 1 : 0),
                                size: e,
                                target: s.y,
                                tt: f,
                                x: s.x
                            });
                        } else f.isActive = !1;
                    }
                    return t;
                }, []);
                !u && P.some((t)=>{
                    let { outside: e } = i, s = (e ? w : 0) + t.anchorX;
                    return s < y.left && s + t.boxWidth < y.right || s < w - y.left + t.boxWidth && y.right - s > s;
                }) && (P = P.map((t)=>{
                    let { x: e, y: i } = A(t.anchorX, t.anchorY, t.point.isHeader, t.boxWidth, !1);
                    return ol(t, {
                        target: i,
                        x: e
                    });
                })), i.cleanSplit(), oo(P, C);
                let L = {
                    left: w,
                    right: w
                };
                P.forEach(function(t) {
                    let { x: e, boxWidth: s, isHeader: o } = t;
                    !o && (i.outside && w + e < L.left && (L.left = w + e), !o && i.outside && L.left + s > L.right && (L.right = w + e));
                }), P.forEach(function(t) {
                    let { x: e, anchorX: s, anchorY: o, pos: r, point: { isHeader: a } } = t, n = {
                        visibility: void 0 === r ? "hidden" : "inherit",
                        x: e,
                        y: (r || 0) + S,
                        anchorX: s,
                        anchorY: o
                    };
                    if (i.outside && e < s) {
                        let t = w - L.left;
                        t > 0 && (a || (n.x = e + t, n.anchorX = s + t), a && (n.x = (L.right - L.left) / 2, n.anchorX = s + t));
                    }
                    t.tt.attr(n);
                });
                let { container: O, outside: E, renderer: I } = i;
                if (E && O && I) {
                    let { width: t, height: e, x: i, y: s } = b.getBBox();
                    I.setSize(t + i, e + s, !1), O.style.left = L.left + "px", O.style.top = M + "px";
                }
                os && b.attr({
                    opacity: 1 === b.opacity ? .999 : 1
                });
            }
            drawTracker() {
                if (!this.shouldStickOnContact()) {
                    this.tracker && (this.tracker = this.tracker.destroy());
                    return;
                }
                let t = this.chart, e = this.label, i = this.shared ? t.hoverPoints : t.hoverPoint;
                if (!e || !i) return;
                let s = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }, o = this.getAnchor(i), r = e.getBBox();
                o[0] += t.plotLeft - (e.translateX || 0), o[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, o[0]), s.y = Math.min(0, o[1]), s.width = o[0] < 0 ? Math.max(Math.abs(o[0]), r.width - o[0]) : Math.max(Math.abs(o[0]), r.width), s.height = o[1] < 0 ? Math.max(Math.abs(o[1]), r.height - Math.abs(o[1])) : Math.max(Math.abs(o[1]), r.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass("highcharts-tracker").add(e), t.styledMode || this.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                }));
            }
            styledModeFormat(t) {
                return t.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
            }
            headerFooterFormatter(t, e) {
                let i = t.series, s = i.tooltipOptions, o = i.xAxis, r = o && o.dateTime, a = {
                    isFooter: e,
                    point: t
                }, n = s.xDateFormat || "", h = s[e ? "footerFormat" : "headerFormat"];
                return od(this, "headerFormatter", a, function(e) {
                    if (r && !n && op(t.key) && (n = r.getXDateFormat(t.key, s.dateTimeLabelFormats)), r && n) {
                        if (og(n)) {
                            let t = n;
                            oe[0] = (e)=>i.chart.time.dateFormat(t, e), n = "%0";
                        }
                        (t.tooltipDateKeys || [
                            "key"
                        ]).forEach((t)=>{
                            h = h.replace(RegExp("point\\." + t + "([ \\)}])", ""), `(point.${t}:${n})$1`);
                        });
                    }
                    i.chart.styledMode && (h = this.styledModeFormat(h)), e.text = s7(h, t, this.chart);
                }), a.text || "";
            }
            update(t) {
                this.destroy(), this.init(this.chart, of(!0, this.options, t));
            }
            updatePosition(t) {
                let { chart: e, container: i, distance: s, options: o, pointer: r, renderer: a } = this, { height: n = 0, width: h = 0 } = this.getLabel(), { left: l, top: d, scaleX: c, scaleY: p } = r.getChartPosition(), g = (o.positioner || this.getPosition).call(this, h, n, t), u = k.doc, f = (t.plotX || 0) + e.plotLeft, m = (t.plotY || 0) + e.plotTop, x;
                a && i && (o.positioner && (g.x += l - s, g.y += d - s), x = (o.borderWidth || 0) + 2 * s + 2, a.setSize(oa(h + x, 0, u.documentElement.clientWidth) - 1, n + x, !1), (1 !== c || 1 !== p) && (on(i, {
                    transform: `scale(${c}, ${p})`
                }), f *= c, m *= p), f += l - g.x, m += d - g.y), this.move(Math.round(g.x), Math.round(g.y || 0), f, m);
            }
        }
        !function(t) {
            t.compose = function(e) {
                ox(ot, "Core.Tooltip") && or(e, "afterInit", function() {
                    let e = this.chart;
                    e.options.tooltip && (e.tooltip = new t(e, e.options.tooltip, this));
                });
            };
        }(ov || (ov = {}));
        let ok = ov, { animObject: ow } = tR, { defaultOptions: oM } = tm, { format: oS } = eo, { addEvent: oT, crisp: oC, erase: oA, extend: oP, fireEvent: oL, getNestedProperty: oO, isArray: oE, isFunction: oI, isNumber: oD, isObject: oB, merge: oN, pick: oz, syncTimeout: oR, removeEvent: oW, uniqueKey: oH } = $;
        class oX {
            animateBeforeDestroy() {
                let t = this, e = {
                    x: t.startXPos,
                    opacity: 0
                }, i = t.getGraphicalProps();
                i.singular.forEach(function(i) {
                    t[i] = t[i].animate("dataLabel" === i ? {
                        x: t[i].startXPos,
                        y: t[i].startYPos,
                        opacity: 0
                    } : e);
                }), i.plural.forEach(function(e) {
                    t[e].forEach(function(e) {
                        e.element && e.animate(oP({
                            x: t.startXPos
                        }, e.startYPos ? {
                            x: e.startXPos,
                            y: e.startYPos
                        } : {}));
                    });
                });
            }
            applyOptions(t, e) {
                let i = this.series, s = i.options.pointValKey || i.pointValKey;
                return oP(this, t = oX.prototype.optionsToObject.call(this, t)), this.options = this.options ? oP(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = oX.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = "select"), "name" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? this.x = e ?? i.autoIncrement() : oD(t.x) && i.options.relativeXValue ? this.x = i.autoIncrement(t.x) : "string" == typeof this.x && (e ?? (e = i.chart.time.parse(this.x)), oD(e) && (this.x = e)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
            }
            destroy() {
                if (!this.destroyed) {
                    let t = this, e = t.series, i = e.chart, s = e.options.dataSorting, o = i.hoverPoints, r = ow(t.series.chart.renderer.globalAnimation), a = ()=>{
                        for(let e in (t.graphic || t.graphics || t.dataLabel || t.dataLabels) && (oW(t), t.destroyElements()), t)delete t[e];
                    };
                    t.legendItem && i.legend.destroyItem(t), o && (t.setState(), oA(o, t), o.length || (i.hoverPoints = null)), t === i.hoverPoint && t.onMouseOut(), s && s.enabled ? (this.animateBeforeDestroy(), oR(a, r.duration)) : a(), i.pointCount--;
                }
                this.destroyed = !0;
            }
            destroyElements(t) {
                let e = this, i = e.getGraphicalProps(t);
                i.singular.forEach(function(t) {
                    e[t] = e[t].destroy();
                }), i.plural.forEach(function(t) {
                    e[t].forEach(function(t) {
                        t && t.element && t.destroy();
                    }), delete e[t];
                });
            }
            firePointEvent(t, e, i) {
                let s = this, o = this.series.options;
                s.manageEvent(t), "click" === t && o.allowPointSelect && (i = function(t) {
                    !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);
                }), oL(s, t, e, i);
            }
            getClassName() {
                return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            }
            getGraphicalProps(t) {
                let e, i;
                let s = this, o = [], r = {
                    singular: [],
                    plural: []
                };
                for((t = t || {
                    graphic: 1,
                    dataLabel: 1
                }).graphic && o.push("graphic", "connector"), t.dataLabel && o.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i = o.length; i--;)s[e = o[i]] && r.singular.push(e);
                return [
                    "graphic",
                    "dataLabel"
                ].forEach(function(e) {
                    let i = e + "s";
                    t[e] && s[i] && r.plural.push(i);
                }), r;
            }
            getNestedProperty(t) {
                return t ? 0 === t.indexOf("custom.") ? oO(t, this.options) : this[t] : void 0;
            }
            getZone() {
                let t = this.series, e = t.zones, i = t.zoneAxis || "y", s, o = 0;
                for(s = e[0]; this[i] >= s.value;)s = e[++o];
                return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;
            }
            hasNewShapeType() {
                return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            }
            constructor(t, e, i){
                this.formatPrefix = "point", this.visible = !0, this.point = this, this.series = t, this.applyOptions(e, i), this.id ?? (this.id = oH()), this.resolveColor(), t.chart.pointCount++, oL(this, "afterInit");
            }
            isValid() {
                return (oD(this.x) || this.x instanceof Date) && oD(this.y);
            }
            optionsToObject(t) {
                let e = this.series, i = e.options.keys, s = i || e.pointArrayMap || [
                    "y"
                ], o = s.length, r = {}, a, n = 0, h = 0;
                if (oD(t) || null === t) r[s[0]] = t;
                else if (oE(t)) for(!i && t.length > o && ("string" == (a = typeof t[0]) ? e.xAxis?.dateTime ? r.x = e.chart.time.parse(t[0]) : r.name = t[0] : "number" === a && (r.x = t[0]), n++); h < o;)i && void 0 === t[n] || (s[h].indexOf(".") > 0 ? oX.prototype.setNestedProperty(r, t[n], s[h]) : r[s[h]] = t[n]), n++, h++;
                else "object" == typeof t && (r = t, t.dataLabels && (e.hasDataLabels = ()=>!0), t.marker && (e._hasPointMarkers = !0));
                return r;
            }
            pos(t, e = this.plotY) {
                if (!this.destroyed) {
                    let { plotX: i, series: s } = this, { chart: o, xAxis: r, yAxis: a } = s, n = 0, h = 0;
                    if (oD(i) && oD(e)) return t && (n = r ? r.pos : o.plotLeft, h = a ? a.pos : o.plotTop), o.inverted && r && a ? [
                        a.len - e + h,
                        r.len - i + n
                    ] : [
                        i + n,
                        e + h
                    ];
                }
            }
            resolveColor() {
                let t = this.series, e = t.chart.options.chart, i = t.chart.styledMode, s, o, r = e.colorCount, a;
                delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (o = t.options.colors || t.chart.options.colors)[t.colorCounter], r = o.length), a = t.colorCounter, t.colorCounter++, t.colorCounter === r && (t.colorCounter = 0)) : (i || (s = t.color), a = t.colorIndex), this.colorIndex = oz(this.options.colorIndex, a), this.color = oz(this.options.color, s);
            }
            setNestedProperty(t, e, i) {
                return i.split(".").reduce(function(t, i, s, o) {
                    let r = o.length - 1 === s;
                    return t[i] = r ? e : oB(t[i], !0) ? t[i] : {}, t[i];
                }, t), t;
            }
            shouldDraw() {
                return !this.isNull;
            }
            tooltipFormatter(t) {
                let { chart: e, pointArrayMap: i = [
                    "y"
                ], tooltipOptions: s } = this.series, { valueDecimals: o = "", valuePrefix: r = "", valueSuffix: a = "" } = s;
                return e.styledMode && (t = e.tooltip?.styledModeFormat(t) || t), i.forEach((e)=>{
                    e = "{point." + e, (r || a) && (t = t.replace(RegExp(e + "}", "g"), r + e + "}" + a)), t = t.replace(RegExp(e + "}", "g"), e + ":,." + o + "f}");
                }), oS(t, this, e);
            }
            update(t, e, i, s) {
                let o;
                let r = this, a = r.series, n = r.graphic, h = a.chart, l = a.options;
                function d() {
                    r.applyOptions(t);
                    let s = n && r.hasMockGraphic, d = null === r.y ? !s : s;
                    n && d && (r.graphic = n.destroy(), delete r.hasMockGraphic), oB(t, !0) && (n && n.element && t && t.marker && void 0 !== t.marker.symbol && (r.graphic = n.destroy()), t?.dataLabels && r.dataLabel && (r.dataLabel = r.dataLabel.destroy())), o = r.index;
                    let c = {};
                    for (let t of a.dataColumnKeys())c[t] = r[t];
                    a.dataTable.setRow(c, o), l.data[o] = oB(l.data[o], !0) || oB(t, !0) ? r.options : oz(t, l.data[o]), a.isDirty = a.isDirtyData = !0, !a.fixedBox && a.hasCartesianSeries && (h.isDirtyBox = !0), "point" === l.legendType && (h.isDirtyLegend = !0), e && h.redraw(i);
                }
                e = oz(e, !0), !1 === s ? d() : r.firePointEvent("update", {
                    options: t
                }, d);
            }
            remove(t, e) {
                this.series.removePoint(this.series.data.indexOf(this), t, e);
            }
            select(t, e) {
                let i = this, s = i.series, o = s.chart;
                t = oz(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? "select" : "unselect", {
                    accumulate: e
                }, function() {
                    i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && "select"), e || o.getSelectedPoints().forEach(function(t) {
                        let e = t.series;
                        t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(o.hoverPoints && e.options.inactiveOtherPoints ? "inactive" : ""), t.firePointEvent("unselect"));
                    });
                }), delete this.selectedStaging;
            }
            onMouseOver(t) {
                let { inverted: e, pointer: i } = this.series.chart;
                i && (t = t ? i.normalize(t) : i.getChartCoordinatesFromPoint(this, e), i.runPointActions(t, this));
            }
            onMouseOut() {
                let t = this.series.chart;
                this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function(t) {
                    t.setState();
                }), t.hoverPoints = t.hoverPoint = null;
            }
            manageEvent(t) {
                let e = oN(this.series.options.point, this.options), i = e.events?.[t];
                oI(i) && (!this.hcEvents?.[t] || this.hcEvents?.[t]?.map((t)=>t.fn).indexOf(i) === -1) ? (this.importedUserEvent?.(), this.importedUserEvent = oT(this, t, i), this.hcEvents && (this.hcEvents[t].userEvent = !0)) : this.importedUserEvent && !i && this.hcEvents?.[t] && this.hcEvents?.[t].userEvent && (oW(this, t), delete this.hcEvents[t], Object.keys(this.hcEvents) || delete this.importedUserEvent);
            }
            setState(t, e) {
                let i = this.series, s = this.state, o = i.options.states[t || "normal"] || {}, r = oM.plotOptions[i.type].marker && i.options.marker, a = r && !1 === r.enabled, n = r && r.states && r.states[t || "normal"] || {}, h = !1 === n.enabled, l = this.marker || {}, d = i.chart, c = r && i.markerAttribs, p = i.halo, g, u, f, m = i.stateMarkerGraphic, x;
                if ((t = t || "") === this.state && !e || this.selected && "select" !== t || !1 === o.enabled || t && (h || a && !1 === n.enabled) || t && l.states && l.states[t] && !1 === l.states[t].enabled) return;
                if (this.state = t, c && (g = i.markerAttribs(this, t)), this.graphic && !this.hasMockGraphic) {
                    if (s && this.graphic.removeClass("highcharts-point-" + s), t && this.graphic.addClass("highcharts-point-" + t), !d.styledMode) {
                        u = i.pointAttribs(this, t), f = oz(d.options.chart.animation, o.animation);
                        let e = u.opacity;
                        i.options.inactiveOtherPoints && oD(e) && (this.dataLabels || []).forEach(function(t) {
                            t && !t.hasClass("highcharts-data-label-hidden") && (t.animate({
                                opacity: e
                            }, f), t.connector && t.connector.animate({
                                opacity: e
                            }, f));
                        }), this.graphic.animate(u, f);
                    }
                    g && this.graphic.animate(g, oz(d.options.chart.animation, n.animation, r.animation)), m && m.hide();
                } else t && n && (x = l.symbol || i.symbol, m && m.currentSymbol !== x && (m = m.destroy()), g && (m ? m[e ? "animate" : "attr"]({
                    x: g.x,
                    y: g.y
                }) : x && (i.stateMarkerGraphic = m = d.renderer.symbol(x, g.x, g.y, g.width, g.height, oN(r, n)).add(i.markerGroup), m.currentSymbol = x)), !d.styledMode && m && "inactive" !== this.state && m.attr(i.pointAttribs(this, t))), m && (m[t && this.isInside ? "show" : "hide"](), m.element.point = this, m.addClass(this.getClassName(), !0));
                let y = o.halo, b = this.graphic || m, v = b && b.visibility || "inherit";
                y && y.size && b && "hidden" !== v && !this.isCluster ? (p || (i.halo = p = d.renderer.path().add(b.parentGroup)), p.show()[e ? "animate" : "attr"]({
                    d: this.haloPath(y.size)
                }), p.attr({
                    class: "highcharts-halo highcharts-color-" + oz(this.colorIndex, i.colorIndex) + (this.className ? " " + this.className : ""),
                    visibility: v,
                    zIndex: -1
                }), p.point = this, d.styledMode || p.attr(oP({
                    fill: this.color || i.color,
                    "fill-opacity": y.opacity
                }, tK.filterUserAttributes(y.attributes || {})))) : p?.point?.haloPath && !p.point.destroyed && p.animate({
                    d: p.point.haloPath(0)
                }, null, p.hide), oL(this, "afterSetState", {
                    state: t
                });
            }
            haloPath(t) {
                let e = this.pos();
                return e ? this.series.chart.renderer.symbols.circle(oC(e[0], 1) - t, e[1] - t, 2 * t, 2 * t) : [];
            }
        }
        let oF = oX, { parse: oG } = tk, { charts: oY, composed: oj, isTouchDevice: oU } = k, { addEvent: o$, attr: oV, css: o_, extend: oq, find: oZ, fireEvent: oK, isNumber: oJ, isObject: oQ, objectEach: o0, offset: o1, pick: o2, pushUnique: o3, splat: o5 } = $;
        class o6 {
            applyInactiveState(t) {
                let e = [], i;
                (t || []).forEach(function(t) {
                    i = t.series, e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && (e = e.concat(i.linkedSeries)), i.navigatorSeries && e.push(i.navigatorSeries);
                }), this.chart.series.forEach(function(t) {
                    -1 === e.indexOf(t) ? t.setState("inactive", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState("inactive");
                });
            }
            destroy() {
                let t = this;
                this.eventsToUnbind.forEach((t)=>t()), this.eventsToUnbind = [], !k.chartCount && (o6.unbindDocumentMouseUp.forEach((t)=>t.unbind()), o6.unbindDocumentMouseUp.length = 0, o6.unbindDocumentTouchEnd && (o6.unbindDocumentTouchEnd = o6.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), o0(t, function(e, i) {
                    t[i] = void 0;
                });
            }
            getSelectionMarkerAttrs(t, e) {
                let i = {
                    args: {
                        chartX: t,
                        chartY: e
                    },
                    attrs: {},
                    shapeType: "rect"
                };
                return oK(this, "getSelectionMarkerAttrs", i, (i)=>{
                    let s;
                    let { chart: o, zoomHor: r, zoomVert: a } = this, { mouseDownX: n = 0, mouseDownY: h = 0 } = o, l = i.attrs;
                    l.x = o.plotLeft, l.y = o.plotTop, l.width = r ? 1 : o.plotWidth, l.height = a ? 1 : o.plotHeight, r && (s = t - n, l.width = Math.max(1, Math.abs(s)), l.x = (s > 0 ? 0 : s) + n), a && (s = e - h, l.height = Math.max(1, Math.abs(s)), l.y = (s > 0 ? 0 : s) + h);
                }), i;
            }
            drag(t) {
                let { chart: e } = this, { mouseDownX: i = 0, mouseDownY: s = 0 } = e, { panning: o, panKey: r, selectionMarkerFill: a } = e.options.chart, n = e.plotLeft, h = e.plotTop, l = e.plotWidth, d = e.plotHeight, c = oQ(o) ? o.enabled : o, p = r && t[`${r}Key`], g = t.chartX, u = t.chartY, f, m = this.selectionMarker;
                if ((!m || !m.touch) && (g < n ? g = n : g > n + l && (g = n + l), u < h ? u = h : u > h + d && (u = h + d), this.hasDragged = Math.sqrt(Math.pow(i - g, 2) + Math.pow(s - u, 2)), this.hasDragged > 10)) {
                    f = e.isInsidePlot(i - n, s - h, {
                        visiblePlotOnly: !0
                    });
                    let { shapeType: r, attrs: l } = this.getSelectionMarkerAttrs(g, u);
                    (e.hasCartesianSeries || e.mapView) && this.hasZoom && f && !p && !m && (this.selectionMarker = m = e.renderer[r](), m.attr({
                        class: "highcharts-selection-marker",
                        zIndex: 7
                    }).add(), e.styledMode || m.attr({
                        fill: a || oG("#334eff").setOpacity(.25).get()
                    })), m && m.attr(l), f && !m && c && e.pan(t, o);
                }
            }
            dragStart(t) {
                let e = this.chart;
                e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = t.chartX, e.mouseDownY = t.chartY;
            }
            getSelectionBox(t) {
                let e = {
                    args: {
                        marker: t
                    },
                    result: t.getBBox()
                };
                return oK(this, "getSelectionBox", e), e.result;
            }
            drop(t) {
                let e;
                let { chart: i, selectionMarker: s } = this;
                for (let t of i.axes)t.isPanning && (t.isPanning = !1, (t.options.startOnTick || t.options.endOnTick || t.series.some((t)=>t.boosted)) && (t.forceRedraw = !0, t.setExtremes(t.userMin, t.userMax, !1), e = !0));
                if (e && i.redraw(), s && t) {
                    if (this.hasDragged) {
                        let e = this.getSelectionBox(s);
                        i.transform({
                            axes: i.axes.filter((t)=>t.zoomEnabled && ("xAxis" === t.coll && this.zoomX || "yAxis" === t.coll && this.zoomY)),
                            selection: {
                                originalEvent: t,
                                xAxis: [],
                                yAxis: [],
                                ...e
                            },
                            from: e
                        });
                    }
                    oJ(i.index) && (this.selectionMarker = s.destroy());
                }
                i && oJ(i.index) && (o_(i.container, {
                    cursor: i._cursor
                }), i.cancelClick = this.hasDragged > 10, i.mouseIsDown = !1, this.hasDragged = 0, this.pinchDown = []);
            }
            findNearestKDPoint(t, e, i) {
                let s;
                return t.forEach(function(t) {
                    let o = !(t.noSharedTooltip && e) && 0 > t.options.findNearestPointBy.indexOf("y"), r = t.searchPoint(i, o);
                    oQ(r, !0) && r.series && (!oQ(s, !0) || function(t, i) {
                        let s = t.distX - i.distX, o = t.dist - i.dist, r = i.series.group?.zIndex - t.series.group?.zIndex;
                        return 0 !== s && e ? s : 0 !== o ? o : 0 !== r ? r : t.series.index > i.series.index ? -1 : 1;
                    }(s, r) > 0) && (s = r);
                }), s;
            }
            getChartCoordinatesFromPoint(t, e) {
                let { xAxis: i, yAxis: s } = t.series, o = t.shapeArgs;
                if (i && s) {
                    let r = t.clientX ?? t.plotX ?? 0, a = t.plotY || 0;
                    return t.isNode && o && oJ(o.x) && oJ(o.y) && (r = o.x, a = o.y), e ? {
                        chartX: s.len + s.pos - a,
                        chartY: i.len + i.pos - r
                    } : {
                        chartX: r + i.pos,
                        chartY: a + s.pos
                    };
                }
                if (o && o.x && o.y) return {
                    chartX: o.x,
                    chartY: o.y
                };
            }
            getChartPosition() {
                if (this.chartPosition) return this.chartPosition;
                let { container: t } = this.chart, e = o1(t);
                this.chartPosition = {
                    left: e.left,
                    top: e.top,
                    scaleX: 1,
                    scaleY: 1
                };
                let { offsetHeight: i, offsetWidth: s } = t;
                return s > 2 && i > 2 && (this.chartPosition.scaleX = e.width / s, this.chartPosition.scaleY = e.height / i), this.chartPosition;
            }
            getCoordinates(t) {
                let e = {
                    xAxis: [],
                    yAxis: []
                };
                for (let i of this.chart.axes)e[i.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: i,
                    value: i.toValue(t[i.horiz ? "chartX" : "chartY"])
                });
                return e;
            }
            getHoverData(t, e, i, s, o, r) {
                let a = [], n = function(t) {
                    return t.visible && !(!o && t.directTouch) && o2(t.options.enableMouseTracking, !0);
                }, h = e, l, d = {
                    chartX: r ? r.chartX : void 0,
                    chartY: r ? r.chartY : void 0,
                    shared: o
                };
                oK(this, "beforeGetHoverData", d), l = h && !h.stickyTracking ? [
                    h
                ] : i.filter((t)=>t.stickyTracking && (d.filter || n)(t));
                let c = s && t || !r ? t : this.findNearestKDPoint(l, o, r);
                return h = c && c.series, c && (o && !h.noSharedTooltip ? (l = i.filter(function(t) {
                    return d.filter ? d.filter(t) : n(t) && !t.noSharedTooltip;
                })).forEach(function(t) {
                    let e = oZ(t.points, function(t) {
                        return t.x === c.x && !t.isNull;
                    });
                    oQ(e) && (t.boosted && t.boost && (e = t.boost.getPoint(e)), a.push(e));
                }) : a.push(c)), oK(this, "afterGetHoverData", d = {
                    hoverPoint: c
                }), {
                    hoverPoint: d.hoverPoint,
                    hoverSeries: h,
                    hoverPoints: a
                };
            }
            getPointFromEvent(t) {
                let e = t.target, i;
                for(; e && !i;)i = e.point, e = e.parentNode;
                return i;
            }
            onTrackerMouseOut(t) {
                let e = this.chart, i = t.relatedTarget, s = e.hoverSeries;
                this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, "highcharts-tooltip") || this.inClass(i, "highcharts-series-" + s.index) && this.inClass(i, "highcharts-tracker") || s.onMouseOut();
            }
            inClass(t, e) {
                let i = t, s;
                for(; i;){
                    if (s = oV(i, "class")) {
                        if (-1 !== s.indexOf(e)) return !0;
                        if (-1 !== s.indexOf("highcharts-container")) return !1;
                    }
                    i = i.parentElement;
                }
            }
            constructor(t, e){
                this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!e.chart.events?.click, this.pinchDown = [], this.setDOMEvents(), oK(this, "afterInit");
            }
            normalize(t, e) {
                let i = t.touches, s = i ? i.length ? i.item(0) : o2(i.changedTouches, t.changedTouches)[0] : t;
                e || (e = this.getChartPosition());
                let o = s.pageX - e.left, r = s.pageY - e.top;
                return oq(t, {
                    chartX: Math.round(o /= e.scaleX),
                    chartY: Math.round(r /= e.scaleY)
                });
            }
            onContainerClick(t) {
                let e = this.chart, i = e.hoverPoint, s = this.normalize(t), o = e.plotLeft, r = e.plotTop;
                !e.cancelClick && (i && this.inClass(s.target, "highcharts-tracker") ? (oK(i.series, "click", oq(s, {
                    point: i
                })), e.hoverPoint && i.firePointEvent("click", s)) : (oq(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - o, s.chartY - r, {
                    visiblePlotOnly: !0
                }) && oK(e, "click", s)));
            }
            onContainerMouseDown(t) {
                let e = (1 & (t.buttons || t.button)) == 1;
                t = this.normalize(t), k.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || e) && (this.zoomOption(t), e && t.preventDefault?.(), this.dragStart(t));
            }
            onContainerMouseLeave(t) {
                let { pointer: e } = oY[o2(o6.hoverChartIndex, -1)] || {};
                t = this.normalize(t), this.onContainerMouseMove(t), e && !this.inClass(t.relatedTarget, "highcharts-tooltip") && (e.reset(), e.chartPosition = void 0);
            }
            onContainerMouseEnter() {
                delete this.chartPosition;
            }
            onContainerMouseMove(t) {
                let e = this.chart, i = e.tooltip, s = this.normalize(t);
                this.setHoverChartIndex(t), ("mousedown" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.openMenu && (this.inClass(s.target, "highcharts-tracker") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {
                    visiblePlotOnly: !0
                })) && !(i && i.shouldStickOnContact(s)) && (this.inClass(s.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(s));
            }
            onDocumentTouchEnd(t) {
                this.onDocumentMouseUp(t);
            }
            onContainerTouchMove(t) {
                this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);
            }
            onContainerTouchStart(t) {
                this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));
            }
            onDocumentMouseMove(t) {
                let e = this.chart, i = e.tooltip, s = this.chartPosition, o = this.normalize(t, s);
                !s || e.isInsidePlot(o.chartX - e.plotLeft, o.chartY - e.plotTop, {
                    visiblePlotOnly: !0
                }) || i && i.shouldStickOnContact(o) || o.target !== e.container.ownerDocument && this.inClass(o.target, "highcharts-tracker") || this.reset();
            }
            onDocumentMouseUp(t) {
                oY[o2(o6.hoverChartIndex, -1)]?.pointer?.drop(t);
            }
            pinch(t) {
                let e = this, { chart: i, hasZoom: s, lastTouches: o } = e, r = [].map.call(t.touches || [], (t)=>e.normalize(t)), a = r.length, n = 1 === a && (e.inClass(t.target, "highcharts-tracker") && i.runTrackerClick || e.runChartClick), h = i.tooltip, l = 1 === a && o2(h?.options.followTouchMove, !0);
                a > 1 ? e.initiated = !0 : l && (e.initiated = !1), s && e.initiated && !n && !1 !== t.cancelable && t.preventDefault(), "touchstart" === t.type ? (e.pinchDown = r, e.res = !0, i.mouseDownX = t.chartX) : l ? this.runPointActions(e.normalize(t)) : o && (oK(i, "touchpan", {
                    originalEvent: t,
                    touches: r
                }, ()=>{
                    let e = (t)=>{
                        let e = t[0], i = t[1] || e;
                        return {
                            x: e.chartX,
                            y: e.chartY,
                            width: i.chartX - e.chartX,
                            height: i.chartY - e.chartY
                        };
                    };
                    i.transform({
                        axes: i.axes.filter((t)=>t.zoomEnabled && (this.zoomHor && t.horiz || this.zoomVert && !t.horiz)),
                        to: e(r),
                        from: e(o),
                        trigger: t.type
                    });
                }), e.res && (e.res = !1, this.reset(!1, 0))), e.lastTouches = r;
            }
            reset(t, e) {
                let i = this.chart, s = i.hoverSeries, o = i.hoverPoint, r = i.hoverPoints, a = i.tooltip, n = a && a.shared ? r : o;
                t && n && o5(n).forEach(function(e) {
                    e.series.isCartesian && void 0 === e.plotX && (t = !1);
                }), t ? a && n && o5(n).length && (a.refresh(n), a.shared && r ? r.forEach(function(t) {
                    t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));
                }) : o && (o.setState(o.state, !0), i.axes.forEach(function(t) {
                    t.crosshair && o.series[t.coll] === t && t.drawCrosshair(null, o);
                }))) : (o && o.onMouseOut(), r && r.forEach(function(t) {
                    t.setState();
                }), s && s.onMouseOut(), a && a.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function(t) {
                    t.hideCrosshair();
                }), i.hoverPoints = i.hoverPoint = void 0);
            }
            runPointActions(t, e, i) {
                let s = this.chart, o = s.series, r = s.tooltip && s.tooltip.options.enabled ? s.tooltip : void 0, a = !!r && r.shared, n = e || s.hoverPoint, h = n && n.series || s.hoverSeries, l = (!t || "touchmove" !== t.type) && (!!e || h && h.directTouch && this.isDirectTouch), d = this.getHoverData(n, h, o, l, a, t);
                n = d.hoverPoint, h = d.hoverSeries;
                let c = d.hoverPoints, p = h && h.tooltipOptions.followPointer && !h.tooltipOptions.split, g = a && h && !h.noSharedTooltip;
                if (n && (i || n !== s.hoverPoint || r && r.isHidden)) {
                    if ((s.hoverPoints || []).forEach(function(t) {
                        -1 === c.indexOf(t) && t.setState();
                    }), s.hoverSeries !== h && h.onMouseOver(), this.applyInactiveState(c), (c || []).forEach(function(t) {
                        t.setState("hover");
                    }), s.hoverPoint && s.hoverPoint.firePointEvent("mouseOut"), !n.series) return;
                    s.hoverPoints = c, s.hoverPoint = n, n.firePointEvent("mouseOver", void 0, ()=>{
                        r && n && r.refresh(g ? c : n, t);
                    });
                } else if (p && r && !r.isHidden) {
                    let e = r.getAnchor([
                        {}
                    ], t);
                    s.isInsidePlot(e[0], e[1], {
                        visiblePlotOnly: !0
                    }) && r.updatePosition({
                        plotX: e[0],
                        plotY: e[1]
                    });
                }
                this.unDocMouseMove || (this.unDocMouseMove = o$(s.container.ownerDocument, "mousemove", (t)=>oY[o6.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(t)), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function(e) {
                    let i;
                    let o = o2((e.crosshair || {}).snap, !0);
                    !o || (i = s.hoverPoint) && i.series[e.coll] === e || (i = oZ(c, (t)=>t.series && t.series[e.coll] === e)), i || !o ? e.drawCrosshair(t, i) : e.hideCrosshair();
                });
            }
            setDOMEvents() {
                let t = this.chart.container, e = t.ownerDocument;
                t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(o$(t, "mouseenter", this.onContainerMouseEnter.bind(this)), o$(t, "mouseleave", this.onContainerMouseLeave.bind(this))), o6.unbindDocumentMouseUp.some((t)=>t.doc === e) || o6.unbindDocumentMouseUp.push({
                    doc: e,
                    unbind: o$(e, "mouseup", this.onDocumentMouseUp.bind(this))
                });
                let i = this.chart.renderTo.parentElement;
                for(; i && "BODY" !== i.tagName;)this.eventsToUnbind.push(o$(i, "scroll", ()=>{
                    delete this.chartPosition;
                })), i = i.parentElement;
                this.eventsToUnbind.push(o$(t, "touchstart", this.onContainerTouchStart.bind(this), {
                    passive: !1
                }), o$(t, "touchmove", this.onContainerTouchMove.bind(this), {
                    passive: !1
                })), o6.unbindDocumentTouchEnd || (o6.unbindDocumentTouchEnd = o$(e, "touchend", this.onDocumentTouchEnd.bind(this), {
                    passive: !1
                })), this.setPointerCapture(), o$(this.chart, "redraw", this.setPointerCapture.bind(this));
            }
            setPointerCapture() {
                if (!oU) return;
                let t = this.pointerCaptureEventsToUnbind, e = this.chart, i = e.container, s = o2(e.options.tooltip?.followTouchMove, !0) && e.series.some((t)=>t.options.findNearestPointBy.indexOf("y") > -1);
                !this.hasPointerCapture && s ? (t.push(o$(i, "pointerdown", (t)=>{
                    t.target?.hasPointerCapture(t.pointerId) && t.target?.releasePointerCapture(t.pointerId);
                }), o$(i, "pointermove", (t)=>{
                    e.pointer?.getPointFromEvent(t)?.onMouseOver(t);
                })), e.styledMode || o_(i, {
                    "touch-action": "none"
                }), i.className += " highcharts-no-touch-action", this.hasPointerCapture = !0) : this.hasPointerCapture && !s && (t.forEach((t)=>t()), t.length = 0, e.styledMode || o_(i, {
                    "touch-action": o2(e.options.chart.style?.["touch-action"], "manipulation")
                }), i.className = i.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = !1);
            }
            setHoverChartIndex(t) {
                let e = this.chart, i = k.charts[o2(o6.hoverChartIndex, -1)];
                if (i && i !== e) {
                    let s = {
                        relatedTarget: e.container
                    };
                    t && !t?.relatedTarget && Object.assign({}, t, s), i.pointer?.onContainerMouseLeave(t || s);
                }
                i && i.mouseIsDown || (o6.hoverChartIndex = e.index);
            }
            touch(t, e) {
                let i;
                let { chart: s, pinchDown: o = [] } = this;
                this.setHoverChartIndex(), 1 === (t = this.normalize(t)).touches.length ? s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, {
                    visiblePlotOnly: !0
                }) && !s.openMenu ? (e && this.runPointActions(t), "touchmove" === t.type && (i = !!o[0] && Math.pow(o[0].chartX - t.chartX, 2) + Math.pow(o[0].chartY - t.chartY, 2) >= 16), o2(i, !0) && this.pinch(t)) : e && this.reset() : 2 === t.touches.length && this.pinch(t);
            }
            touchSelect(t) {
                return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);
            }
            zoomOption(t) {
                let e = this.chart, i = e.inverted, s = e.zooming.type || "", o, r;
                /touch/.test(t.type) && (s = o2(e.zooming.pinchType, s)), this.zoomX = o = /x/.test(s), this.zoomY = r = /y/.test(s), this.zoomHor = o && !i || r && i, this.zoomVert = r && !i || o && i, this.hasZoom = o || r;
            }
        }
        o6.unbindDocumentMouseUp = [], function(t) {
            t.compose = function(e) {
                o3(oj, "Core.Pointer") && o$(e, "beforeRender", function() {
                    this.pointer = new t(this, this.options);
                });
            };
        }(o6 || (o6 = {}));
        let o9 = o6, { fireEvent: o4, isArray: o8, objectEach: o7, uniqueKey: rt } = $, re = class {
            constructor(t = {}){
                this.autoId = !t.id, this.columns = {}, this.id = t.id || rt(), this.modified = this, this.rowCount = 0, this.versionTag = rt();
                let e = 0;
                o7(t.columns || {}, (t, i)=>{
                    this.columns[i] = t.slice(), e = Math.max(e, t.length);
                }), this.applyRowCount(e);
            }
            applyRowCount(t) {
                this.rowCount = t, o7(this.columns, (e)=>{
                    o8(e) && (e.length = t);
                });
            }
            getColumn(t, e) {
                return this.columns[t];
            }
            getColumns(t, e) {
                return (t || Object.keys(this.columns)).reduce((t, e)=>(t[e] = this.columns[e], t), {});
            }
            getRow(t, e) {
                return (e || Object.keys(this.columns)).map((e)=>this.columns[e]?.[t]);
            }
            setColumn(t, e = [], i = 0, s) {
                this.setColumns({
                    [t]: e
                }, i, s);
            }
            setColumns(t, e, i) {
                let s = this.rowCount;
                o7(t, (t, e)=>{
                    this.columns[e] = t.slice(), s = t.length;
                }), this.applyRowCount(s), i?.silent || (o4(this, "afterSetColumns"), this.versionTag = rt());
            }
            setRow(t, e = this.rowCount, i, s) {
                let { columns: o } = this, r = i ? this.rowCount + 1 : e + 1;
                o7(t, (t, a)=>{
                    let n = o[a] || s?.addColumns !== !1 && Array(r);
                    n && (i ? n.splice(e, 0, t) : n[e] = t, o[a] = n);
                }), r > this.rowCount && this.applyRowCount(r), s?.silent || (o4(this, "afterSetRows"), this.versionTag = rt());
            }
        }, { extend: ri, merge: rs, pick: ro } = $;
        !function(t) {
            function e(t, e, i) {
                let s = this.legendItem = this.legendItem || {}, { chart: o, options: r } = this, { baseline: a = 0, symbolWidth: n, symbolHeight: h } = t, l = this.symbol || "circle", d = h / 2, c = o.renderer, p = s.group, g = a - Math.round((t.fontMetrics?.b || h) * (i ? .4 : .3)), u = {}, f, m = r.marker, x = 0;
                if (o.styledMode || (u["stroke-width"] = Math.min(r.lineWidth || 0, 24), r.dashStyle ? u.dashstyle = r.dashStyle : "square" === r.linecap || (u["stroke-linecap"] = "round")), s.line = c.path().addClass("highcharts-graph").attr(u).add(p), i && (s.area = c.path().addClass("highcharts-area").add(p)), u["stroke-linecap"] && (x = Math.min(s.line.strokeWidth(), n) / 2), n) {
                    let t = [
                        [
                            "M",
                            x,
                            g
                        ],
                        [
                            "L",
                            n - x,
                            g
                        ]
                    ];
                    s.line.attr({
                        d: t
                    }), s.area?.attr({
                        d: [
                            ...t,
                            [
                                "L",
                                n - x,
                                a
                            ],
                            [
                                "L",
                                x,
                                a
                            ]
                        ]
                    });
                }
                if (m && !1 !== m.enabled && n) {
                    let t = Math.min(ro(m.radius, d), d);
                    0 === l.indexOf("url") && (m = rs(m, {
                        width: h,
                        height: h
                    }), t = 0), s.symbol = f = c.symbol(l, n / 2 - t, g - t, 2 * t, 2 * t, ri({
                        context: "legend"
                    }, m)).addClass("highcharts-point").add(p), f.isMarker = !0;
                }
            }
            t.areaMarker = function(t, i) {
                e.call(this, t, i, !0);
            }, t.lineMarker = e, t.rectangle = function(t, e) {
                let i = e.legendItem || {}, s = t.options, o = t.symbolHeight, r = s.squareSymbol, a = r ? o : t.symbolWidth;
                i.symbol = this.chart.renderer.rect(r ? (t.symbolWidth - o) / 2 : 0, t.baseline - o + 1, a, o, ro(t.options.symbolRadius, o / 2)).addClass("highcharts-point").attr({
                    zIndex: 3
                }).add(i.group);
            };
        }(d || (d = {}));
        let rr = d, { defaultOptions: ra } = tm, { extend: rn, extendClass: rh, merge: rl } = $;
        !function(t) {
            function e(e, i) {
                let s = ra.plotOptions || {}, o = i.defaultOptions, r = i.prototype;
                return r.type = e, r.pointClass || (r.pointClass = oF), !t.seriesTypes[e] && (o && (s[e] = o), t.seriesTypes[e] = i, !0);
            }
            t.seriesTypes = k.seriesTypes, t.registerSeriesType = e, t.seriesType = function(i, s, o, r, a) {
                let n = ra.plotOptions || {};
                if (s = s || "", n[i] = rl(n[s], o), delete t.seriesTypes[i], e(i, rh(t.seriesTypes[s] || function() {}, r)), t.seriesTypes[i].prototype.type = i, a) {
                    class e extends oF {
                    }
                    rn(e.prototype, a), t.seriesTypes[i].prototype.pointClass = e;
                }
                return t.seriesTypes[i];
            };
        }(c || (c = {}));
        let rd = c, { animObject: rc, setAnimation: rp } = tR, { defaultOptions: rg } = tm, { registerEventOptions: ru } = i3, { svg: rf, win: rm } = k, { seriesTypes: rx } = rd, { arrayMax: ry, arrayMin: rb, clamp: rv, correctFloat: rk, crisp: rw, defined: rM, destroyObjectProperties: rS, diffObjects: rT, erase: rC, error: rA, extend: rP, find: rL, fireEvent: rO, getClosestDistance: rE, getNestedProperty: rI, insertItem: rD, isArray: rB, isNumber: rN, isString: rz, merge: rR, objectEach: rW, pick: rH, removeEvent: rX, syncTimeout: rF } = $;
        class rG {
            constructor(){
                this.zoneAxis = "y";
            }
            init(t, e) {
                let i;
                rO(this, "init", {
                    options: e
                }), this.dataTable ?? (this.dataTable = new re);
                let s = t.series;
                this.eventsToUnbind = [], this.chart = t, this.options = this.setOptions(e);
                let o = this.options, r = !1 !== o.visible;
                this.linkedSeries = [], this.bindAxes(), rP(this, {
                    name: o.name,
                    state: "",
                    visible: r,
                    selected: !0 === o.selected
                }), ru(this, o);
                let a = o.events;
                (a && a.click || o.point && o.point.events && o.point.events.click || o.allowPointSelect) && (t.runTrackerClick = !0), this.getColor(), this.getSymbol(), this.isCartesian && (t.hasCartesianSeries = !0), s.length && (i = s[s.length - 1]), this._i = rH(i && i._i, -1) + 1, this.opacity = this.options.opacity, t.orderItems("series", rD(this, s)), o.dataSorting && o.dataSorting.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o.data, !1), rO(this, "afterInit");
            }
            is(t) {
                return rx[t] && this instanceof rx[t];
            }
            bindAxes() {
                let t;
                let e = this, i = e.options, s = e.chart;
                rO(this, "bindAxes", null, function() {
                    (e.axisTypes || []).forEach(function(o) {
                        (s[o] || []).forEach(function(s) {
                            t = s.options, (rH(i[o], 0) === s.index || void 0 !== i[o] && i[o] === t.id) && (rD(e, s.series), e[o] = s, s.isDirty = !0);
                        }), e[o] || e.optionalAxis === o || rA(18, !0, s);
                    });
                }), rO(this, "afterBindAxes");
            }
            hasData() {
                return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.dataTable.rowCount > 0;
            }
            hasMarkerChanged(t, e) {
                let i = t.marker, s = e.marker || {};
                return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);
            }
            autoIncrement(t) {
                let e;
                let i = this.options, { pointIntervalUnit: s, relativeXValue: o } = this.options, r = this.chart.time, a = this.xIncrement ?? r.parse(i.pointStart) ?? 0;
                if (this.pointInterval = e = rH(this.pointInterval, i.pointInterval, 1), o && rN(t) && (e *= t), s) {
                    let t = r.toParts(a);
                    "day" === s ? t[2] += e : "month" === s ? t[1] += e : "year" === s && (t[0] += e), e = r.makeTime.apply(r, t) - a;
                }
                return o && rN(t) ? a + e : (this.xIncrement = a + e, a);
            }
            setDataSortingOptions() {
                let t = this.options;
                rP(this, {
                    requireSorting: !1,
                    sorted: !1,
                    enabledDataSorting: !0,
                    allowDG: !1
                }), rM(t.pointRange) || (t.pointRange = 1);
            }
            setOptions(t) {
                let e;
                let i = this.chart, s = i.options.plotOptions, o = i.userOptions || {}, r = rR(t), a = i.styledMode, n = {
                    plotOptions: s,
                    userOptions: r
                };
                rO(this, "setOptions", n);
                let h = n.plotOptions[this.type], l = o.plotOptions || {}, d = l.series || {}, c = rg.plotOptions[this.type] || {}, p = l[this.type] || {};
                this.userOptions = n.userOptions;
                let g = rR(h, s.series, p, r);
                this.tooltipOptions = rR(rg.tooltip, rg.plotOptions.series?.tooltip, c?.tooltip, i.userOptions.tooltip, l.series?.tooltip, p.tooltip, r.tooltip), this.stickyTracking = rH(r.stickyTracking, p.stickyTracking, d.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || g.stickyTracking), null === h.marker && delete g.marker, this.zoneAxis = g.zoneAxis || "y";
                let u = this.zones = (g.zones || []).map((t)=>({
                        ...t
                    }));
                return (g.negativeColor || g.negativeFillColor) && !g.zones && (e = {
                    value: g[this.zoneAxis + "Threshold"] || g.threshold || 0,
                    className: "highcharts-negative"
                }, a || (e.color = g.negativeColor, e.fillColor = g.negativeFillColor), u.push(e)), u.length && rM(u[u.length - 1].value) && u.push(a ? {} : {
                    color: this.color,
                    fillColor: this.fillColor
                }), rO(this, "afterSetOptions", {
                    options: g
                }), g;
            }
            getName() {
                return rH(this.options.name, "Series " + (this.index + 1));
            }
            getCyclic(t, e, i) {
                let s, o;
                let r = this.chart, a = `${t}Index`, n = `${t}Counter`, h = i?.length || r.options.chart.colorCount;
                !e && (rM(o = rH("color" === t ? this.options.colorIndex : void 0, this[a])) ? s = o : (r.series.length || (r[n] = 0), s = r[n] % h, r[n] += 1), i && (e = i[s])), void 0 !== s && (this[a] = s), this[t] = e;
            }
            getColor() {
                this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || rg.plotOptions[this.type].color, this.chart.options.colors);
            }
            getPointsCollection() {
                return (this.hasGroupedData ? this.points : this.data) || [];
            }
            getSymbol() {
                let t = this.options.marker;
                this.getCyclic("symbol", t.symbol, this.chart.options.symbols);
            }
            getColumn(t, e) {
                return (e ? this.dataTable.modified : this.dataTable).getColumn(t, !0) || [];
            }
            findPointIndex(t, e) {
                let i, s, o;
                let r = t.id, a = t.x, n = this.points, h = this.options.dataSorting;
                if (r) {
                    let t = this.chart.get(r);
                    t instanceof oF && (i = t);
                } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
                    let e = (e)=>!e.touched && e.index === t.index;
                    if (h && h.matchByName ? e = (e)=>!e.touched && e.name === t.name : this.options.relativeXValue && (e = (e)=>!e.touched && e.options.x === t.x), !(i = rL(n, e))) return;
                }
                return i && void 0 !== (o = i && i.index) && (s = !0), void 0 === o && rN(a) && (o = this.getColumn("x").indexOf(a, e)), -1 !== o && void 0 !== o && this.cropped && (o = o >= this.cropStart ? o - this.cropStart : o), !s && rN(o) && n[o] && n[o].touched && (o = void 0), o;
            }
            updateData(t, e) {
                let i = this.options, s = i.dataSorting, o = this.points, r = [], a = this.requireSorting, n = t.length === o.length, h, l, d, c, p = !0;
                if (this.xIncrement = null, t.forEach(function(t, e) {
                    let l;
                    let d = rM(t) && this.pointClass.prototype.optionsToObject.call({
                        series: this
                    }, t) || {}, p = d.x;
                    d.id || rN(p) ? (-1 === (l = this.findPointIndex(d, c)) || void 0 === l ? r.push(t) : o[l] && t !== i.data[l] ? (o[l].update(t, !1, null, !1), o[l].touched = !0, a && (c = l + 1)) : o[l] && (o[l].touched = !0), (!n || e !== l || s && s.enabled || this.hasDerivedData) && (h = !0)) : r.push(t);
                }, this), h) for(l = o.length; l--;)(d = o[l]) && !d.touched && d.remove && d.remove(!1, e);
                else !n || s && s.enabled ? p = !1 : (t.forEach(function(t, e) {
                    t === o[e].y || o[e].destroyed || o[e].update(t, !1, null, !1);
                }), r.length = 0);
                if (o.forEach(function(t) {
                    t && (t.touched = !1);
                }), !p) return !1;
                r.forEach(function(t) {
                    this.addPoint(t, !1, null, null, !1);
                }, this);
                let g = this.getColumn("x");
                return null === this.xIncrement && g.length && (this.xIncrement = ry(g), this.autoIncrement()), !0;
            }
            dataColumnKeys() {
                return [
                    "x",
                    ...this.pointArrayMap || [
                        "y"
                    ]
                ];
            }
            setData(t, e = !0, i, s) {
                let o = this.points, r = o && o.length || 0, a = this.options, n = this.chart, h = a.dataSorting, l = this.xAxis, d = a.turboThreshold, c = this.dataTable, p = this.dataColumnKeys(), g = this.pointValKey || "y", u = (this.pointArrayMap || []).length, f = a.keys, m, x, y = 0, b = 1, v;
                n.options.chart.allowMutatingData || (a.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v = rR(!0, t));
                let k = (t = v || t || []).length;
                if (h && h.enabled && (t = this.sortData(t)), n.options.chart.allowMutatingData && !1 !== s && k && r && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x = this.updateData(t, i)), !x) {
                    this.xIncrement = null, this.colorCounter = 0;
                    let e = d && k > d;
                    if (e) {
                        let i = this.getFirstValidPoint(t), s = this.getFirstValidPoint(t, k - 1, -1), o = (t)=>!!(rB(t) && (f || rN(t[0])));
                        if (rN(i) && rN(s)) {
                            let e = [], i = [];
                            for (let s of t)e.push(this.autoIncrement()), i.push(s);
                            c.setColumns({
                                x: e,
                                [g]: i
                            });
                        } else if (o(i) && o(s)) {
                            if (u) {
                                let e = i.length === u ? 1 : 0, s = Array(p.length).fill(0).map(()=>[]);
                                for (let i of t){
                                    e && s[0].push(this.autoIncrement());
                                    for(let t = e; t <= u; t++)s[t]?.push(i[t - e]);
                                }
                                c.setColumns(p.reduce((t, e, i)=>(t[e] = s[i], t), {}));
                            } else {
                                f && (y = f.indexOf("x"), b = f.indexOf("y"), y = y >= 0 ? y : 0, b = b >= 0 ? b : 1), 1 === i.length && (b = 0);
                                let e = [], s = [];
                                if (y === b) for (let i of t)e.push(this.autoIncrement()), s.push(i[b]);
                                else for (let i of t)e.push(i[y]), s.push(i[b]);
                                c.setColumns({
                                    x: e,
                                    [g]: s
                                });
                            }
                        } else e = !1;
                    }
                    if (!e) {
                        let e = p.reduce((t, e)=>(t[e] = [], t), {});
                        for(m = 0; m < k; m++){
                            let i = this.pointClass.prototype.applyOptions.apply({
                                series: this
                            }, [
                                t[m]
                            ]);
                            for (let t of p)e[t][m] = i[t];
                        }
                        c.setColumns(e);
                    }
                    for(rz(this.getColumn("y")[0]) && rA(14, !0, n), this.data = [], this.options.data = this.userOptions.data = t, m = r; m--;)o[m]?.destroy();
                    l && (l.minRange = l.userMinRange), this.isDirty = n.isDirtyBox = !0, this.isDirtyData = !!o, i = !1;
                }
                "point" === a.legendType && (this.processData(), this.generatePoints()), e && n.redraw(i);
            }
            sortData(t) {
                let e = this, i = e.options.dataSorting.sortKey || "y", s = function(t, e) {
                    return rM(e) && t.pointClass.prototype.optionsToObject.call({
                        series: t
                    }, e) || {};
                };
                return t.forEach(function(i, o) {
                    t[o] = s(e, i), t[o].index = o;
                }, this), t.concat().sort((t, e)=>{
                    let s = rI(i, t), o = rI(i, e);
                    return o < s ? -1 : o > s ? 1 : 0;
                }).forEach(function(t, e) {
                    t.x = e;
                }, this), e.linkedSeries && e.linkedSeries.forEach(function(e) {
                    let i = e.options, o = i.data;
                    i.dataSorting && i.dataSorting.enabled || !o || (o.forEach(function(i, r) {
                        o[r] = s(e, i), t[r] && (o[r].x = t[r].x, o[r].index = r);
                    }), e.setData(o, !1));
                }), t;
            }
            getProcessedData(t) {
                let e = this, { dataTable: i, isCartesian: s, options: o, xAxis: r } = e, a = o.cropThreshold, n = t || e.getExtremesFromAll, h = r?.logarithmic, l = i.rowCount, d, c, p = 0, g, u, f, m = e.getColumn("x"), x = i, y = !1;
                return r && (u = (g = r.getExtremes()).min, f = g.max, y = !!(r.categories && !r.names.length), s && e.sorted && !n && (!a || l > a || e.forceCrop) && (m[l - 1] < u || m[0] > f ? x = new re : e.getColumn(e.pointValKey || "y").length && (m[0] < u || m[l - 1] > f) && (x = (d = this.cropData(i, u, f)).modified, p = d.start, c = !0))), m = x.getColumn("x") || [], {
                    modified: x,
                    cropped: c,
                    cropStart: p,
                    closestPointRange: rE([
                        h ? m.map(h.log2lin) : m
                    ], ()=>e.requireSorting && !y && rA(15, !1, e.chart))
                };
            }
            processData(t) {
                let e = this.xAxis, i = this.dataTable;
                if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;
                let s = this.getProcessedData();
                i.modified = s.modified, this.cropped = s.cropped, this.cropStart = s.cropStart, this.closestPointRange = this.basePointRange = s.closestPointRange, rO(this, "afterProcessData");
            }
            cropData(t, e, i) {
                let s = t.getColumn("x", !0) || [], o = s.length, r = {}, a, n, h = 0, l = o;
                for(a = 0; a < o; a++)if (s[a] >= e) {
                    h = Math.max(0, a - 1);
                    break;
                }
                for(n = a; n < o; n++)if (s[n] > i) {
                    l = n + 1;
                    break;
                }
                for (let e of this.dataColumnKeys()){
                    let i = t.getColumn(e, !0);
                    i && (r[e] = i.slice(h, l));
                }
                return {
                    modified: new re({
                        columns: r
                    }),
                    start: h,
                    end: l
                };
            }
            generatePoints() {
                let t = this.options, e = this.processedData || t.data, i = this.dataTable.modified, s = this.getColumn("x", !0), o = this.pointClass, r = i.rowCount, a = this.cropStart || 0, n = this.hasGroupedData, h = t.keys, l = [], d = t.dataGrouping && t.dataGrouping.groupAll ? a : 0, c = this.xAxis?.categories, p = this.pointArrayMap || [
                    "y"
                ], g = this.dataColumnKeys(), u, f, m, x, y = this.data, b;
                if (!y && !n) {
                    let t = [];
                    t.length = e?.length || 0, y = this.data = t;
                }
                for(h && n && (this.options.keys = !1), x = 0; x < r; x++)f = a + x, n ? ((m = new o(this, i.getRow(x, g) || [])).dataGroup = this.groupMap[d + x], m.dataGroup?.options && (m.options = m.dataGroup.options, rP(m, m.dataGroup.options), delete m.dataLabels)) : (m = y[f], b = e ? e[f] : i.getRow(x, p), m || void 0 === b || (y[f] = m = new o(this, b, s[x]))), m && (m.index = n ? d + x : f, l[x] = m, m.category = c?.[m.x] ?? m.x, m.key = m.name ?? m.category);
                if (this.options.keys = h, y && (r !== (u = y.length) || n)) for(x = 0; x < u; x++)x !== a || n || (x += r), y[x] && (y[x].destroyElements(), y[x].plotX = void 0);
                this.data = y, this.points = l, rO(this, "afterGeneratePoints");
            }
            getXExtremes(t) {
                return {
                    min: rb(t),
                    max: ry(t)
                };
            }
            getExtremes(t, e) {
                let { xAxis: i, yAxis: s } = this, o = e || this.getExtremesFromAll || this.options.getExtremesFromAll, r = o && this.cropped ? this.dataTable : this.dataTable.modified, a = r.rowCount, n = t || this.stackedYData, h = n ? [
                    n
                ] : (this.keysAffectYAxis || this.pointArrayMap || [
                    "y"
                ])?.map((t)=>r.getColumn(t, !0) || []) || [], l = this.getColumn("x", !0), d = [], c = this.requireSorting && !this.is("column") ? 1 : 0, p = !!s && s.positiveValuesOnly, g = o || this.cropped || !i, u, f, m, x = 0, y = 0;
                for(i && (x = (u = i.getExtremes()).min, y = u.max), m = 0; m < a; m++)if (f = l[m], g || (l[m + c] || f) >= x && (l[m - c] || f) <= y) for (let t of h){
                    let e = t[m];
                    rN(e) && (e > 0 || !p) && d.push(e);
                }
                let b = {
                    activeYData: d,
                    dataMin: rb(d),
                    dataMax: ry(d)
                };
                return rO(this, "afterGetExtremes", {
                    dataExtremes: b
                }), b;
            }
            applyExtremes() {
                let t = this.getExtremes();
                return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;
            }
            getFirstValidPoint(t, e = 0, i = 1) {
                let s = t.length, o = e;
                for(; o >= 0 && o < s;){
                    if (rM(t[o])) return t[o];
                    o += i;
                }
            }
            translate() {
                this.generatePoints();
                let t = this.options, e = t.stacking, i = this.xAxis, s = this.enabledDataSorting, o = this.yAxis, r = this.points, a = r.length, n = this.pointPlacementToXValue(), h = !!n, l = t.threshold, d = t.startFromThreshold ? l : 0, c, p, g, u, f = Number.MAX_VALUE;
                function m(t) {
                    return rv(t, -1e9, 1e9);
                }
                for(c = 0; c < a; c++){
                    let t;
                    let a = r[c], x = a.x, y, b, v = a.y, k = a.low, w = e && o.stacking?.stacks[(this.negStacks && v < (d ? 0 : l) ? "-" : "") + this.stackKey];
                    p = i.translate(x, !1, !1, !1, !0, n), a.plotX = rN(p) ? rk(m(p)) : void 0, e && this.visible && w && w[x] && (u = this.getStackIndicator(u, x, this.index), !a.isNull && u.key && (b = (y = w[x]).points[u.key]), y && rB(b) && (k = b[0], v = b[1], k === d && u.key === w[x].base && (k = rH(rN(l) ? l : o.min)), o.positiveValuesOnly && rM(k) && k <= 0 && (k = void 0), a.total = a.stackTotal = rH(y.total), a.percentage = rM(a.y) && y.total ? a.y / y.total * 100 : void 0, a.stackY = v, this.irregularWidths || y.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a.yBottom = rM(k) ? m(o.translate(k, !1, !0, !1, !0)) : void 0, this.dataModify && (v = this.dataModify.modifyValue(v, c)), rN(v) && void 0 !== a.plotX && (t = rN(t = o.translate(v, !1, !0, !1, !0)) ? m(t) : void 0), a.plotY = t, a.isInside = this.isPointInside(a), a.clientX = h ? rk(i.translate(x, !1, !1, !1, !0, n)) : p, a.negative = (a.y || 0) < (l || 0), a.isNull || !1 === a.visible || (void 0 !== g && (f = Math.min(f, Math.abs(p - g))), g = p), a.zone = this.zones.length ? a.getZone() : void 0, !a.graphic && this.group && s && (a.isNew = !0);
                }
                this.closestPointRangePx = f, rO(this, "afterTranslate");
            }
            getValidPoints(t, e, i) {
                let s = this.chart;
                return (t || this.points || []).filter(function(t) {
                    let { plotX: o, plotY: r } = t;
                    return !!((i || !t.isNull && rN(r)) && (!e || s.isInsidePlot(o, r, {
                        inverted: s.inverted
                    }))) && !1 !== t.visible;
                });
            }
            getClipBox() {
                let { chart: t, xAxis: e, yAxis: i } = this, { x: s, y: o, width: r, height: a } = rR(t.clipBox);
                return e && e.len !== t.plotSizeX && (r = e.len), i && i.len !== t.plotSizeY && (a = i.len), t.inverted && !this.invertible && ([r, a] = [
                    a,
                    r
                ]), {
                    x: s,
                    y: o,
                    width: r,
                    height: a
                };
            }
            getSharedClipKey() {
                return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
            }
            setClip() {
                let { chart: t, group: e, markerGroup: i } = this, s = t.sharedClips, o = t.renderer, r = this.getClipBox(), a = this.getSharedClipKey(), n = s[a];
                n ? n.animate(r) : s[a] = n = o.clipRect(r), e && e.clip(!1 === this.options.clip ? void 0 : n), i && i.clip();
            }
            animate(t) {
                let { chart: e, group: i, markerGroup: s } = this, o = e.inverted, r = rc(this.options.animation), a = [
                    this.getSharedClipKey(),
                    r.duration,
                    r.easing,
                    r.defer
                ].join(","), n = e.sharedClips[a], h = e.sharedClips[a + "m"];
                if (t && i) {
                    let t = this.getClipBox();
                    if (n) n.attr("height", t.height);
                    else {
                        t.width = 0, o && (t.x = e.plotHeight), n = e.renderer.clipRect(t), e.sharedClips[a] = n;
                        let i = {
                            x: -99,
                            y: -99,
                            width: o ? e.plotWidth + 199 : 99,
                            height: o ? 99 : e.plotHeight + 199
                        };
                        h = e.renderer.clipRect(i), e.sharedClips[a + "m"] = h;
                    }
                    i.clip(n), s?.clip(h);
                } else if (n && !n.hasClass("highcharts-animating")) {
                    let t = this.getClipBox(), i = r.step;
                    (s?.element.childNodes.length || e.series.length > 1) && (r.step = function(t, e) {
                        i && i.apply(e, arguments), "width" === e.prop && h?.element && h.attr(o ? "height" : "width", t + 99);
                    }), n.addClass("highcharts-animating").animate(t, r);
                }
            }
            afterAnimate() {
                this.setClip(), rW(this.chart.sharedClips, (t, e, i)=>{
                    t && !this.chart.container.querySelector(`[clip-path="url(#${t.id})"]`) && (t.destroy(), delete i[e]);
                }), this.finishedAnimating = !0, rO(this, "afterAnimate");
            }
            drawPoints(t = this.points) {
                let e, i, s, o, r, a, n;
                let h = this.chart, l = h.styledMode, { colorAxis: d, options: c } = this, p = c.marker, g = this[this.specialGroup || "markerGroup"], u = this.xAxis, f = rH(p.enabled, !u || !!u.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);
                if (!1 !== p.enabled || this._hasPointMarkers) for(e = 0; e < t.length; e++)if (o = (s = (i = t[e]).graphic) ? "animate" : "attr", r = i.marker || {}, a = !!i.marker, (f && void 0 === r.enabled || r.enabled) && !i.isNull && !1 !== i.visible) {
                    let t = rH(r.symbol, this.symbol, "rect");
                    n = this.markerAttribs(i, i.selected && "select"), this.enabledDataSorting && (i.startXPos = u.reversed ? -(n.width || 0) : u.width);
                    let e = !1 !== i.isInside;
                    if (!s && e && ((n.width || 0) > 0 || i.hasImage) && (i.graphic = s = h.renderer.symbol(t, n.x, n.y, n.width, n.height, a ? r : p).add(g), this.enabledDataSorting && h.hasRendered && (s.attr({
                        x: i.startXPos
                    }), o = "animate")), s && "animate" === o && s[e ? "show" : "hide"](e).animate(n), s) {
                        let t = this.pointAttribs(i, l || !i.selected ? void 0 : "select");
                        l ? d && s.css({
                            fill: t.fill
                        }) : s[o](t);
                    }
                    s && s.addClass(i.getClassName(), !0);
                } else s && (i.graphic = s.destroy());
            }
            markerAttribs(t, e) {
                let i = this.options, s = i.marker, o = t.marker || {}, r = o.symbol || s.symbol, a = {}, n, h, l = rH(o.radius, s && s.radius);
                e && (n = s.states[e], l = rH((h = o.states && o.states[e]) && h.radius, n && n.radius, l && l + (n && n.radiusPlus || 0))), t.hasImage = r && 0 === r.indexOf("url"), t.hasImage && (l = 0);
                let d = t.pos();
                return rN(l) && d && (i.crisp && (d[0] = rw(d[0], t.hasImage ? 0 : "rect" === r ? s?.lineWidth || 0 : 1)), a.x = d[0] - l, a.y = d[1] - l), l && (a.width = a.height = 2 * l), a;
            }
            pointAttribs(t, e) {
                let i = this.options.marker, s = t && t.options, o = s && s.marker || {}, r = s && s.color, a = t && t.color, n = t && t.zone && t.zone.color, h, l, d = this.color, c, p, g = rH(o.lineWidth, i.lineWidth), u = 1;
                return d = r || n || a || d, c = o.fillColor || i.fillColor || d, p = o.lineColor || i.lineColor || d, e = e || "normal", h = i.states[e] || {}, g = rH((l = o.states && o.states[e] || {}).lineWidth, h.lineWidth, g + rH(l.lineWidthPlus, h.lineWidthPlus, 0)), c = l.fillColor || h.fillColor || c, {
                    stroke: p = l.lineColor || h.lineColor || p,
                    "stroke-width": g,
                    fill: c,
                    opacity: u = rH(l.opacity, h.opacity, u)
                };
            }
            destroy(t) {
                let e, i, s;
                let o = this, r = o.chart, a = /AppleWebKit\/533/.test(rm.navigator.userAgent), n = o.data || [];
                for(rO(o, "destroy", {
                    keepEventsForUpdate: t
                }), this.removeEvents(t), (o.axisTypes || []).forEach(function(t) {
                    (s = o[t]) && s.series && (rC(s.series, o), s.isDirty = s.forceRedraw = !0);
                }), o.legendItem && o.chart.legend.destroyItem(o), e = n.length; e--;)(i = n[e]) && i.destroy && i.destroy();
                for (let t of o.zones)rS(t, void 0, !0);
                $.clearTimeout(o.animationTimeout), rW(o, function(t, e) {
                    t instanceof ej && !t.survive && t[a && "group" === e ? "hide" : "destroy"]();
                }), r.hoverSeries === o && (r.hoverSeries = void 0), rC(r.series, o), r.orderItems("series"), rW(o, function(e, i) {
                    t && "hcEvents" === i || delete o[i];
                });
            }
            applyZones() {
                let { area: t, chart: e, graph: i, zones: s, points: o, xAxis: r, yAxis: a, zoneAxis: n } = this, { inverted: h, renderer: l } = e, d = this[`${n}Axis`], { isXAxis: c, len: p = 0, minPointOffset: g = 0 } = d || {}, u = (i?.strokeWidth() || 0) / 2 + 1, f = (t, e = 0, i = 0)=>{
                    h && (i = p - i);
                    let { translated: s = 0, lineClip: o } = t, r = i - s;
                    o?.push([
                        "L",
                        e,
                        Math.abs(r) < u ? i - u * (r <= 0 ? -1 : 1) : s
                    ]);
                };
                if (s.length && (i || t) && d && rN(d.min)) {
                    let e = d.getExtremes().max + g, u = (t)=>{
                        t.forEach((e, i)=>{
                            ("M" === e[0] || "L" === e[0]) && (t[i] = [
                                e[0],
                                c ? p - e[1] : e[1],
                                c ? e[2] : p - e[2]
                            ]);
                        });
                    };
                    if (s.forEach((t)=>{
                        t.lineClip = [], t.translated = rv(d.toPixels(rH(t.value, e), !0) || 0, 0, p);
                    }), i && !this.showLine && i.hide(), t && t.hide(), "y" === n && o.length < r.len) for (let t of o){
                        let { plotX: e, plotY: i, zone: o } = t, r = o && s[s.indexOf(o) - 1];
                        o && f(o, e, i), r && f(r, e, i);
                    }
                    let m = [], x = d.toPixels(d.getExtremes().min - g, !0);
                    s.forEach((e)=>{
                        let s = e.lineClip || [], o = Math.round(e.translated || 0);
                        r.reversed && s.reverse();
                        let { clip: n, simpleClip: d } = e, p = 0, g = 0, f = r.len, y = a.len;
                        c ? (p = o, f = x) : (g = o, y = x);
                        let b = [
                            [
                                "M",
                                p,
                                g
                            ],
                            [
                                "L",
                                f,
                                g
                            ],
                            [
                                "L",
                                f,
                                y
                            ],
                            [
                                "L",
                                p,
                                y
                            ],
                            [
                                "Z"
                            ]
                        ], v = [
                            b[0],
                            ...s,
                            b[1],
                            b[2],
                            ...m,
                            b[3],
                            b[4]
                        ];
                        m = s.reverse(), x = o, h && (u(v), t && u(b)), n ? (n.animate({
                            d: v
                        }), d?.animate({
                            d: b
                        })) : (n = e.clip = l.path(v), t && (d = e.simpleClip = l.path(b))), i && e.graph?.clip(n), t && e.area?.clip(d);
                    });
                } else this.visible && (i && i.show(), t && t.show());
            }
            plotGroup(t, e, i, s, o) {
                let r = this[t], a = !r, n = {
                    visibility: i,
                    zIndex: s || .1
                };
                return rM(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (n.opacity = this.opacity), r || (this[t] = r = this.chart.renderer.g().add(o)), r.addClass("highcharts-" + e + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (rM(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), r.attr(n)[a ? "attr" : "animate"](this.getPlotBox(e)), r;
            }
            getPlotBox(t) {
                let e = this.xAxis, i = this.yAxis, s = this.chart, o = s.inverted && !s.polar && e && this.invertible && "series" === t;
                return s.inverted && (e = i, i = this.xAxis), {
                    translateX: e ? e.left : s.plotLeft,
                    translateY: i ? i.top : s.plotTop,
                    rotation: o ? 90 : 0,
                    rotationOriginX: o ? (e.len - i.len) / 2 : 0,
                    rotationOriginY: o ? (e.len + i.len) / 2 : 0,
                    scaleX: o ? -1 : 1,
                    scaleY: 1
                };
            }
            removeEvents(t) {
                let { eventsToUnbind: e } = this;
                t || rX(this), e.length && (e.forEach((t)=>{
                    t();
                }), e.length = 0);
            }
            render() {
                let t = this, { chart: e, options: i, hasRendered: s } = t, o = rc(i.animation), r = t.visible ? "inherit" : "hidden", a = i.zIndex, n = e.seriesGroup, h = t.finishedAnimating ? 0 : o.duration;
                rO(this, "render"), t.plotGroup("group", "series", r, a, n), t.markerGroup = t.plotGroup("markerGroup", "markers", r, a, n), !1 !== i.clip && t.setClip(), h && t.animate?.(!0), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), t.drawDataLabels?.(), t.redrawPoints?.(), i.enableMouseTracking && t.drawTracker?.(), h && t.animate?.(), s || (h && o.defer && (h += o.defer), t.animationTimeout = rF(()=>{
                    t.afterAnimate();
                }, h || 0)), t.isDirty = !1, t.hasRendered = !0, rO(t, "afterRender");
            }
            redraw() {
                let t = this.isDirty || this.isDirtyData;
                this.translate(), this.render(), t && delete this.kdTree;
            }
            reserveSpace() {
                return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
            }
            searchPoint(t, e) {
                let { xAxis: i, yAxis: s } = this, o = this.chart.inverted;
                return this.searchKDTree({
                    clientX: o ? i.len - t.chartY + i.pos : t.chartX - i.pos,
                    plotY: o ? s.len - t.chartX + s.pos : t.chartY - s.pos
                }, e, t);
            }
            buildKDTree(t) {
                this.buildingKdTree = !0;
                let e = this, i = e.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
                delete e.kdTree, rF(function() {
                    e.kdTree = function t(i, s, o) {
                        let r, a;
                        let n = i?.length;
                        if (n) return r = e.kdAxisArray[s % o], i.sort((t, e)=>(t[r] || 0) - (e[r] || 0)), {
                            point: i[a = Math.floor(n / 2)],
                            left: t(i.slice(0, a), s + 1, o),
                            right: t(i.slice(a + 1), s + 1, o)
                        };
                    }(e.getValidPoints(void 0, !e.directTouch), i, i), e.buildingKdTree = !1;
                }, e.options.kdNow || t?.type === "touchstart" ? 0 : 1);
            }
            searchKDTree(t, e, i, s, o) {
                let r = this, [a, n] = this.kdAxisArray, h = e ? "distX" : "dist", l = (r.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, d = !!r.isBubble, c = s || ((t, e, i)=>[
                        (t[i] || 0) < (e[i] || 0) ? t : e,
                        !1
                    ]), p = o || ((t, e)=>t < e);
                if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, s, o) {
                    let l = i.point, g = r.kdAxisArray[s % o], u = l, f = !1;
                    !function(t, e) {
                        let i = t[a], s = e[a], o = rM(i) && rM(s) ? i - s : null, r = t[n], h = e[n], l = rM(r) && rM(h) ? r - h : 0, c = d && e.marker?.radius || 0;
                        e.dist = Math.sqrt((o && o * o || 0) + l * l) - c, e.distX = rM(o) ? Math.abs(o) - c : Number.MAX_VALUE;
                    }(e, l);
                    let m = (e[g] || 0) - (l[g] || 0) + (d && l.marker?.radius || 0), x = m < 0 ? "left" : "right", y = m < 0 ? "right" : "left";
                    return i[x] && ([u, f] = c(l, t(e, i[x], s + 1, o), h)), i[y] && p(Math.sqrt(m * m), u[h], f) && (u = c(u, t(e, i[y], s + 1, o), h)[0]), u;
                }(t, this.kdTree, l, l);
            }
            pointPlacementToXValue() {
                let { options: t, xAxis: e } = this, i = t.pointPlacement;
                return "between" === i && (i = e.reversed ? -.5 : .5), rN(i) ? i * (t.pointRange || e.pointRange) : 0;
            }
            isPointInside(t) {
                let { chart: e, xAxis: i, yAxis: s } = this, { plotX: o = -1, plotY: r = -1 } = t;
                return r >= 0 && r <= (s ? s.len : e.plotHeight) && o >= 0 && o <= (i ? i.len : e.plotWidth);
            }
            drawTracker() {
                let t = this, e = t.options, i = e.trackByArea, s = [].concat((i ? t.areaPath : t.graphPath) || []), o = t.chart, r = o.pointer, a = o.renderer, n = o.options.tooltip?.snap || 0, h = ()=>{
                    e.enableMouseTracking && o.hoverSeries !== t && t.onMouseOver();
                }, l = "rgba(192,192,192," + (rf ? 1e-4 : .002) + ")", d = t.tracker;
                d ? d.attr({
                    d: s
                }) : t.graph && (t.tracker = d = a.path(s).attr({
                    visibility: t.visible ? "inherit" : "hidden",
                    zIndex: 2
                }).addClass(i ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t.group), o.styledMode || d.attr({
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    stroke: l,
                    fill: i ? l : "none",
                    "stroke-width": t.graph.strokeWidth() + (i ? 0 : 2 * n)
                }), [
                    t.tracker,
                    t.markerGroup,
                    t.dataLabelsGroup
                ].forEach((t)=>{
                    t && (t.addClass("highcharts-tracker").on("mouseover", h).on("mouseout", (t)=>{
                        r?.onTrackerMouseOut(t);
                    }), e.cursor && !o.styledMode && t.css({
                        cursor: e.cursor
                    }), t.on("touchstart", h));
                })), rO(this, "afterDrawTracker");
            }
            addPoint(t, e, i, s, o) {
                let r, a;
                let n = this.options, { chart: h, data: l, dataTable: d, xAxis: c } = this, p = c && c.hasNames && c.names, g = n.data, u = this.getColumn("x");
                e = rH(e, !0);
                let f = {
                    series: this
                };
                this.pointClass.prototype.applyOptions.apply(f, [
                    t
                ]);
                let m = f.x;
                if (a = u.length, this.requireSorting && m < u[a - 1]) for(r = !0; a && u[a - 1] > m;)a--;
                d.setRow(f, a, !0, {
                    addColumns: !1
                }), p && f.name && (p[m] = f.name), g?.splice(a, 0, t), (r || this.processedData) && (this.data.splice(a, 0, null), this.processData()), "point" === n.legendType && this.generatePoints(), i && (l[0] && l[0].remove ? l[0].remove(!1) : ([
                    l,
                    g,
                    ...Object.values(d.getColumns())
                ].filter(rM).forEach((t)=>{
                    t.shift();
                }), d.rowCount -= 1, rO(d, "afterDeleteRows"))), !1 !== o && rO(this, "addPoint", {
                    point: f
                }), this.isDirty = !0, this.isDirtyData = !0, e && h.redraw(s);
            }
            removePoint(t, e, i) {
                let s = this, { chart: o, data: r, points: a, dataTable: n } = s, h = r[t], l = function() {
                    [
                        a?.length === r.length ? a : void 0,
                        r,
                        s.options.data,
                        ...Object.values(n.getColumns())
                    ].filter(rM).forEach((e)=>{
                        e.splice(t, 1);
                    }), n.rowCount -= 1, rO(n, "afterDeleteRows"), h?.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && o.redraw();
                };
                rp(i, o), e = rH(e, !0), h ? h.firePointEvent("remove", null, l) : l();
            }
            remove(t, e, i, s) {
                let o = this, r = o.chart;
                function a() {
                    o.destroy(s), r.isDirtyLegend = r.isDirtyBox = !0, r.linkSeries(s), rH(t, !0) && r.redraw(e);
                }
                !1 !== i ? rO(o, "remove", null, a) : a();
            }
            update(t, e) {
                rO(this, "update", {
                    options: t = rT(t, this.userOptions)
                });
                let i = this, s = i.chart, o = i.userOptions, r = i.initialType || i.type, a = s.options.plotOptions, n = rx[r].prototype, h = i.finishedAnimating && {
                    animation: !1
                }, l = {}, d, c, p = [
                    "colorIndex",
                    "eventOptions",
                    "navigatorSeries",
                    "symbolIndex",
                    "baseSeries"
                ], g = t.type || o.type || s.options.chart.type, u = !(this.hasDerivedData || g && g !== this.type || void 0 !== t.keys || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || [
                    "dataGrouping",
                    "pointStart",
                    "pointInterval",
                    "pointIntervalUnit",
                    "keys"
                ].some((t)=>i.hasOptionChanged(t)));
                g = g || r, u ? (p.push("data", "isDirtyData", "isDirtyCanvas", "points", "dataTable", "processedData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"), !1 !== t.visible && p.push("area", "graph"), i.parallelArrays.forEach(function(t) {
                    p.push(t + "Data");
                }), t.data && (t.dataSorting && rP(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))) : this.dataTable.modified = this.dataTable, t = rR(o, {
                    index: void 0 === o.index ? i.index : o.index,
                    pointStart: a?.series?.pointStart ?? o.pointStart ?? i.getColumn("x")[0]
                }, !u && {
                    data: i.options.data
                }, t, h), u && t.data && (t.data = i.options.data), (p = [
                    "group",
                    "markerGroup",
                    "dataLabelsGroup",
                    "transformGroup"
                ].concat(p)).forEach(function(t) {
                    p[t] = i[t], delete i[t];
                });
                let f = !1;
                if (rx[g]) {
                    if (f = g !== i.type, i.remove(!1, !1, !1, !0), f) {
                        if (s.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i, rx[g].prototype);
                        else {
                            let t = Object.hasOwnProperty.call(i, "hcEvents") && i.hcEvents;
                            for(c in n)i[c] = void 0;
                            rP(i, rx[g].prototype), t ? i.hcEvents = t : delete i.hcEvents;
                        }
                    }
                } else rA(17, !0, s, {
                    missingModuleFor: g
                });
                if (p.forEach(function(t) {
                    i[t] = p[t];
                }), i.init(s, t), u && this.points) for (let t of (!1 === (d = i.options).visible ? (l.graphic = 1, l.dataLabel = 1) : (this.hasMarkerChanged(d, o) && (l.graphic = 1), i.hasDataLabels?.() || (l.dataLabel = 1)), this.points))t && t.series && (t.resolveColor(), Object.keys(l).length && t.destroyElements(l), !1 === d.showInLegend && t.legendItem && s.legend.destroyItem(t));
                i.initialType = r, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), rO(this, "afterUpdate"), rH(e, !0) && s.redraw(!!u && void 0);
            }
            setName(t) {
                this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;
            }
            hasOptionChanged(t) {
                let e = this.chart, i = this.options[t], s = e.options.plotOptions, o = this.userOptions[t], r = rH(s?.[this.type]?.[t], s?.series?.[t]);
                return o && !rM(r) ? i !== o : i !== rH(r, i);
            }
            onMouseOver() {
                let t = this.chart, e = t.hoverSeries, i = t.pointer;
                i?.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && rO(this, "mouseOver"), this.setState("hover"), t.hoverSeries = this;
            }
            onMouseOut() {
                let t = this.options, e = this.chart, i = e.tooltip, s = e.hoverPoint;
                e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && rO(this, "mouseOut"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function(t) {
                    t.setState("", !0);
                });
            }
            setState(t, e) {
                let i = this, s = i.options, o = i.graph, r = s.inactiveOtherPoints, a = s.states, n = rH(a[t || "normal"] && a[t || "normal"].animation, i.chart.options.chart.animation), h = s.lineWidth, l = s.opacity;
                if (t = t || "", i.state !== t && ([
                    i.group,
                    i.markerGroup,
                    i.dataLabelsGroup
                ].forEach(function(e) {
                    e && (i.state && e.removeClass("highcharts-series-" + i.state), t && e.addClass("highcharts-series-" + t));
                }), i.state = t, !i.chart.styledMode)) {
                    if (a[t] && !1 === a[t].enabled) return;
                    if (t && (h = a[t].lineWidth || h + (a[t].lineWidthPlus || 0), l = rH(a[t].opacity, l)), o && !o.dashstyle && rN(h)) for (let t of [
                        o,
                        ...this.zones.map((t)=>t.graph)
                    ])t?.animate({
                        "stroke-width": h
                    }, n);
                    r || [
                        i.group,
                        i.markerGroup,
                        i.dataLabelsGroup,
                        i.labelBySeries
                    ].forEach(function(t) {
                        t && t.animate({
                            opacity: l
                        }, n);
                    });
                }
                e && r && i.points && i.setAllPointsToState(t || void 0);
            }
            setAllPointsToState(t) {
                this.points.forEach(function(e) {
                    e.setState && e.setState(t);
                });
            }
            setVisible(t, e) {
                let i = this, s = i.chart, o = s.options.chart.ignoreHiddenSeries, r = i.visible;
                i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !r : t;
                let a = t ? "show" : "hide";
                [
                    "group",
                    "dataLabelsGroup",
                    "markerGroup",
                    "tracker",
                    "tt"
                ].forEach((t)=>{
                    i[t]?.[a]();
                }), (s.hoverSeries === i || s.hoverPoint?.series === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach((t)=>{
                    t.options.stacking && t.visible && (t.isDirty = !0);
                }), i.linkedSeries.forEach((e)=>{
                    e.setVisible(t, !1);
                }), o && (s.isDirtyBox = !0), rO(i, a), !1 !== e && s.redraw();
            }
            show() {
                this.setVisible(!0);
            }
            hide() {
                this.setVisible(!1);
            }
            select(t) {
                this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), rO(this, t ? "select" : "unselect");
            }
            shouldShowTooltip(t, e, i = {}) {
                return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);
            }
            drawLegendSymbol(t, e) {
                rr[this.options.legendSymbol || "rectangle"]?.call(this, t, e);
            }
        }
        rG.defaultOptions = {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
                duration: 1e3
            },
            enableMouseTracking: !0,
            events: {},
            marker: {
                enabledThreshold: 2,
                lineColor: "#ffffff",
                lineWidth: 0,
                radius: 4,
                states: {
                    normal: {
                        animation: !0
                    },
                    hover: {
                        animation: {
                            duration: 150
                        },
                        enabled: !0,
                        radiusPlus: 2,
                        lineWidthPlus: 1
                    },
                    select: {
                        fillColor: "#cccccc",
                        lineColor: "#000000",
                        lineWidth: 2
                    }
                }
            },
            point: {
                events: {}
            },
            dataLabels: {
                animation: {},
                align: "center",
                borderWidth: 0,
                defer: !0,
                formatter: function() {
                    let { numberFormatter: t } = this.series.chart;
                    return "number" != typeof this.y ? "" : t(this.y, -1);
                },
                padding: 5,
                style: {
                    fontSize: "0.7em",
                    fontWeight: "bold",
                    color: "contrast",
                    textOutline: "1px contrast"
                },
                verticalAlign: "bottom",
                x: 0,
                y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
                normal: {
                    animation: !0
                },
                hover: {
                    animation: {
                        duration: 150
                    },
                    lineWidthPlus: 1,
                    marker: {},
                    halo: {
                        size: 10,
                        opacity: .25
                    }
                },
                select: {
                    animation: {
                        duration: 0
                    }
                },
                inactive: {
                    animation: {
                        duration: 150
                    },
                    opacity: .2
                }
            },
            stickyTracking: !0,
            turboThreshold: 1e3,
            findNearestPointBy: "x"
        }, rG.types = rd.seriesTypes, rG.registerType = rd.registerSeriesType, rP(rG.prototype, {
            axisTypes: [
                "xAxis",
                "yAxis"
            ],
            coll: "series",
            colorCounter: 0,
            directTouch: !1,
            invertible: !0,
            isCartesian: !0,
            kdAxisArray: [
                "clientX",
                "plotY"
            ],
            parallelArrays: [
                "x",
                "y"
            ],
            pointClass: oF,
            requireSorting: !0,
            sorted: !0
        }), rd.series = rG;
        let rY = rG, { animObject: rj, setAnimation: rU } = tR, { registerEventOptions: r$ } = i3, { composed: rV, marginNames: r_ } = k, { distribute: rq } = ed, { format: rZ } = eo, { addEvent: rK, createElement: rJ, css: rQ, defined: r0, discardElement: r1, find: r2, fireEvent: r3, isNumber: r5, merge: r6, pick: r9, pushUnique: r4, relativeLength: r8, stableSort: r7, syncTimeout: at } = $;
        class ae {
            constructor(t, e){
                this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), r$(this, e), rK(this.chart, "endResize", function() {
                    this.legend.positionCheckboxes();
                })), rK(this.chart, "render", ()=>{
                    this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
                });
            }
            setOptions(t) {
                let e = r9(t.padding, 8);
                this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = r6(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = r9(t.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t.layout && !this.chart.inverted, this.baseline = void 0;
            }
            update(t, e) {
                let i = this.chart;
                this.setOptions(r6(!0, this.options, t)), "events" in this.options && r$(this, this.options), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, r9(e, !0) && i.redraw(), r3(this, "afterUpdate", {
                    redraw: e
                });
            }
            colorizeItem(t, e) {
                let i = t.color, { area: s, group: o, label: r, line: a, symbol: n } = t.legendItem || {};
                if ((t instanceof rY || t instanceof oF) && (t.color = t.options?.legendSymbolColor || i), o?.[e ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
                    let { itemHiddenStyle: i = {} } = this, o = i.color, { fillColor: h, fillOpacity: l, lineColor: d, marker: c } = t.options, p = (t)=>(!e && (t.fill && (t.fill = o), t.stroke && (t.stroke = o)), t);
                    r?.css(r6(e ? this.itemStyle : i)), a?.attr(p({
                        stroke: d || t.color
                    })), n && n.attr(p(c && n.isMarker ? t.pointAttribs() : {
                        fill: t.color
                    })), s?.attr(p({
                        fill: h || t.color,
                        "fill-opacity": h ? 1 : l ?? .75
                    }));
                }
                t.color = i, r3(this, "afterColorizeItem", {
                    item: t,
                    visible: e
                });
            }
            positionItems() {
                this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
            }
            positionItem(t) {
                let { group: e, x: i = 0, y: s = 0 } = t.legendItem || {}, o = this.options, r = o.symbolPadding, a = !o.rtl, n = t.checkbox;
                if (e && e.element) {
                    let o = {
                        translateX: a ? i : this.legendWidth - i - 2 * r - 4,
                        translateY: s
                    };
                    e[r0(e.translateY) ? "animate" : "attr"](o, void 0, ()=>{
                        r3(this, "afterPositionItem", {
                            item: t
                        });
                    });
                }
                n && (n.x = i, n.y = s);
            }
            destroyItem(t) {
                let e = t.checkbox, i = t.legendItem || {};
                for (let t of [
                    "group",
                    "label",
                    "line",
                    "symbol"
                ])i[t] && (i[t] = i[t].destroy());
                e && r1(e), t.legendItem = void 0;
            }
            destroy() {
                for (let t of this.getAllItems())this.destroyItem(t);
                for (let t of [
                    "clipRect",
                    "up",
                    "down",
                    "pager",
                    "nav",
                    "box",
                    "title",
                    "group"
                ])this[t] && (this[t] = this[t].destroy());
                this.display = null;
            }
            positionCheckboxes() {
                let t;
                let e = this.group && this.group.alignAttr, i = this.clipHeight || this.legendHeight, s = this.titleHeight;
                e && (t = e.translateY, this.allItems.forEach(function(o) {
                    let r;
                    let a = o.checkbox;
                    a && (r = t + s + a.y + (this.scrollOffset || 0) + 3, rQ(a, {
                        left: e.translateX + o.checkboxOffset + a.x - 20 + "px",
                        top: r + "px",
                        display: this.proximate || r > t - 6 && r < t + i - 6 ? "" : "none"
                    }));
                }, this));
            }
            renderTitle() {
                let t = this.options, e = this.padding, i = t.title, s, o = 0;
                i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, "legend-title").attr({
                    zIndex: 1
                }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({
                    width: this.maxLegendWidth + "px"
                }), o = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({
                    translateY: o
                })), this.titleHeight = o;
            }
            setText(t) {
                let e = this.options;
                t.legendItem.label.attr({
                    text: e.labelFormat ? rZ(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)
                });
            }
            renderItem(t) {
                let e = t.legendItem = t.legendItem || {}, i = this.chart, s = i.renderer, o = this.options, r = "horizontal" === o.layout, a = this.symbolWidth, n = o.symbolPadding || 0, h = this.itemStyle, l = this.itemHiddenStyle, d = r ? r9(o.itemDistance, 20) : 0, c = !o.rtl, p = !t.series, g = !p && t.series.drawLegendSymbol ? t.series : t, u = g.options, f = !!this.createCheckboxForItem && u && u.showCheckbox, m = o.useHTML, x = t.options.className, y = e.label, b = a + n + d + (f ? 20 : 0);
                !y && (e.group = s.g("legend-item").addClass("highcharts-" + g.type + "-series highcharts-color-" + t.colorIndex + (x ? " " + x : "") + (p ? " highcharts-series-" + t.index : "")).attr({
                    zIndex: 1
                }).add(this.scrollGroup), e.label = y = s.text("", c ? a + n : -n, this.baseline || 0, m), i.styledMode || y.css(r6(t.visible ? h : l)), y.attr({
                    align: c ? "left" : "right",
                    zIndex: 2
                }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr("y", this.baseline), this.symbolHeight = r9(o.symbolHeight, this.fontMetrics.f), o.squareSymbol && (this.symbolWidth = r9(o.symbolWidth, Math.max(this.symbolHeight, 16)), b = this.symbolWidth + n + d + (f ? 20 : 0), c && y.attr("x", this.symbolWidth + n))), g.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !h.width) && y.css({
                    width: (o.itemWidth || this.widthOption || i.spacingBox.width) - b + "px"
                }), this.setText(t);
                let v = y.getBBox(), k = this.fontMetrics && this.fontMetrics.h || 0;
                t.itemWidth = t.checkboxOffset = o.itemWidth || e.labelWidth || v.width + b, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * k ? v.height : k));
            }
            layoutItem(t) {
                let e = this.options, i = this.padding, s = "horizontal" === e.layout, o = t.itemHeight, r = this.itemMarginBottom, a = this.itemMarginTop, n = s ? r9(e.itemDistance, 20) : 0, h = this.maxLegendWidth, l = e.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : t.itemWidth, d = t.legendItem || {};
                s && this.itemX - i + l > h && (this.itemX = i, this.lastLineHeight && (this.itemY += a + this.lastLineHeight + r), this.lastLineHeight = 0), this.lastItemY = a + this.itemY + r, this.lastLineHeight = Math.max(o, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += l : (this.itemY += a + o + r, this.lastLineHeight = o), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : n) : l) + i, this.offsetWidth);
            }
            getAllItems() {
                let t = [];
                return this.chart.series.forEach(function(e) {
                    let i = e && e.options;
                    e && r9(i.showInLegend, !r0(i.linkedTo) && void 0, !0) && (t = t.concat((e.legendItem || {}).labels || ("point" === i.legendType ? e.data : e)));
                }), r3(this, "afterGetAllItems", {
                    allItems: t
                }), t;
            }
            getAlignment() {
                let t = this.options;
                return this.proximate ? t.align.charAt(0) + "tv" : t.floating ? "" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);
            }
            adjustMargins(t, e) {
                let i = this.chart, s = this.options, o = this.getAlignment();
                o && [
                    /(lth|ct|rth)/,
                    /(rtv|rm|rbv)/,
                    /(rbh|cb|lbh)/,
                    /(lbv|lm|ltv)/
                ].forEach(function(r, a) {
                    r.test(o) && !r0(t[a]) && (i[r_[a]] = Math.max(i[r_[a]], i.legend[(a + 1) % 2 ? "legendHeight" : "legendWidth"] + [
                        1,
                        -1,
                        -1,
                        1
                    ][a] * s[a % 2 ? "x" : "y"] + r9(s.margin, 12) + e[a] + (i.titleOffset[a] || 0)));
                });
            }
            proximatePositions() {
                let t;
                let e = this.chart, i = [], s = "left" === this.options.align;
                for (let o of (this.allItems.forEach(function(t) {
                    let o, r, a = s, n, h;
                    t.yAxis && (t.xAxis.options.reversed && (a = !a), t.points && (o = r2(a ? t.points : t.points.slice(0).reverse(), function(t) {
                        return r5(t.plotY);
                    })), r = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, h = t.yAxis.top - e.plotTop, n = t.visible ? (o ? o.plotY : t.yAxis.height) + (h - .3 * r) : h + t.yAxis.height, i.push({
                        target: n,
                        size: r,
                        item: t
                    }));
                }, this), rq(i, e.plotHeight)))t = o.item.legendItem || {}, r5(o.pos) && (t.y = e.plotTop - e.spacing[0] + o.pos);
            }
            render() {
                let t = this.chart, e = t.renderer, i = this.options, s = this.padding, o = this.getAllItems(), r, a, n, h = this.group, l, d = this.box;
                this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = r8(i.width, t.spacingBox.width - s), l = t.spacingBox.width - 2 * s - i.x, [
                    "rm",
                    "lm"
                ].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l /= 2), this.maxLegendWidth = this.widthOption || l, h || (this.group = h = e.g("legend").addClass(i.className || "").attr({
                    zIndex: 7
                }).add(), this.contentGroup = e.g().attr({
                    zIndex: 1
                }).add(h), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), r7(o, (t, e)=>(t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0)), i.reversed && o.reverse(), this.allItems = o, this.display = r = !!o.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o.forEach(this.renderItem, this), o.forEach(this.layoutItem, this), a = (this.widthOption || this.offsetWidth) + s, n = this.lastItemY + this.lastLineHeight + this.titleHeight, n = this.handleOverflow(n) + s, d || (this.box = d = e.rect().addClass("highcharts-legend-box").attr({
                    r: i.borderRadius
                }).add(h)), t.styledMode || d.attr({
                    stroke: i.borderColor,
                    "stroke-width": i.borderWidth || 0,
                    fill: i.backgroundColor || "none"
                }).shadow(i.shadow), a > 0 && n > 0 && d[d.placed ? "animate" : "attr"](d.crisp.call({}, {
                    x: 0,
                    y: 0,
                    width: a,
                    height: n
                }, d.strokeWidth())), h[r ? "show" : "hide"](), t.styledMode && "none" === h.getStyle("display") && (a = n = 0), this.legendWidth = a, this.legendHeight = n, r && this.align(), this.proximate || this.positionItems(), r3(this, "afterRender");
            }
            align(t = this.chart.spacingBox) {
                let e = this.chart, i = this.options, s = t.y;
                /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = r6(t, {
                    y: s
                })), e.hasRendered || (this.group.placed = !1), this.group.align(r6(i, {
                    width: this.legendWidth,
                    height: this.legendHeight,
                    verticalAlign: this.proximate ? "top" : i.verticalAlign
                }), !0, t);
            }
            handleOverflow(t) {
                let e = this, i = this.chart, s = i.renderer, o = this.options, r = o.y, a = "top" === o.verticalAlign, n = this.padding, h = o.maxHeight, l = o.navigation, d = r9(l.animation, !0), c = l.arrowSize || 12, p = this.pages, g = this.allItems, u = function(t) {
                    "number" == typeof t ? k.attr({
                        height: t
                    }) : k && (e.clipRect = k.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? "rect(" + n + "px,9999px," + (n + t) + "px,0)" : "auto");
                }, f = function(t) {
                    return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(v), i.styledMode || e[t].attr("fill", "rgba(0,0,0,0.0001)"), e[t];
                }, m, x, y, b = i.spacingBox.height + (a ? -r : r) - n, v = this.nav, k = this.clipRect;
                return "horizontal" !== o.layout || "middle" === o.verticalAlign || o.floating || (b /= 2), h && (b = Math.min(b, h)), p.length = 0, t && b > 0 && t > b && !1 !== l.enabled ? (this.clipHeight = m = Math.max(b - 20 - this.titleHeight - n, 0), this.currentPage = r9(this.currentPage, 1), this.fullHeight = t, g.forEach((t, e)=>{
                    let i = (y = t.legendItem || {}).y || 0, s = Math.round(y.label.getBBox().height), o = p.length;
                    (!o || i - p[o - 1] > m && (x || i) !== p[o - 1]) && (p.push(x || i), o++), y.pageIx = o - 1, x && ((g[e - 1].legendItem || {}).pageIx = o - 1), e === g.length - 1 && i + s - p[o - 1] > m && i > p[o - 1] && (p.push(i), y.pageIx = o), i !== x && (x = i);
                }), k || (k = e.clipRect = s.clipRect(0, n - 2, 9999, 0), e.contentGroup.clip(k)), u(m), v || (this.nav = v = s.g().attr({
                    zIndex: 1
                }).add(this.group), this.up = s.symbol("triangle", 0, 0, c, c).add(v), f("upTracker").on("click", function() {
                    e.scroll(-1, d);
                }), this.pager = s.text("", 15, 10).addClass("highcharts-legend-navigation"), !i.styledMode && l.style && this.pager.css(l.style), this.pager.add(v), this.down = s.symbol("triangle-down", 0, 0, c, c).add(v), f("downTracker").on("click", function() {
                    e.scroll(1, d);
                })), e.scroll(0), t = b) : v && (u(), this.nav = v.destroy(), this.scrollGroup.attr({
                    translateY: 1
                }), this.clipHeight = 0), t;
            }
            scroll(t, e) {
                let i = this.chart, s = this.pages, o = s.length, r = this.clipHeight, a = this.options.navigation, n = this.pager, h = this.padding, l = this.currentPage + t;
                l > o && (l = o), l > 0 && (void 0 !== e && rU(e, i), this.nav.attr({
                    translateX: h,
                    translateY: r + this.padding + 7 + this.titleHeight,
                    visibility: "inherit"
                }), [
                    this.up,
                    this.upTracker
                ].forEach(function(t) {
                    t.attr({
                        class: 1 === l ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                }), n.attr({
                    text: l + "/" + o
                }), [
                    this.down,
                    this.downTracker
                ].forEach(function(t) {
                    t.attr({
                        x: 18 + this.pager.getBBox().width,
                        class: l === o ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                }, this), i.styledMode || (this.up.attr({
                    fill: 1 === l ? a.inactiveColor : a.activeColor
                }), this.upTracker.css({
                    cursor: 1 === l ? "default" : "pointer"
                }), this.down.attr({
                    fill: l === o ? a.inactiveColor : a.activeColor
                }), this.downTracker.css({
                    cursor: l === o ? "default" : "pointer"
                })), this.scrollOffset = -s[l - 1] + this.initialItemY, this.scrollGroup.animate({
                    translateY: this.scrollOffset
                }), this.currentPage = l, this.positionCheckboxes(), at(()=>{
                    r3(this, "afterScroll", {
                        currentPage: l
                    });
                }, rj(r9(e, i.renderer.globalAnimation, !0)).duration));
            }
            setItemEvents(t, e, i) {
                let s = this, o = t.legendItem || {}, r = s.chart.renderer.boxWrapper, a = t instanceof oF, n = t instanceof rY, h = "highcharts-legend-" + (a ? "point" : "series") + "-active", l = s.chart.styledMode, d = i ? [
                    e,
                    o.symbol
                ] : [
                    o.group
                ], c = (e)=>{
                    s.allItems.forEach((i)=>{
                        t !== i && [
                            i
                        ].concat(i.linkedSeries || []).forEach((t)=>{
                            t.setState(e, !a);
                        });
                    });
                };
                for (let i of d)i && i.on("mouseover", function() {
                    t.visible && c("inactive"), t.setState("hover"), t.visible && r.addClass(h), l || e.css(s.options.itemHoverStyle);
                }).on("mouseout", function() {
                    s.chart.styledMode || e.css(r6(t.visible ? s.itemStyle : s.itemHiddenStyle)), c(""), r.removeClass(h), t.setState();
                }).on("click", function(e) {
                    let i = function() {
                        t.setVisible && t.setVisible(), c(t.visible ? "inactive" : "");
                    };
                    r.removeClass(h), r3(s, "itemClick", {
                        browserEvent: e,
                        legendItem: t
                    }, i), a ? t.firePointEvent("legendItemClick", {
                        browserEvent: e
                    }) : n && r3(t, "legendItemClick", {
                        browserEvent: e
                    });
                });
            }
            createCheckboxForItem(t) {
                t.checkbox = rJ("input", {
                    type: "checkbox",
                    className: "highcharts-legend-checkbox",
                    checked: t.selected,
                    defaultChecked: t.selected
                }, this.options.itemCheckboxStyle, this.chart.container), rK(t.checkbox, "click", function(e) {
                    let i = e.target;
                    r3(t.series || t, "checkboxClick", {
                        checked: i.checked,
                        item: t
                    }, function() {
                        t.select();
                    });
                });
            }
        }
        !function(t) {
            t.compose = function(e) {
                r4(rV, "Core.Legend") && rK(e, "beforeMargins", function() {
                    this.legend = new t(this, this.options.legend);
                });
            };
        }(ae || (ae = {}));
        let ai = ae, { animate: as, animObject: ao, setAnimation: ar } = tR, { defaultOptions: aa } = tm, { numberFormat: an } = eo, { registerEventOptions: ah } = i3, { charts: al, doc: ad, marginNames: ac, svg: ap, win: ag } = k, { seriesTypes: au } = rd, { addEvent: af, attr: am, createElement: ax, css: ay, defined: ab, diffObjects: av, discardElement: ak, erase: aw, error: aM, extend: aS, find: aT, fireEvent: aC, getAlignFactor: aA, getStyle: aP, isArray: aL, isNumber: aO, isObject: aE, isString: aI, merge: aD, objectEach: aB, pick: aN, pInt: az, relativeLength: aR, removeEvent: aW, splat: aH, syncTimeout: aX, uniqueKey: aF } = $;
        class aG {
            static chart(t, e, i) {
                return new aG(t, e, i);
            }
            constructor(t, e, i){
                this.sharedClips = {};
                let s = [
                    ...arguments
                ];
                (aI(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]);
            }
            setZoomOptions() {
                let t = this.options.chart, e = t.zooming;
                this.zooming = {
                    ...e,
                    type: aN(t.zoomType, e.type),
                    key: aN(t.zoomKey, e.key),
                    pinchType: aN(t.pinchType, e.pinchType),
                    singleTouch: aN(t.zoomBySingleTouch, e.singleTouch, !1),
                    resetButton: aD(e.resetButton, t.resetZoomButton)
                };
            }
            init(t, e) {
                aC(this, "init", {
                    args: arguments
                }, function() {
                    let i = aD(aa, t), s = i.chart, o = this.renderTo || s.renderTo;
                    this.userOptions = aS({}, t), (this.renderTo = aI(o) ? ad.getElementById(o) : o) || aM(13, !0, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.locale = i.lang.locale ?? this.renderTo.closest("[lang]")?.lang, this.time = new td(aS(i.time || {}, {
                        locale: this.locale
                    })), i.time = this.time.options, this.numberFormatter = (s.numberFormatter || an).bind(this), this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = al.length, al.push(this), k.chartCount++, ah(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), aC(this, "afterInit"), this.firstRender();
                });
            }
            initSeries(t) {
                let e = this.options.chart, i = t.type || e.type, s = au[i];
                s || aM(17, !0, this, {
                    missingModuleFor: i
                });
                let o = new s;
                return "function" == typeof o.init && o.init(this, t), o;
            }
            setSortedData() {
                this.getSeriesOrderByLinks().forEach(function(t) {
                    t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);
                });
            }
            getSeriesOrderByLinks() {
                return this.series.concat().sort(function(t, e) {
                    return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;
                });
            }
            orderItems(t, e = 0) {
                let i = this[t], s = this.options[t] = aH(this.options[t]).slice(), o = this.userOptions[t] = this.userOptions[t] ? aH(this.userOptions[t]).slice() : [];
                if (this.hasRendered && (s.splice(e), o.splice(e)), i) for(let t = e, r = i.length; t < r; ++t){
                    let e = i[t];
                    e && (e.index = t, e instanceof rY && (e.name = e.getName()), e.options.isInternal || (s[t] = e.options, o[t] = e.userOptions));
                }
            }
            isInsidePlot(t, e, i = {}) {
                let { inverted: s, plotBox: o, plotLeft: r, plotTop: a, scrollablePlotBox: n } = this, { scrollLeft: h = 0, scrollTop: l = 0 } = i.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {}, d = i.series, c = i.visiblePlotOnly && n || o, p = i.inverted ? e : t, g = i.inverted ? t : e, u = {
                    x: p,
                    y: g,
                    isInsidePlot: !0,
                    options: i
                };
                if (!i.ignoreX) {
                    let t = d && (s && !this.polar ? d.yAxis : d.xAxis) || {
                        pos: r,
                        len: 1 / 0
                    }, e = i.paneCoordinates ? t.pos + p : r + p;
                    e >= Math.max(h + r, t.pos) && e <= Math.min(h + r + c.width, t.pos + t.len) || (u.isInsidePlot = !1);
                }
                if (!i.ignoreY && u.isInsidePlot) {
                    let t = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {
                        pos: a,
                        len: 1 / 0
                    }, e = i.paneCoordinates ? t.pos + g : a + g;
                    e >= Math.max(l + a, t.pos) && e <= Math.min(l + a + c.height, t.pos + t.len) || (u.isInsidePlot = !1);
                }
                return aC(this, "afterIsInsidePlot", u), u.isInsidePlot;
            }
            redraw(t) {
                aC(this, "beforeRedraw");
                let e = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i = this.series, s = this.pointer, o = this.legend, r = this.userOptions.legend, a = this.renderer, n = a.isHidden(), h = [], l, d, c, p = this.isDirtyBox, g = this.isDirtyLegend, u;
                for(a.rootFontSize = a.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(!1), ar(!!this.hasRendered && t, this), n && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;)if (((u = i[c]).options.stacking || u.options.centerInCategory) && (d = !0, u.isDirty)) {
                    l = !0;
                    break;
                }
                if (l) for(c = i.length; c--;)(u = i[c]).options.stacking && (u.isDirty = !0);
                i.forEach(function(t) {
                    t.isDirty && ("point" === t.options.legendType ? ("function" == typeof t.updateTotals && t.updateTotals(), g = !0) : r && (r.labelFormatter || r.labelFormat) && (g = !0)), t.isDirtyData && aC(t, "updatedData");
                }), g && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function(t) {
                    t.updateNames(), t.setScale();
                }), this.getMargins(), e.forEach(function(t) {
                    t.isDirty && (p = !0);
                }), e.forEach(function(t) {
                    let e = t.min + "," + t.max;
                    t.extKey !== e && (t.extKey = e, h.push(function() {
                        aC(t, "afterSetExtremes", aS(t.eventArgs, t.getExtremes())), delete t.eventArgs;
                    })), (p || d) && t.redraw();
                }), p && this.drawChartBox(), aC(this, "predraw"), i.forEach(function(t) {
                    (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;
                }), s && s.reset(!0), a.draw(), aC(this, "redraw"), aC(this, "render"), n && this.temporaryDisplay(!0), h.forEach(function(t) {
                    t.call();
                });
            }
            get(t) {
                let e = this.series;
                function i(e) {
                    return e.id === t || e.options && e.options.id === t;
                }
                let s = aT(this.axes, i) || aT(this.series, i);
                for(let t = 0; !s && t < e.length; t++)s = aT(e[t].points || [], i);
                return s;
            }
            createAxes() {
                let t = this.userOptions;
                for (let e of (aC(this, "createAxes"), [
                    "xAxis",
                    "yAxis"
                ]))for (let i of t[e] = aH(t[e] || {}))new sR(this, i, e);
                aC(this, "afterCreateAxes");
            }
            getSelectedPoints() {
                return this.series.reduce((t, e)=>(e.getPointsCollection().forEach((e)=>{
                        aN(e.selectedStaging, e.selected) && t.push(e);
                    }), t), []);
            }
            getSelectedSeries() {
                return this.series.filter((t)=>t.selected);
            }
            setTitle(t, e, i) {
                this.applyDescription("title", t), this.applyDescription("subtitle", e), this.applyDescription("caption", void 0), this.layOutTitles(i);
            }
            applyDescription(t, e) {
                let i = this, s = this.options[t] = aD(this.options[t], e), o = this[t];
                o && e && (this[t] = o = o.destroy()), s && !o && ((o = this.renderer.text(s.text, 0, 0, s.useHTML).attr({
                    align: s.align,
                    class: "highcharts-" + t,
                    zIndex: s.zIndex || 4
                }).css({
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap"
                }).add()).update = function(e, s) {
                    i.applyDescription(t, e), i.layOutTitles(s);
                }, this.styledMode || o.css(aS("title" === t ? {
                    fontSize: this.options.isStock ? "1em" : "1.2em"
                } : {}, s.style)), o.textPxLength = o.getBBox().width, o.css({
                    whiteSpace: s.style?.whiteSpace
                }), this[t] = o);
            }
            layOutTitles(t = !0) {
                let e = [
                    0,
                    0,
                    0
                ], { options: i, renderer: s, spacingBox: o } = this;
                [
                    "title",
                    "subtitle",
                    "caption"
                ].forEach((t)=>{
                    let i = this[t], r = this.options[t], a = aD(o), n = i?.textPxLength || 0;
                    if (i && r) {
                        aC(this, "layOutTitle", {
                            alignTo: a,
                            key: t,
                            textPxLength: n
                        });
                        let o = s.fontMetrics(i), h = o.b, l = o.h, d = r.verticalAlign || "top", c = "top" === d, p = c && r.minScale || 1, g = "title" === t ? c ? -3 : 0 : c ? e[0] + 2 : 0, u = Math.min(a.width / n, 1), f = Math.max(p, u), m = aD({
                            y: "bottom" === d ? h : g + h
                        }, {
                            align: "title" === t ? u < p ? "left" : "center" : this.title?.alignValue
                        }, r), x = r.width || (u > p ? this.chartWidth : a.width) / f;
                        i.alignValue !== m.align && (i.placed = !1);
                        let y = Math.round(i.css({
                            width: `${x}px`
                        }).getBBox(r.useHTML).height);
                        if (m.height = y, i.align(m, !1, a).attr({
                            align: m.align,
                            scaleX: f,
                            scaleY: f,
                            "transform-origin": `${a.x + n * f * aA(m.align)} ${l}`
                        }), !r.floating) {
                            let t = y * (y < 1.2 * l ? 1 : f);
                            "top" === d ? e[0] = Math.ceil(e[0] + t) : "bottom" === d && (e[2] = Math.ceil(e[2] + t));
                        }
                    }
                }, this), e[0] && "top" === (i.title?.verticalAlign || "top") && (e[0] += i.title?.margin || 0), e[2] && i.caption?.verticalAlign === "bottom" && (e[2] += i.caption?.margin || 0);
                let r = !this.titleOffset || this.titleOffset.join(",") !== e.join(",");
                this.titleOffset = e, aC(this, "afterLayOutTitles"), !this.isDirtyBox && r && (this.isDirtyBox = this.isDirtyLegend = r, this.hasRendered && t && this.isDirtyBox && this.redraw());
            }
            getContainerBox() {
                let t = [].map.call(this.renderTo.children, (t)=>{
                    if (t !== this.container) {
                        let e = t.style.display;
                        return t.style.display = "none", [
                            t,
                            e
                        ];
                    }
                }), e = {
                    width: aP(this.renderTo, "width", !0) || 0,
                    height: aP(this.renderTo, "height", !0) || 0
                };
                return t.filter(Boolean).forEach(([t, e])=>{
                    t.style.display = e;
                }), e;
            }
            getChartSize() {
                let t = this.options.chart, e = t.width, i = t.height, s = this.getContainerBox(), o = s.height <= 1 || !this.renderTo.parentElement?.style.height && "100%" === this.renderTo.style.height;
                this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, aR(i, this.chartWidth) || (o ? 400 : s.height)), this.containerBox = s;
            }
            temporaryDisplay(t) {
                let e = this.renderTo, i;
                if (t) for(; e && e.style;)e.hcOrigStyle && (ay(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (ad.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;
                else for(; e && e.style && (ad.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, ad.body.appendChild(e)), ("none" === aP(e, "display", !1) || e.hcOricDetached) && (e.hcOrigStyle = {
                    display: e.style.display,
                    height: e.style.height,
                    overflow: e.style.overflow
                }, i = {
                    display: "block",
                    overflow: "hidden"
                }, e !== this.renderTo && (i.height = 0), ay(e, i), e.offsetWidth || e.style.setProperty("display", "block", "important")), (e = e.parentNode) !== ad.body););
            }
            setClassName(t) {
                this.container.className = "highcharts-container " + (t || "");
            }
            getContainer() {
                let t;
                let e = this.options, i = e.chart, s = "data-highcharts-chart", o = aF(), r = this.renderTo, a = az(am(r, s));
                aO(a) && al[a] && al[a].hasRendered && al[a].destroy(), am(r, s, this.index), r.innerHTML = tK.emptyHTML, i.skipClone || r.offsetWidth || this.temporaryDisplay(), this.getChartSize();
                let n = this.chartHeight, h = this.chartWidth;
                ay(r, {
                    overflow: "hidden"
                }), this.styledMode || (t = aS({
                    position: "relative",
                    overflow: "hidden",
                    width: h + "px",
                    height: n + "px",
                    textAlign: "left",
                    lineHeight: "normal",
                    zIndex: 0,
                    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                    userSelect: "none",
                    "touch-action": "manipulation",
                    outline: "none",
                    padding: "0px"
                }, i.style || {}));
                let l = ax("div", {
                    id: o
                }, t, r);
                this.container = l, this.getChartSize(), h === this.chartWidth || (h = this.chartWidth, this.styledMode || ay(l, {
                    width: aN(i.style?.width, h + "px")
                })), this.containerBox = this.getContainerBox(), this._cursor = l.style.cursor;
                let d = i.renderer || !ap ? er.getRendererType(i.renderer) : iR;
                if (this.renderer = new d(l, h, n, void 0, i.forExport, e.exporting && e.exporting.allowHTML, this.styledMode), ar(void 0, this), this.setClassName(i.className), this.styledMode) for(let t in e.defs)this.renderer.definition(e.defs[t]);
                else this.renderer.setStyle(i.style);
                this.renderer.chartIndex = this.index, aC(this, "afterGetContainer");
            }
            getMargins(t) {
                let { spacing: e, margin: i, titleOffset: s } = this;
                this.resetMargins(), s[0] && !ab(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !ab(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), aC(this, "getMargins"), t || this.getAxisMargins();
            }
            getAxisMargins() {
                let t = this, e = t.axisOffset = [
                    0,
                    0,
                    0,
                    0
                ], i = t.colorAxis, s = t.margin, o = function(t) {
                    t.forEach(function(t) {
                        t.visible && t.getOffset();
                    });
                };
                t.hasCartesianSeries ? o(t.axes) : i && i.length && o(i), ac.forEach(function(i, o) {
                    ab(s[o]) || (t[i] += e[o]);
                }), t.setChartSize();
            }
            getOptions() {
                return av(this.userOptions, aa);
            }
            reflow(t) {
                let e = this, i = e.containerBox, s = e.getContainerBox();
                delete e.pointer?.chartPosition, !e.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && ($.clearTimeout(e.reflowTimeout), e.reflowTimeout = aX(function() {
                    e.container && e.setSize(void 0, void 0, !1);
                }, t ? 100 : 0)), e.containerBox = s);
            }
            setReflow() {
                let t = this, e = (e)=>{
                    t.options?.chart.reflow && t.hasLoaded && t.reflow(e);
                };
                if ("function" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);
                else {
                    let t = af(ag, "resize", e);
                    af(this, "destroy", t);
                }
            }
            setSize(t, e, i) {
                let s = this, o = s.renderer;
                s.isResizing += 1, ar(i, s);
                let r = o.globalAnimation;
                s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize();
                let { chartWidth: a, chartHeight: n, scrollablePixelsX: h = 0, scrollablePixelsY: l = 0 } = s;
                (s.isDirtyBox || a !== s.oldChartWidth || n !== s.oldChartHeight) && (s.styledMode || (r ? as : ay)(s.container, {
                    width: `${a + h}px`,
                    height: `${n + l}px`
                }, r), s.setChartSize(!0), o.setSize(a, n, r), s.axes.forEach(function(t) {
                    t.isDirty = !0, t.setScale();
                }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(r), s.oldChartHeight = void 0, aC(s, "resize"), setTimeout(()=>{
                    s && aC(s, "endResize");
                }, ao(r).duration)), s.isResizing -= 1;
            }
            setChartSize(t) {
                let e, i, s, o;
                let { chartHeight: r, chartWidth: a, inverted: n, spacing: h, renderer: l } = this, d = this.clipOffset, c = Math[n ? "floor" : "round"];
                this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(a - e - this.marginRight)), this.plotHeight = o = Math.max(0, Math.round(r - i - this.marginBottom)), this.plotSizeX = n ? o : s, this.plotSizeY = n ? s : o, this.spacingBox = l.spacingBox = {
                    x: h[3],
                    y: h[0],
                    width: a - h[3] - h[1],
                    height: r - h[0] - h[2]
                }, this.plotBox = l.plotBox = {
                    x: e,
                    y: i,
                    width: s,
                    height: o
                }, d && (this.clipBox = {
                    x: c(d[3]),
                    y: c(d[0]),
                    width: c(this.plotSizeX - d[1] - d[3]),
                    height: c(this.plotSizeY - d[0] - d[2])
                }), t || (this.axes.forEach(function(t) {
                    t.setAxisSize(), t.setAxisTranslation();
                }), l.alignElements()), aC(this, "afterSetChartSize", {
                    skipAxes: t
                });
            }
            resetMargins() {
                aC(this, "resetMargins");
                let t = this, e = t.options.chart, i = e.plotBorderWidth || 0, s = i / 2;
                [
                    "margin",
                    "spacing"
                ].forEach(function(i) {
                    let s = e[i], o = aE(s) ? s : [
                        s,
                        s,
                        s,
                        s
                    ];
                    [
                        "Top",
                        "Right",
                        "Bottom",
                        "Left"
                    ].forEach(function(s, r) {
                        t[i][r] = aN(e[i + s], o[r]);
                    });
                }), ac.forEach(function(e, i) {
                    t[e] = aN(t.margin[i], t.spacing[i]);
                }), t.axisOffset = [
                    0,
                    0,
                    0,
                    0
                ], t.clipOffset = [
                    s,
                    s,
                    s,
                    s
                ], t.plotBorderWidth = i;
            }
            drawChartBox() {
                let t = this.options.chart, e = this.renderer, i = this.chartWidth, s = this.chartHeight, o = this.styledMode, r = this.plotBGImage, a = t.backgroundColor, n = t.plotBackgroundColor, h = t.plotBackgroundImage, l = this.plotLeft, d = this.plotTop, c = this.plotWidth, p = this.plotHeight, g = this.plotBox, u = this.clipRect, f = this.clipBox, m = this.chartBackground, x = this.plotBackground, y = this.plotBorder, b, v, k, w = "animate";
                m || (this.chartBackground = m = e.rect().addClass("highcharts-background").add(), w = "attr"), o ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + (t.shadow ? 8 : 0), k = {
                    fill: a || "none"
                }, (b || m["stroke-width"]) && (k.stroke = t.borderColor, k["stroke-width"] = b), m.attr(k).shadow(t.shadow)), m[w]({
                    x: v / 2,
                    y: v / 2,
                    width: i - v - b % 2,
                    height: s - v - b % 2,
                    r: t.borderRadius
                }), w = "animate", x || (w = "attr", this.plotBackground = x = e.rect().addClass("highcharts-plot-background").add()), x[w](g), !o && (x.attr({
                    fill: n || "none"
                }).shadow(t.plotShadow), h && (r ? (h !== r.attr("href") && r.attr("href", h), r.animate(g)) : this.plotBGImage = e.image(h, l, d, c, p).add())), u ? u.animate({
                    width: f.width,
                    height: f.height
                }) : this.clipRect = e.clipRect(f), w = "animate", y || (w = "attr", this.plotBorder = y = e.rect().addClass("highcharts-plot-border").attr({
                    zIndex: 1
                }).add()), o || y.attr({
                    stroke: t.plotBorderColor,
                    "stroke-width": t.plotBorderWidth || 0,
                    fill: "none"
                }), y[w](y.crisp({
                    x: l,
                    y: d,
                    width: c,
                    height: p
                }, -y.strokeWidth())), this.isDirtyBox = !1, aC(this, "afterDrawChartBox");
            }
            propFromSeries() {
                let t, e, i;
                let s = this, o = s.options.chart, r = s.options.series;
                [
                    "inverted",
                    "angular",
                    "polar"
                ].forEach(function(a) {
                    for(e = au[o.type], i = o[a] || e && e.prototype[a], t = r && r.length; !i && t--;)(e = au[r[t].type]) && e.prototype[a] && (i = !0);
                    s[a] = i;
                });
            }
            linkSeries(t) {
                let e = this, i = e.series;
                i.forEach(function(t) {
                    t.linkedSeries.length = 0;
                }), i.forEach(function(t) {
                    let { linkedTo: i } = t.options;
                    if (aI(i)) {
                        let s;
                        (s = ":previous" === i ? e.series[t.index - 1] : e.get(i)) && s.linkedParent !== t && (s.linkedSeries.push(t), t.linkedParent = s, s.enabledDataSorting && t.setDataSortingOptions(), t.visible = aN(t.options.visible, s.options.visible, t.visible));
                    }
                }), aC(this, "afterLinkSeries", {
                    isUpdating: t
                });
            }
            renderSeries() {
                this.series.forEach(function(t) {
                    t.translate(), t.render();
                });
            }
            render() {
                let t = this.axes, e = this.colorAxis, i = this.renderer, s = this.options.chart.axisLayoutRuns || 2, o = (t)=>{
                    t.forEach((t)=>{
                        t.visible && t.render();
                    });
                }, r = 0, a = !0, n, h = 0;
                for (let e of (this.setTitle(), aC(this, "beforeMargins"), this.getStacks?.(), this.getMargins(!0), this.setChartSize(), t)){
                    let { options: t } = e, { labels: i } = t;
                    if (this.hasCartesianSeries && e.horiz && e.visible && i.enabled && e.series.length && "colorAxis" !== e.coll && !this.polar) {
                        r = t.tickLength, e.createGroups();
                        let s = new sa(e, 0, "", !0), o = s.createLabel("x", i);
                        if (s.destroy(), o && aN(i.reserveSpace, !aO(t.crossing)) && (r = o.getBBox().height + i.distance + Math.max(t.offset || 0, 0)), r) {
                            o?.destroy();
                            break;
                        }
                    }
                }
                for(this.plotHeight = Math.max(this.plotHeight - r, 0); (a || n || s > 1) && h < s;){
                    let e = this.plotWidth, i = this.plotHeight;
                    for (let e of t)0 === h ? e.setScale() : (e.horiz && a || !e.horiz && n) && e.setTickInterval(!0);
                    0 === h ? this.getAxisMargins() : this.getMargins(), a = e / this.plotWidth > (h ? 1 : 1.1), n = i / this.plotHeight > (h ? 1 : 1.05), h++;
                }
                this.drawChartBox(), this.hasCartesianSeries ? o(t) : e && e.length && o(e), this.seriesGroup || (this.seriesGroup = i.g("series-group").attr({
                    zIndex: 3
                }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;
            }
            addCredits(t) {
                let e = this, i = aD(!0, this.options.credits, t);
                i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
                    i.href && (ag.location.href = i.href);
                }).attr({
                    align: i.position.align,
                    zIndex: 8
                }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function(t) {
                    e.credits = e.credits.destroy(), e.addCredits(t);
                });
            }
            destroy() {
                let t;
                let e = this, i = e.axes, s = e.series, o = e.container, r = o && o.parentNode;
                for(aC(e, "destroy"), e.renderer.forExport ? aw(al, e) : al[e.index] = void 0, k.chartCount--, e.renderTo.removeAttribute("data-highcharts-chart"), aW(e), t = i.length; t--;)i[t] = i[t].destroy();
                for(this.scroller && this.scroller.destroy && this.scroller.destroy(), t = s.length; t--;)s[t] = s[t].destroy();
                [
                    "title",
                    "subtitle",
                    "chartBackground",
                    "plotBackground",
                    "plotBGImage",
                    "plotBorder",
                    "seriesGroup",
                    "clipRect",
                    "credits",
                    "pointer",
                    "rangeSelector",
                    "legend",
                    "resetZoomButton",
                    "tooltip",
                    "renderer"
                ].forEach(function(t) {
                    let i = e[t];
                    i && i.destroy && (e[t] = i.destroy());
                }), o && (o.innerHTML = tK.emptyHTML, aW(o), r && ak(o)), aB(e, function(t, i) {
                    delete e[i];
                });
            }
            firstRender() {
                let t = this, e = t.options;
                t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.createAxes();
                let i = aL(e.series) ? e.series : [];
                e.series = [], i.forEach(function(e) {
                    t.initSeries(e);
                }), t.linkSeries(), t.setSortedData(), aC(t, "beforeRender"), t.render(), t.pointer?.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);
            }
            onload() {
                this.callbacks.concat([
                    this.callback
                ]).forEach(function(t) {
                    t && void 0 !== this.index && t.apply(this, [
                        this
                    ]);
                }, this), aC(this, "load"), aC(this, "render"), ab(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;
            }
            warnIfA11yModuleNotLoaded() {
                let { options: t, title: e } = this;
                !t || this.accessibility || (this.renderer.boxWrapper.attr({
                    role: "img",
                    "aria-label": (e && e.element.textContent || "").replace(/</g, "&lt;")
                }), t.accessibility && !1 === t.accessibility.enabled || aM('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));
            }
            addSeries(t, e, i) {
                let s;
                let o = this;
                return t && (e = aN(e, !0), aC(o, "addSeries", {
                    options: t
                }, function() {
                    s = o.initSeries(t), o.isDirtyLegend = !0, o.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), aC(o, "afterAddSeries", {
                        series: s
                    }), e && o.redraw(i);
                })), s;
            }
            addAxis(t, e, i, s) {
                return this.createAxis(e ? "xAxis" : "yAxis", {
                    axis: t,
                    redraw: i,
                    animation: s
                });
            }
            addColorAxis(t, e, i) {
                return this.createAxis("colorAxis", {
                    axis: t,
                    redraw: e,
                    animation: i
                });
            }
            createAxis(t, e) {
                let i = new sR(this, e.axis, t);
                return aN(e.redraw, !0) && this.redraw(e.animation), i;
            }
            showLoading(t) {
                let e = this, i = e.options, s = i.loading, o = function() {
                    r && ay(r, {
                        left: e.plotLeft + "px",
                        top: e.plotTop + "px",
                        width: e.plotWidth + "px",
                        height: e.plotHeight + "px"
                    });
                }, r = e.loadingDiv, a = e.loadingSpan;
                r || (e.loadingDiv = r = ax("div", {
                    className: "highcharts-loading highcharts-loading-hidden"
                }, null, e.container)), a || (e.loadingSpan = a = ax("span", {
                    className: "highcharts-loading-inner"
                }, null, r), af(e, "redraw", o)), r.className = "highcharts-loading", tK.setElementHTML(a, aN(t, i.lang.loading, "")), e.styledMode || (ay(r, aS(s.style, {
                    zIndex: 10
                })), ay(a, s.labelStyle), e.loadingShown || (ay(r, {
                    opacity: 0,
                    display: ""
                }), as(r, {
                    opacity: s.style.opacity || .5
                }, {
                    duration: s.showDuration || 0
                }))), e.loadingShown = !0, o();
            }
            hideLoading() {
                let t = this.options, e = this.loadingDiv;
                e && (e.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || as(e, {
                    opacity: 0
                }, {
                    duration: t.loading.hideDuration || 100,
                    complete: function() {
                        ay(e, {
                            display: "none"
                        });
                    }
                })), this.loadingShown = !1;
            }
            update(t, e, i, s) {
                let o, r, a;
                let n = this, h = {
                    credits: "addCredits",
                    title: "setTitle",
                    subtitle: "setSubtitle",
                    caption: "setCaption"
                }, l = t.isResponsiveOptions, d = [];
                aC(n, "update", {
                    options: t
                }), l || n.setResponsive(!1, !0), t = av(t, n.options), n.userOptions = aD(n.userOptions, t);
                let c = t.chart;
                c && (aD(!0, n.options.chart, c), this.setZoomOptions(), "className" in c && n.setClassName(c.className), ("inverted" in c || "polar" in c || "type" in c) && (n.propFromSeries(), o = !0), "alignTicks" in c && (o = !0), "events" in c && ah(this, c), aB(c, function(t, e) {
                    -1 !== n.propsRequireUpdateSeries.indexOf("chart." + e) && (r = !0), -1 !== n.propsRequireDirtyBox.indexOf(e) && (n.isDirtyBox = !0), -1 === n.propsRequireReflow.indexOf(e) || (n.isDirtyBox = !0, l || (a = !0));
                }), !n.styledMode && c.style && n.renderer.setStyle(n.options.chart.style || {})), !n.styledMode && t.colors && (this.options.colors = t.colors), aB(t, function(e, i) {
                    n[i] && "function" == typeof n[i].update ? n[i].update(e, !1) : "function" == typeof n[h[i]] ? n[h[i]](e) : "colors" !== i && -1 === n.collectionsWithUpdate.indexOf(i) && aD(!0, n.options[i], t[i]), "chart" !== i && -1 !== n.propsRequireUpdateSeries.indexOf(i) && (r = !0);
                }), this.collectionsWithUpdate.forEach(function(e) {
                    t[e] && (aH(t[e]).forEach(function(t, s) {
                        let o;
                        let r = ab(t.id);
                        r && (o = n.get(t.id)), !o && n[e] && (o = n[e][aN(t.index, s)]) && (r && ab(o.options.id) || o.options.isInternal) && (o = void 0), o && o.coll === e && (o.update(t, !1), i && (o.touched = !0)), !o && i && n.collectionsWithInit[e] && (n.collectionsWithInit[e][0].apply(n, [
                            t
                        ].concat(n.collectionsWithInit[e][1] || []).concat([
                            !1
                        ])).touched = !0);
                    }), i && n[e].forEach(function(t) {
                        t.touched || t.options.isInternal ? delete t.touched : d.push(t);
                    }));
                }), d.forEach(function(t) {
                    t.chart && t.remove && t.remove(!1);
                }), o && n.axes.forEach(function(t) {
                    t.update({}, !1);
                }), r && n.getSeriesOrderByLinks().forEach(function(t) {
                    t.chart && t.update({}, !1);
                }, this);
                let p = c && c.width, g = c && (aI(c.height) ? aR(c.height, p || n.chartWidth) : c.height);
                a || aO(p) && p !== n.chartWidth || aO(g) && g !== n.chartHeight ? n.setSize(p, g, s) : aN(e, !0) && n.redraw(s), aC(n, "afterUpdate", {
                    options: t,
                    redraw: e,
                    animation: s
                });
            }
            setSubtitle(t, e) {
                this.applyDescription("subtitle", t), this.layOutTitles(e);
            }
            setCaption(t, e) {
                this.applyDescription("caption", t), this.layOutTitles(e);
            }
            showResetZoom() {
                let t = this, e = aa.lang, i = t.zooming.resetButton, s = i.theme, o = "chart" === i.relativeTo || "spacingBox" === i.relativeTo ? null : "plotBox";
                function r() {
                    t.zoomOut();
                }
                aC(this, "beforeShowResetZoom", null, function() {
                    t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, r, s).attr({
                        align: i.position.align,
                        title: e.resetZoomTitle
                    }).addClass("highcharts-reset-zoom").add().align(i.position, !1, o);
                }), aC(this, "afterShowResetZoom");
            }
            zoomOut() {
                aC(this, "selection", {
                    resetSelection: !0
                }, ()=>this.transform({
                        reset: !0,
                        trigger: "zoom"
                    }));
            }
            pan(t, e) {
                let i = this, s = "object" == typeof e ? e : {
                    enabled: e,
                    type: "x"
                }, o = s.type, r = o && i[({
                    x: "xAxis",
                    xy: "axes",
                    y: "yAxis"
                })[o]].filter((t)=>t.options.panningEnabled && !t.options.isInternal), a = i.options.chart;
                a?.panning && (a.panning = s), aC(this, "pan", {
                    originalEvent: t
                }, ()=>{
                    i.transform({
                        axes: r,
                        event: t,
                        to: {
                            x: t.chartX - (i.mouseDownX || 0),
                            y: t.chartY - (i.mouseDownY || 0)
                        },
                        trigger: "pan"
                    }), ay(i.container, {
                        cursor: "move"
                    });
                });
            }
            transform(t) {
                let { axes: e = this.axes, event: i, from: s = {}, reset: o, selection: r, to: a = {}, trigger: n } = t, { inverted: h, time: l } = this, d = !1, c, p;
                for (let t of (this.hoverPoints?.forEach((t)=>t.setState()), e)){
                    let { horiz: e, len: g, minPointOffset: u = 0, options: f, reversed: m } = t, x = e ? "width" : "height", y = e ? "x" : "y", b = aN(a[x], t.len), v = aN(s[x], t.len), k = 10 > Math.abs(b) ? 1 : b / v, w = (s[y] || 0) + v / 2 - t.pos, M = w - ((a[y] ?? t.pos) + b / 2 - t.pos) / k, S = m && !h || !m && h ? -1 : 1;
                    if (!o && (w < 0 || w > t.len)) continue;
                    let T = t.toValue(M, !0) + (r || t.isOrdinal ? 0 : u * S), C = t.toValue(M + g / k, !0) - (r || t.isOrdinal ? 0 : u * S || 0), A = t.allExtremes;
                    if (T > C && ([T, C] = [
                        C,
                        T
                    ]), 1 === k && !o && "yAxis" === t.coll && !A) {
                        for (let e of t.series){
                            let t = e.getExtremes(e.getProcessedData(!0).modified.getColumn("y") || [], !0);
                            A ?? (A = {
                                dataMin: Number.MAX_VALUE,
                                dataMax: -Number.MAX_VALUE
                            }), aO(t.dataMin) && aO(t.dataMax) && (A.dataMin = Math.min(t.dataMin, A.dataMin), A.dataMax = Math.max(t.dataMax, A.dataMax));
                        }
                        t.allExtremes = A;
                    }
                    let { dataMin: P, dataMax: L, min: O, max: E } = aS(t.getExtremes(), A || {}), I = l.parse(f.min), D = l.parse(f.max), B = P ?? I, N = L ?? D, z = C - T, R = t.categories ? 0 : Math.min(z, N - B), W = B - R * (ab(I) ? 0 : f.minPadding), H = N + R * (ab(D) ? 0 : f.maxPadding), X = t.allowZoomOutside || 1 === k || "zoom" !== n && k > 1, F = Math.min(I ?? W, W, X ? O : W), G = Math.max(D ?? H, H, X ? E : H);
                    (!t.isOrdinal || t.options.overscroll || 1 !== k || o) && (T < F && (T = F, k >= 1 && (C = T + z)), C > G && (C = G, k >= 1 && (T = C - z)), (o || t.series.length && (T !== O || C !== E) && T >= F && C <= G) && (r ? r[t.coll].push({
                        axis: t,
                        min: T,
                        max: C
                    }) : (t.isPanning = "zoom" !== n, t.isPanning && (p = !0), t.setExtremes(o ? void 0 : T, o ? void 0 : C, !1, !1, {
                        move: M,
                        trigger: n,
                        scale: k
                    }), !o && (T > F || C < G) && "mousewheel" !== n && (c = !0)), d = !0), i && (this[e ? "mouseDownX" : "mouseDownY"] = i[e ? "chartX" : "chartY"]));
                }
                return d && (r ? aC(this, "selection", r, ()=>{
                    delete t.selection, t.trigger = "zoom", this.transform(t);
                }) : (!c || p || this.resetZoomButton ? !c && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw("zoom" === n && (this.options.chart.animation ?? this.pointCount < 100)))), d;
            }
        }
        aS(aG.prototype, {
            callbacks: [],
            collectionsWithInit: {
                xAxis: [
                    aG.prototype.addAxis,
                    [
                        !0
                    ]
                ],
                yAxis: [
                    aG.prototype.addAxis,
                    [
                        !1
                    ]
                ],
                series: [
                    aG.prototype.addSeries
                ]
            },
            collectionsWithUpdate: [
                "xAxis",
                "yAxis",
                "series"
            ],
            propsRequireDirtyBox: [
                "backgroundColor",
                "borderColor",
                "borderWidth",
                "borderRadius",
                "plotBackgroundColor",
                "plotBackgroundImage",
                "plotBorderColor",
                "plotBorderWidth",
                "plotShadow",
                "shadow"
            ],
            propsRequireReflow: [
                "margin",
                "marginTop",
                "marginRight",
                "marginBottom",
                "marginLeft",
                "spacing",
                "spacingTop",
                "spacingRight",
                "spacingBottom",
                "spacingLeft"
            ],
            propsRequireUpdateSeries: [
                "chart.inverted",
                "chart.polar",
                "chart.ignoreHiddenSeries",
                "chart.type",
                "colors",
                "plotOptions",
                "time",
                "tooltip"
            ]
        });
        let { stop: aY } = tR, { composed: aj } = k, { addEvent: aU, createElement: a$, css: aV, defined: a_, erase: aq, merge: aZ, pushUnique: aK } = $;
        function aJ() {
            let t = this.scrollablePlotArea;
            (this.scrollablePixelsX || this.scrollablePixelsY) && !t && (this.scrollablePlotArea = t = new a0(this)), t?.applyFixed();
        }
        function aQ() {
            this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = !0);
        }
        class a0 {
            static compose(t, e, i) {
                aK(aj, this.compose) && (aU(t, "afterInit", aQ), aU(e, "afterSetChartSize", (t)=>this.afterSetSize(t.target, t)), aU(e, "render", aJ), aU(i, "show", aQ));
            }
            static afterSetSize(t, e) {
                let i, s, o;
                let { minWidth: r, minHeight: a } = t.options.chart.scrollablePlotArea || {}, { clipBox: n, plotBox: h, inverted: l, renderer: d } = t;
                if (!d.forExport && (r ? (t.scrollablePixelsX = i = Math.max(0, r - t.chartWidth), i && (t.scrollablePlotBox = aZ(t.plotBox), h.width = t.plotWidth += i, n[l ? "height" : "width"] += i, o = !0)) : a && (t.scrollablePixelsY = s = Math.max(0, a - t.chartHeight), a_(s) && (t.scrollablePlotBox = aZ(t.plotBox), h.height = t.plotHeight += s, n[l ? "width" : "height"] += s, o = !1)), a_(o) && !e.skipAxes)) for (let e of t.axes)(e.horiz === o || t.hasParallelCoordinates && "yAxis" === e.coll) && (e.setAxisSize(), e.setAxisTranslation());
            }
            constructor(t){
                let e;
                let i = t.options.chart, s = er.getRendererType(), o = i.scrollablePlotArea || {}, r = this.moveFixedElements.bind(this), a = {
                    WebkitOverflowScrolling: "touch",
                    overflowX: "hidden",
                    overflowY: "hidden"
                };
                t.scrollablePixelsX && (a.overflowX = "auto"), t.scrollablePixelsY && (a.overflowY = "auto"), this.chart = t;
                let n = this.parentDiv = a$("div", {
                    className: "highcharts-scrolling-parent"
                }, {
                    position: "relative"
                }, t.renderTo), h = this.scrollingContainer = a$("div", {
                    className: "highcharts-scrolling"
                }, a, n), l = this.innerContainer = a$("div", {
                    className: "highcharts-inner-container"
                }, void 0, h), d = this.fixedDiv = a$("div", {
                    className: "highcharts-fixed"
                }, {
                    position: "absolute",
                    overflow: "hidden",
                    pointerEvents: "none",
                    zIndex: (i.style?.zIndex || 0) + 2,
                    top: 0
                }, void 0, !0), c = this.fixedRenderer = new s(d, t.chartWidth, t.chartHeight, i.style);
                this.mask = c.path().attr({
                    fill: i.backgroundColor || "#fff",
                    "fill-opacity": o.opacity ?? .85,
                    zIndex: -1
                }).addClass("highcharts-scrollable-mask").add(), h.parentNode.insertBefore(d, h), aV(t.renderTo, {
                    overflow: "visible"
                }), aU(t, "afterShowResetZoom", r), aU(t, "afterApplyDrilldown", r), aU(t, "afterLayOutTitles", r), aU(h, "scroll", ()=>{
                    let { pointer: i, hoverPoint: s } = t;
                    i && (delete i.chartPosition, s && (e = s), i.runPointActions(void 0, e, !0));
                }), l.appendChild(t.container);
            }
            applyFixed() {
                let { chart: t, fixedRenderer: e, isDirty: i, scrollingContainer: s } = this, { axisOffset: o, chartWidth: r, chartHeight: a, container: n, plotHeight: h, plotLeft: l, plotTop: d, plotWidth: c, scrollablePixelsX: p = 0, scrollablePixelsY: g = 0 } = t, { scrollPositionX: u = 0, scrollPositionY: f = 0 } = t.options.chart.scrollablePlotArea || {}, m = r + p, x = a + g;
                e.setSize(r, a), (i ?? !0) && (this.isDirty = !1, this.moveFixedElements()), aY(t.container), aV(n, {
                    width: `${m}px`,
                    height: `${x}px`
                }), t.renderer.boxWrapper.attr({
                    width: m,
                    height: x,
                    viewBox: [
                        0,
                        0,
                        m,
                        x
                    ].join(" ")
                }), t.chartBackground?.attr({
                    width: m,
                    height: x
                }), aV(s, {
                    width: `${r}px`,
                    height: `${a}px`
                }), a_(i) || (s.scrollLeft = p * u, s.scrollTop = g * f);
                let y = d - o[0] - 1, b = l - o[3] - 1, v = d + h + o[2] + 1, k = l + c + o[1] + 1, w = l + c - p, M = d + h - g, S = [
                    [
                        "M",
                        0,
                        0
                    ]
                ];
                p ? S = [
                    [
                        "M",
                        0,
                        y
                    ],
                    [
                        "L",
                        l - 1,
                        y
                    ],
                    [
                        "L",
                        l - 1,
                        v
                    ],
                    [
                        "L",
                        0,
                        v
                    ],
                    [
                        "Z"
                    ],
                    [
                        "M",
                        w,
                        y
                    ],
                    [
                        "L",
                        r,
                        y
                    ],
                    [
                        "L",
                        r,
                        v
                    ],
                    [
                        "L",
                        w,
                        v
                    ],
                    [
                        "Z"
                    ]
                ] : g && (S = [
                    [
                        "M",
                        b,
                        0
                    ],
                    [
                        "L",
                        b,
                        d - 1
                    ],
                    [
                        "L",
                        k,
                        d - 1
                    ],
                    [
                        "L",
                        k,
                        0
                    ],
                    [
                        "Z"
                    ],
                    [
                        "M",
                        b,
                        M
                    ],
                    [
                        "L",
                        b,
                        a
                    ],
                    [
                        "L",
                        k,
                        a
                    ],
                    [
                        "L",
                        k,
                        M
                    ],
                    [
                        "Z"
                    ]
                ]), "adjustHeight" !== t.redrawTrigger && this.mask.attr({
                    d: S
                });
            }
            moveFixedElements() {
                let t;
                let { container: e, inverted: i, scrollablePixelsX: s, scrollablePixelsY: o } = this.chart, r = this.fixedRenderer, a = a0.fixedSelectors;
                if (s && !i ? t = ".highcharts-yaxis" : s && i ? t = ".highcharts-xaxis" : o && !i ? t = ".highcharts-xaxis" : o && i && (t = ".highcharts-yaxis"), t && !(this.chart.hasParallelCoordinates && ".highcharts-yaxis" === t)) for (let e of [
                    `${t}:not(.highcharts-radial-axis)`,
                    `${t}-labels:not(.highcharts-radial-axis-labels)`
                ])aK(a, e);
                else for (let t of [
                    ".highcharts-xaxis",
                    ".highcharts-yaxis"
                ])for (let e of [
                    `${t}:not(.highcharts-radial-axis)`,
                    `${t}-labels:not(.highcharts-radial-axis-labels)`
                ])aq(a, e);
                for (let t of a)[].forEach.call(e.querySelectorAll(t), (t)=>{
                    (t.namespaceURI === r.SVG_NS ? r.box : r.box.parentNode).appendChild(t), t.style.pointerEvents = "auto";
                });
            }
        }
        a0.fixedSelectors = [
            ".highcharts-breadcrumbs-group",
            ".highcharts-contextbutton",
            ".highcharts-caption",
            ".highcharts-credits",
            ".highcharts-drillup-button",
            ".highcharts-legend",
            ".highcharts-legend-checkbox",
            ".highcharts-navigator-series",
            ".highcharts-navigator-xaxis",
            ".highcharts-navigator-yaxis",
            ".highcharts-navigator",
            ".highcharts-range-selector-group",
            ".highcharts-reset-zoom",
            ".highcharts-scrollbar",
            ".highcharts-subtitle",
            ".highcharts-title"
        ];
        let { format: a1 } = eo, { series: a2 } = rd, { destroyObjectProperties: a3, fireEvent: a5, getAlignFactor: a6, isNumber: a9, pick: a4 } = $, a8 = class {
            constructor(t, e, i, s, o){
                let r = t.chart.inverted, a = t.reversed;
                this.axis = t;
                let n = this.isNegative = !!i != !!a;
                this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = o, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {
                    align: e.align || (r ? n ? "left" : "right" : "center"),
                    verticalAlign: e.verticalAlign || (r ? "middle" : n ? "bottom" : "top"),
                    y: e.y,
                    x: e.x
                }, this.textAlign = e.textAlign || (r ? n ? "right" : "left" : "center");
            }
            destroy() {
                a3(this, this.axis);
            }
            render(t) {
                let e = this.axis.chart, i = this.options, s = i.format, o = s ? a1(s, this, e) : i.formatter.call(this);
                if (this.label) this.label.attr({
                    text: o,
                    visibility: "hidden"
                });
                else {
                    this.label = e.renderer.label(o, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, "stack-labels");
                    let s = {
                        r: i.borderRadius || 0,
                        text: o,
                        padding: a4(i.padding, 5),
                        visibility: "hidden"
                    };
                    e.styledMode || (s.fill = i.backgroundColor, s.stroke = i.borderColor, s["stroke-width"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(s), this.label.added || this.label.add(t);
                }
                this.label.labelrank = e.plotSizeY, a5(this, "afterRender");
            }
            setOffset(t, e, i, s, o, r) {
                let { alignOptions: a, axis: n, label: h, options: l, textAlign: d } = this, c = n.chart, p = this.getStackBox({
                    xOffset: t,
                    width: e,
                    boxBottom: i,
                    boxTop: s,
                    defaultX: o,
                    xAxis: r
                }), { verticalAlign: g } = a;
                if (h && p) {
                    let t = h.getBBox(void 0, 0), e = h.padding, i = "justify" === a4(l.overflow, "justify"), s;
                    a.x = l.x || 0, a.y = l.y || 0;
                    let { x: o, y: r } = this.adjustStackPosition({
                        labelBox: t,
                        verticalAlign: g,
                        textAlign: d
                    });
                    p.x -= o, p.y -= r, h.align(a, !1, p), (s = c.isInsidePlot(h.alignAttr.x + a.x + o, h.alignAttr.y + a.y + r)) || (i = !1), i && a2.prototype.justifyDataLabel.call(n, h, a, h.alignAttr, t, p), h.attr({
                        x: h.alignAttr.x,
                        y: h.alignAttr.y,
                        rotation: l.rotation,
                        rotationOriginX: t.width * a6(l.textAlign || "center"),
                        rotationOriginY: t.height / 2
                    }), a4(!i && l.crop, !0) && (s = a9(h.x) && a9(h.y) && c.isInsidePlot(h.x - e + (h.width || 0), h.y) && c.isInsidePlot(h.x + e, h.y)), h[s ? "show" : "hide"]();
                }
                a5(this, "afterSetOffset", {
                    xOffset: t,
                    width: e
                });
            }
            adjustStackPosition({ labelBox: t, verticalAlign: e, textAlign: i }) {
                return {
                    x: t.width / 2 + t.width / 2 * (2 * a6(i) - 1),
                    y: t.height / 2 * 2 * (1 - a6(e))
                };
            }
            getStackBox(t) {
                let e = this.axis, i = e.chart, { boxTop: s, defaultX: o, xOffset: r, width: a, boxBottom: n } = t, h = e.stacking.usePercentage ? 100 : a4(s, this.total, 0), l = e.toPixels(h), d = t.xAxis || i.xAxis[0], c = a4(o, d.translate(this.x)) + r, p = Math.abs(l - e.toPixels(n || a9(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0)), g = i.inverted, u = this.isNegative;
                return g ? {
                    x: (u ? l : l - p) - i.plotLeft,
                    y: d.height - c - a + d.top - i.plotTop,
                    width: p,
                    height: a
                } : {
                    x: c + d.transB - i.plotLeft,
                    y: (u ? l - p : l) - i.plotTop,
                    width: a,
                    height: p
                };
            }
        }, { getDeferredAnimation: a7 } = tR, { series: { prototype: nt } } = rd, { addEvent: ne, correctFloat: ni, defined: ns, destroyObjectProperties: no, fireEvent: nr, isNumber: na, objectEach: nn, pick: nh } = $;
        function nl() {
            let t = this.inverted;
            this.axes.forEach((t)=>{
                t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);
            }), this.series.forEach((e)=>{
                let i = e.xAxis && e.xAxis.options || {};
                e.options.stacking && e.reserveSpace() && (e.stackKey = [
                    e.type,
                    nh(e.options.stack, ""),
                    t ? i.top : i.left,
                    t ? i.height : i.width
                ].join(","));
            });
        }
        function nd() {
            let t = this.stacking;
            if (t) {
                let e = t.stacks;
                nn(e, (t, i)=>{
                    no(t), delete e[i];
                }), t.stackTotalGroup?.destroy();
            }
        }
        function nc() {
            this.stacking || (this.stacking = new nx(this));
        }
        function np(t, e, i, s) {
            return !ns(t) || t.x !== e || s && t.stackKey !== s ? t = {
                x: e,
                index: 0,
                key: s,
                stackKey: s
            } : t.index++, t.key = [
                i,
                e,
                t.index
            ].join(","), t;
        }
        function ng() {
            let t;
            let e = this, i = e.yAxis, s = e.stackKey || "", o = i.stacking.stacks, r = e.getColumn("x", !0), a = e.options.stacking, n = e[a + "Stacker"];
            n && [
                s,
                "-" + s
            ].forEach((i)=>{
                let s = r.length, a, h, l;
                for(; s--;)a = r[s], t = e.getStackIndicator(t, a, e.index, i), h = o[i]?.[a], (l = h?.points[t.key || ""]) && n.call(e, l, h, s);
            });
        }
        function nu(t, e, i) {
            let s = e.total ? 100 / e.total : 0;
            t[0] = ni(t[0] * s), t[1] = ni(t[1] * s), this.stackedYData[i] = t[1];
        }
        function nf(t) {
            (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && this.chart.series.length > 1 ? nt.setStackedPoints.call(this, t, "group") : t.stacking.resetStacks());
        }
        function nm(t, e) {
            let i, s, o, r, a, n, h;
            let l = e || this.options.stacking;
            if (!l || !this.reserveSpace() || (({
                group: "xAxis"
            })[l] || "yAxis") !== t.coll) return;
            let d = this.getColumn("x", !0), c = this.getColumn(this.pointValKey || "y", !0), p = [], g = c.length, u = this.options, f = u.threshold || 0, m = u.startFromThreshold ? f : 0, x = u.stack, y = e ? `${this.type},${l}` : this.stackKey || "", b = "-" + y, v = this.negStacks, k = t.stacking, w = k.stacks, M = k.oldStacks;
            for(k.stacksTouched += 1, h = 0; h < g; h++){
                let e = d[h] || 0, g = c[h], u = na(g) && g || 0;
                n = (i = this.getStackIndicator(i, e, this.index)).key || "", w[a = (s = v && u < (m ? 0 : f)) ? b : y] || (w[a] = {}), w[a][e] || (M[a]?.[e] ? (w[a][e] = M[a][e], w[a][e].total = null) : w[a][e] = new a8(t, t.options.stackLabels, !!s, e, x)), o = w[a][e], null !== g ? (o.points[n] = o.points[this.index] = [
                    nh(o.cumulative, m)
                ], ns(o.cumulative) || (o.base = n), o.touched = k.stacksTouched, i.index > 0 && !1 === this.singleStacks && (o.points[n][0] = o.points[this.index + "," + e + ",0"][0])) : (delete o.points[n], delete o.points[this.index]);
                let S = o.total || 0;
                "percent" === l ? (r = s ? y : b, S = v && w[r]?.[e] ? (r = w[r][e]).total = Math.max(r.total || 0, S) + Math.abs(u) : ni(S + Math.abs(u))) : "group" === l ? na(g) && S++ : S = ni(S + u), "group" === l ? o.cumulative = (S || 1) - 1 : o.cumulative = ni(nh(o.cumulative, m) + u), o.total = S, null !== g && (o.points[n].push(o.cumulative), p[h] = o.cumulative, o.hasValidPoints = !0);
            }
            "percent" === l && (k.usePercentage = !0), "group" !== l && (this.stackedYData = p), k.oldStacks = {};
        }
        class nx {
            constructor(t){
                this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;
            }
            buildStacks() {
                let t, e;
                let i = this.axis, s = i.series, o = "xAxis" === i.coll, r = i.options.reversedStacks, a = s.length;
                for(this.resetStacks(), this.usePercentage = !1, e = a; e--;)t = s[r ? e : a - e - 1], o && t.setGroupedPoints(i), t.setStackedPoints(i);
                if (!o) for(e = 0; e < a; e++)s[e].modifyStacks();
                nr(i, "afterBuildStacks");
            }
            cleanStacks() {
                this.oldStacks && (this.stacks = this.oldStacks, nn(this.stacks, (t)=>{
                    nn(t, (t)=>{
                        t.cumulative = t.total;
                    });
                }));
            }
            resetStacks() {
                nn(this.stacks, (t)=>{
                    nn(t, (e, i)=>{
                        na(e.touched) && e.touched < this.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);
                    });
                });
            }
            renderStackTotals() {
                let t = this.axis, e = t.chart, i = e.renderer, s = this.stacks, o = a7(e, t.options.stackLabels?.animation || !1), r = this.stackTotalGroup = this.stackTotalGroup || i.g("stack-labels").attr({
                    zIndex: 6,
                    opacity: 0
                }).add();
                r.translate(e.plotLeft, e.plotTop), nn(s, (t)=>{
                    nn(t, (t)=>{
                        t.render(r);
                    });
                }), r.animate({
                    opacity: 1
                }, o);
            }
        }
        (p || (p = {})).compose = function(t, e, i) {
            let s = e.prototype, o = i.prototype;
            s.getStacks || (ne(t, "init", nc), ne(t, "destroy", nd), s.getStacks = nl, o.getStackIndicator = np, o.modifyStacks = ng, o.percentStacker = nu, o.setGroupedPoints = nf, o.setStackedPoints = nm);
        };
        let ny = p, { defined: nb, merge: nv, isObject: nk } = $;
        class nw extends rY {
            drawGraph() {
                let t = this.options, e = (this.gappedPath || this.getGraphPath).call(this), i = this.chart.styledMode;
                [
                    this,
                    ...this.zones
                ].forEach((s, o)=>{
                    let r, a = s.graph, n = a ? "animate" : "attr", h = s.dashStyle || t.dashStyle;
                    a ? (a.endX = this.preventGraphAnimation ? null : e.xMap, a.animate({
                        d: e
                    })) : e.length && (s.graph = a = this.chart.renderer.path(e).addClass("highcharts-graph" + (o ? ` highcharts-zone-graph-${o - 1} ` : " ") + (o && s.className || "")).attr({
                        zIndex: 1
                    }).add(this.group)), a && !i && (r = {
                        stroke: !o && t.lineColor || s.color || this.color || "#cccccc",
                        "stroke-width": t.lineWidth || 0,
                        fill: this.fillGraph && this.color || "none"
                    }, h ? r.dashstyle = h : "square" !== t.linecap && (r["stroke-linecap"] = r["stroke-linejoin"] = "round"), a[n](r).shadow(t.shadow && nv({
                        filterUnits: "userSpaceOnUse"
                    }, nk(t.shadow) ? t.shadow : {}))), a && (a.startX = e.xMap, a.isArea = e.isArea);
                });
            }
            getGraphPath(t, e, i) {
                let s = this, o = s.options, r = [], a = [], n, h = o.step, l = (t = t || s.points).reversed;
                return l && t.reverse(), (h = ({
                    right: 1,
                    center: 2
                })[h] || h && 3) && l && (h = 4 - h), (t = this.getValidPoints(t, !1, !(o.connectNulls && !e && !i))).forEach(function(l, d) {
                    let c;
                    let p = l.plotX, g = l.plotY, u = t[d - 1], f = l.isNull || "number" != typeof g;
                    (l.leftCliff || u && u.rightCliff) && !i && (n = !0), f && !nb(e) && d > 0 ? n = !o.connectNulls : f && !e ? n = !0 : (0 === d || n ? c = [
                        [
                            "M",
                            l.plotX,
                            l.plotY
                        ]
                    ] : s.getPointSpline ? c = [
                        s.getPointSpline(t, l, d)
                    ] : h ? (c = 1 === h ? [
                        [
                            "L",
                            u.plotX,
                            g
                        ]
                    ] : 2 === h ? [
                        [
                            "L",
                            (u.plotX + p) / 2,
                            u.plotY
                        ],
                        [
                            "L",
                            (u.plotX + p) / 2,
                            g
                        ]
                    ] : [
                        [
                            "L",
                            p,
                            u.plotY
                        ]
                    ]).push([
                        "L",
                        p,
                        g
                    ]) : c = [
                        [
                            "L",
                            p,
                            g
                        ]
                    ], a.push(l.x), h && (a.push(l.x), 2 === h && a.push(l.x)), r.push.apply(r, c), n = !1);
                }), r.xMap = a, s.graphPath = r, r;
            }
        }
        nw.defaultOptions = nv(rY.defaultOptions, {
            legendSymbol: "lineMarker"
        }), rd.registerSeriesType("line", nw);
        let { seriesTypes: { line: nM } } = rd, { extend: nS, merge: nT, objectEach: nC, pick: nA } = $;
        class nP extends nM {
            drawGraph() {
                this.areaPath = [], super.drawGraph.apply(this);
                let { areaPath: t, options: e } = this;
                [
                    this,
                    ...this.zones
                ].forEach((i, s)=>{
                    let o = {}, r = i.fillColor || e.fillColor, a = i.area, n = a ? "animate" : "attr";
                    a ? (a.endX = this.preventGraphAnimation ? null : t.xMap, a.animate({
                        d: t
                    })) : (o.zIndex = 0, (a = i.area = this.chart.renderer.path(t).addClass("highcharts-area" + (s ? ` highcharts-zone-area-${s - 1} ` : " ") + (s && i.className || "")).add(this.group)).isArea = !0), this.chart.styledMode || (o.fill = r || i.color || this.color, o["fill-opacity"] = r ? 1 : e.fillOpacity ?? .75, a.css({
                        pointerEvents: this.stickyTracking ? "none" : "auto"
                    })), a[n](o), a.startX = t.xMap, a.shiftUnit = e.step ? 2 : 1;
                });
            }
            getGraphPath(t) {
                let e, i, s;
                let o = nM.prototype.getGraphPath, r = this.options, a = r.stacking, n = this.yAxis, h = [], l = [], d = this.index, c = n.stacking.stacks[this.stackKey], p = r.threshold, g = Math.round(n.getThreshold(r.threshold)), u = nA(r.connectNulls, "percent" === a), f = function(i, s, o) {
                    let r = t[i], u = a && c[r.x].points[d], f = r[o + "Null"] || 0, m = r[o + "Cliff"] || 0, x, y, b = !0;
                    m || f ? (x = (f ? u[0] : u[1]) + m, y = u[0] + m, b = !!f) : !a && t[s] && t[s].isNull && (x = y = p), void 0 !== x && (l.push({
                        plotX: e,
                        plotY: null === x ? g : n.getThreshold(x),
                        isNull: b,
                        isCliff: !0
                    }), h.push({
                        plotX: e,
                        plotY: null === y ? g : n.getThreshold(y),
                        doCurve: !1
                    }));
                };
                t = t || this.points, a && (t = this.getStackPoints(t));
                for(let o = 0, r = t.length; o < r; ++o)a || (t[o].leftCliff = t[o].rightCliff = t[o].leftNull = t[o].rightNull = void 0), i = t[o].isNull, e = nA(t[o].rectPlotX, t[o].plotX), s = a ? nA(t[o].yBottom, g) : g, i && !u || (u || f(o, o - 1, "left"), i && !a && u || (l.push(t[o]), h.push({
                    x: o,
                    plotX: e,
                    plotY: s
                })), u || f(o, o + 1, "right"));
                let m = o.call(this, l, !0, !0);
                h.reversed = !0;
                let x = o.call(this, h, !0, !0), y = x[0];
                y && "M" === y[0] && (x[0] = [
                    "L",
                    y[1],
                    y[2]
                ]);
                let b = m.concat(x);
                b.length && b.push([
                    "Z"
                ]);
                let v = o.call(this, l, !1, u);
                return this.chart.series.length > 1 && a && l.some((t)=>t.isCliff) && (b.hasStackedCliffs = v.hasStackedCliffs = !0), b.xMap = m.xMap, this.areaPath = b, v;
            }
            getStackPoints(t) {
                let e = this, i = [], s = [], o = this.xAxis, r = this.yAxis, a = r.stacking.stacks[this.stackKey], n = {}, h = r.series, l = h.length, d = r.options.reversedStacks ? 1 : -1, c = h.indexOf(e);
                if (t = t || this.points, this.options.stacking) {
                    for(let e = 0; e < t.length; e++)t[e].leftNull = t[e].rightNull = void 0, n[t[e].x] = t[e];
                    nC(a, function(t, e) {
                        null !== t.total && s.push(e);
                    }), s.sort(function(t, e) {
                        return t - e;
                    });
                    let p = h.map((t)=>t.visible);
                    s.forEach(function(t, g) {
                        let u = 0, f, m;
                        if (n[t] && !n[t].isNull) i.push(n[t]), [
                            -1,
                            1
                        ].forEach(function(i) {
                            let o = 1 === i ? "rightNull" : "leftNull", r = a[s[g + i]], u = 0;
                            if (r) {
                                let i = c;
                                for(; i >= 0 && i < l;){
                                    let s = h[i].index;
                                    !(f = r.points[s]) && (s === e.index ? n[t][o] = !0 : p[i] && (m = a[t].points[s]) && (u -= m[1] - m[0])), i += d;
                                }
                            }
                            n[t][1 === i ? "rightCliff" : "leftCliff"] = u;
                        });
                        else {
                            let e = c;
                            for(; e >= 0 && e < l;){
                                let i = h[e].index;
                                if (f = a[t].points[i]) {
                                    u = f[1];
                                    break;
                                }
                                e += d;
                            }
                            u = nA(u, 0), u = r.translate(u, 0, 1, 0, 1), i.push({
                                isNull: !0,
                                plotX: o.translate(t, 0, 0, 0, 1),
                                x: t,
                                plotY: u,
                                yBottom: u
                            });
                        }
                    });
                }
                return i;
            }
        }
        nP.defaultOptions = nT(nM.defaultOptions, {
            threshold: 0,
            legendSymbol: "areaMarker"
        }), nS(nP.prototype, {
            singleStacks: !1
        }), rd.registerSeriesType("area", nP);
        let { line: nL } = rd.seriesTypes, { merge: nO, pick: nE } = $;
        class nI extends nL {
            getPointSpline(t, e, i) {
                let s, o, r, a;
                let n = e.plotX || 0, h = e.plotY || 0, l = t[i - 1], d = t[i + 1];
                function c(t) {
                    return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;
                }
                if (c(l) && c(d)) {
                    let t = l.plotX || 0, i = l.plotY || 0, c = d.plotX || 0, p = d.plotY || 0, g = 0;
                    s = (1.5 * n + t) / 2.5, o = (1.5 * h + i) / 2.5, r = (1.5 * n + c) / 2.5, a = (1.5 * h + p) / 2.5, r !== s && (g = (a - o) * (r - n) / (r - s) + h - a), o += g, a += g, o > i && o > h ? (o = Math.max(i, h), a = 2 * h - o) : o < i && o < h && (o = Math.min(i, h), a = 2 * h - o), a > p && a > h ? (a = Math.max(p, h), o = 2 * h - a) : a < p && a < h && (a = Math.min(p, h), o = 2 * h - a), e.rightContX = r, e.rightContY = a, e.controlPoints = {
                        low: [
                            s,
                            o
                        ],
                        high: [
                            r,
                            a
                        ]
                    };
                }
                let p = [
                    "C",
                    nE(l.rightContX, l.plotX, 0),
                    nE(l.rightContY, l.plotY, 0),
                    nE(s, n, 0),
                    nE(o, h, 0),
                    n,
                    h
                ];
                return l.rightContX = l.rightContY = void 0, p;
            }
        }
        nI.defaultOptions = nO(nL.defaultOptions), rd.registerSeriesType("spline", nI);
        let nD = nI, { area: nB, area: { prototype: nN } } = rd.seriesTypes, { extend: nz, merge: nR } = $;
        class nW extends nD {
        }
        nW.defaultOptions = nR(nD.defaultOptions, nB.defaultOptions), nz(nW.prototype, {
            getGraphPath: nN.getGraphPath,
            getStackPoints: nN.getStackPoints,
            drawGraph: nN.drawGraph
        }), rd.registerSeriesType("areaspline", nW);
        let { animObject: nH } = tR, { parse: nX } = tk, { noop: nF } = k, { clamp: nG, crisp: nY, defined: nj, extend: nU, fireEvent: n$, isArray: nV, isNumber: n_, merge: nq, pick: nZ, objectEach: nK } = $;
        class nJ extends rY {
            animate(t) {
                let e, i;
                let s = this, o = this.yAxis, r = o.pos, a = o.reversed, n = s.options, { clipOffset: h, inverted: l } = this.chart, d = {}, c = l ? "translateX" : "translateY";
                t && h ? (d.scaleY = .001, i = nG(o.toPixels(n.threshold || 0), r, r + o.len), l ? (i += a ? -Math.floor(h[0]) : Math.ceil(h[2]), d.translateX = i - o.len) : (i += a ? Math.ceil(h[0]) : -Math.floor(h[2]), d.translateY = i), s.clipBox && s.setClip(), s.group.attr(d)) : (e = Number(s.group.attr(c)), s.group.animate({
                    scaleY: 1
                }, nU(nH(s.options.animation), {
                    step: function(t, i) {
                        s.group && (d[c] = e + i.pos * (r - e), s.group.attr(d));
                    }
                })));
            }
            init(t, e) {
                super.init.apply(this, arguments);
                let i = this;
                (t = i.chart).hasRendered && t.series.forEach(function(t) {
                    t.type === i.type && (t.isDirty = !0);
                });
            }
            getColumnMetrics() {
                let t = this, e = t.options, i = t.xAxis, s = t.yAxis, o = i.options.reversedStacks, r = i.reversed && !o || !i.reversed && o, a = {}, n, h = 0;
                !1 === e.grouping ? h = 1 : t.chart.series.forEach(function(e) {
                    let i;
                    let o = e.yAxis, r = e.options;
                    e.type === t.type && e.reserveSpace() && s.len === o.len && s.pos === o.pos && (r.stacking && "group" !== r.stacking ? (void 0 === a[n = e.stackKey] && (a[n] = h++), i = a[n]) : !1 !== r.grouping && (i = h++), e.columnIndex = i);
                });
                let l = Math.min(Math.abs(i.transA) * (!i.brokenAxis?.hasBreaks && i.ordinal?.slope || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len), d = l * e.groupPadding, c = (l - 2 * d) / (h || 1), p = Math.min(e.maxPointWidth || i.len, nZ(e.pointWidth, c * (1 - 2 * e.pointPadding))), g = (t.columnIndex || 0) + (r ? 1 : 0);
                return t.columnMetrics = {
                    width: p,
                    offset: (c - p) / 2 + (d + g * c - l / 2) * (r ? -1 : 1),
                    paddedWidth: c,
                    columnCount: h
                }, t.columnMetrics;
            }
            crispCol(t, e, i, s) {
                let o = this.borderWidth, r = this.chart.inverted;
                return s = nY(e + s, o, r) - (e = nY(e, o, r)), this.options.crisp && (i = nY(t + i, o) - (t = nY(t, o))), {
                    x: t,
                    y: e,
                    width: i,
                    height: s
                };
            }
            adjustForMissingColumns(t, e, i, s) {
                if (!i.isNull && s.columnCount > 1) {
                    let o = this.xAxis.series.filter((t)=>t.visible).map((t)=>t.index), r = 0, a = 0;
                    nK(this.xAxis.stacking?.stacks, (t)=>{
                        let e = "number" == typeof i.x ? t[i.x.toString()]?.points : void 0, s = e?.[this.index], n = {};
                        if (e && nV(s)) {
                            let t = this.index, i = Object.keys(e).filter((t)=>!t.match(",") && e[t] && e[t].length > 1).map(parseFloat).filter((t)=>-1 !== o.indexOf(t)).filter((e)=>{
                                let i = this.chart.series[e].options, s = i.stacking && i.stack;
                                if (nj(s)) {
                                    if (n_(n[s])) return t === e && (t = n[s]), !1;
                                    n[s] = e;
                                }
                                return !0;
                            }).sort((t, e)=>e - t);
                            r = i.indexOf(t), a = i.length;
                        }
                    }), r = this.xAxis.reversed ? a - 1 - r : r;
                    let n = (a - 1) * s.paddedWidth + e;
                    t = (i.plotX || 0) + n / 2 - e - r * s.paddedWidth;
                }
                return t;
            }
            translate() {
                let t = this, e = t.chart, i = t.options, s = t.dense = t.closestPointRange * t.xAxis.transA < 2, o = t.borderWidth = nZ(i.borderWidth, s ? 0 : 1), r = t.xAxis, a = t.yAxis, n = i.threshold, h = nZ(i.minPointLength, 5), l = t.getColumnMetrics(), d = l.width, c = t.pointXOffset = l.offset, p = t.dataMin, g = t.dataMax, u = t.translatedThreshold = a.getThreshold(n), f = t.barW = Math.max(d, 1 + 2 * o);
                i.pointPadding && i.crisp && (f = Math.ceil(f)), rY.prototype.translate.apply(t), t.points.forEach(function(s) {
                    let o = nZ(s.yBottom, u), m = 999 + Math.abs(o), x = s.plotX || 0, y = nG(s.plotY, -m, a.len + m), b, v = Math.min(y, o), k = Math.max(y, o) - v, w = d, M = x + c, S = f;
                    h && Math.abs(k) < h && (k = h, b = !a.reversed && !s.negative || a.reversed && s.negative, n_(n) && n_(g) && s.y === n && g <= n && (a.min || 0) < n && (p !== g || (a.max || 0) <= n) && (b = !b, s.negative = !s.negative), v = Math.abs(v - u) > h ? o - h : u - (b ? h : 0)), nj(s.options.pointWidth) && (M -= Math.round(((w = S = Math.ceil(s.options.pointWidth)) - d) / 2)), i.centerInCategory && (M = t.adjustForMissingColumns(M, w, s, l)), s.barX = M, s.pointWidth = w, s.tooltipPos = e.inverted ? [
                        nG(a.len + a.pos - e.plotLeft - y, a.pos - e.plotLeft, a.len + a.pos - e.plotLeft),
                        r.len + r.pos - e.plotTop - M - S / 2,
                        k
                    ] : [
                        r.left - e.plotLeft + M + S / 2,
                        nG(y + a.pos - e.plotTop, a.pos - e.plotTop, a.len + a.pos - e.plotTop),
                        k
                    ], s.shapeType = t.pointClass.prototype.shapeType || "roundedRect", s.shapeArgs = t.crispCol(M, s.isNull ? u : v, S, s.isNull ? 0 : k);
                }), n$(this, "afterColumnTranslate");
            }
            drawGraph() {
                this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            }
            pointAttribs(t, e) {
                let i = this.options, s = this.pointAttrToOptions || {}, o = s.stroke || "borderColor", r = s["stroke-width"] || "borderWidth", a, n, h, l = t && t.color || this.color, d = t && t[o] || i[o] || l, c = t && t.options.dashStyle || i.dashStyle, p = t && t[r] || i[r] || this[r] || 0, g = nZ(t && t.opacity, i.opacity, 1);
                t && this.zones.length && (n = t.getZone(), l = t.options.color || n && (n.color || t.nonZonedColor) || this.color, n && (d = n.borderColor || d, c = n.dashStyle || c, p = n.borderWidth || p)), e && t && (h = (a = nq(i.states[e], t.options.states && t.options.states[e] || {})).brightness, l = a.color || void 0 !== h && nX(l).brighten(a.brightness).get() || l, d = a[o] || d, p = a[r] || p, c = a.dashStyle || c, g = nZ(a.opacity, g));
                let u = {
                    fill: l,
                    stroke: d,
                    "stroke-width": p,
                    opacity: g
                };
                return c && (u.dashstyle = c), u;
            }
            drawPoints(t = this.points) {
                let e;
                let i = this, s = this.chart, o = i.options, r = s.renderer, a = o.animationLimit || 250;
                t.forEach(function(t) {
                    let n = t.plotY, h = t.graphic, l = !!h, d = h && s.pointCount < a ? "animate" : "attr";
                    n_(n) && null !== t.y ? (e = t.shapeArgs, h && t.hasNewShapeType() && (h = h.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !h && (t.graphic = h = r[t.shapeType](e).add(t.group || i.group), h && i.enabledDataSorting && s.hasRendered && s.pointCount < a && (h.attr({
                        x: t.startXPos
                    }), l = !0, d = "animate")), h && l && h[d](nq(e)), s.styledMode || h[d](i.pointAttribs(t, t.selected && "select")).shadow(!1 !== t.allowShadow && o.shadow), h && (h.addClass(t.getClassName(), !0), h.attr({
                        visibility: t.visible ? "inherit" : "hidden"
                    }))) : h && (t.graphic = h.destroy());
                });
            }
            drawTracker(t = this.points) {
                let e;
                let i = this, s = i.chart, o = s.pointer, r = function(t) {
                    o?.normalize(t);
                    let e = o?.getPointFromEvent(t), r = !s.scrollablePlotArea || s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, {
                        visiblePlotOnly: !0
                    });
                    o && e && i.options.enableMouseTracking && r && (o.isDirectTouch = !0, e.onMouseOver(t));
                };
                t.forEach(function(t) {
                    e = nV(t.dataLabels) ? t.dataLabels : t.dataLabel ? [
                        t.dataLabel
                    ] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function(e) {
                        (e.div || e.element).point = t;
                    });
                }), i._hasTracking || (i.trackerGroups.forEach(function(t) {
                    i[t] && (i[t].addClass("highcharts-tracker").on("mouseover", r).on("mouseout", function(t) {
                        o?.onTrackerMouseOut(t);
                    }).on("touchstart", r), !s.styledMode && i.options.cursor && i[t].css({
                        cursor: i.options.cursor
                    }));
                }), i._hasTracking = !0), n$(this, "afterDrawTracker");
            }
            remove() {
                let t = this, e = t.chart;
                e.hasRendered && e.series.forEach(function(e) {
                    e.type === t.type && (e.isDirty = !0);
                }), rY.prototype.remove.apply(t, arguments);
            }
        }
        nJ.defaultOptions = nq(rY.defaultOptions, {
            borderRadius: 3,
            centerInCategory: !1,
            groupPadding: .2,
            marker: null,
            pointPadding: .1,
            minPointLength: 0,
            cropThreshold: 50,
            pointRange: null,
            states: {
                hover: {
                    halo: !1,
                    brightness: .1
                },
                select: {
                    color: "#cccccc",
                    borderColor: "#000000"
                }
            },
            dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
            },
            startFromThreshold: !0,
            stickyTracking: !1,
            tooltip: {
                distance: 6
            },
            threshold: 0,
            borderColor: "#ffffff"
        }), nU(nJ.prototype, {
            directTouch: !0,
            getSymbol: nF,
            negStacks: !0,
            trackerGroups: [
                "group",
                "dataLabelsGroup"
            ]
        }), rd.registerSeriesType("column", nJ);
        let nQ = nJ, { getDeferredAnimation: n0 } = tR, { format: n1 } = eo, { defined: n2, extend: n3, fireEvent: n5, getAlignFactor: n6, isArray: n9, isString: n4, merge: n8, objectEach: n7, pick: ht, pInt: he, splat: hi } = $;
        !function(t) {
            function e() {
                return h(this).some((t)=>t?.enabled);
            }
            function i(t, e, i, s, o) {
                let { chart: r, enabledDataSorting: a } = this, n = this.isCartesian && r.inverted, h = t.plotX, l = t.plotY, d = i.rotation || 0, c = n2(h) && n2(l) && r.isInsidePlot(h, Math.round(l), {
                    inverted: n,
                    paneCoordinates: !0,
                    series: this
                }), p = 0 === d && "justify" === ht(i.overflow, a ? "none" : "justify"), g = this.visible && !1 !== t.visible && n2(h) && (t.series.forceDL || a && !p || c || ht(i.inside, !!this.options.stacking) && s && r.isInsidePlot(h, n ? s.x + 1 : s.y + s.height - 1, {
                    inverted: n,
                    paneCoordinates: !0,
                    series: this
                })), u = t.pos();
                if (g && u) {
                    var f;
                    let h = e.getBBox(), l = e.getBBox(void 0, 0);
                    if (s = n3({
                        x: u[0],
                        y: Math.round(u[1]),
                        width: 0,
                        height: 0
                    }, s || {}), "plotEdges" === i.alignTo && this.isCartesian && (s[n ? "x" : "y"] = 0, s[n ? "width" : "height"] = this.yAxis?.len || 0), n3(i, {
                        width: h.width,
                        height: h.height
                    }), f = s, a && this.xAxis && !p && this.setDataLabelStartPos(t, e, o, c, f), e.align(n8(i, {
                        width: l.width,
                        height: l.height
                    }), !1, s, !1), e.alignAttr.x += n6(i.align) * (l.width - h.width), e.alignAttr.y += n6(i.verticalAlign) * (l.height - h.height), e[e.placed ? "animate" : "attr"]({
                        "text-align": e.alignAttr["text-align"] || "center",
                        x: e.alignAttr.x + (h.width - l.width) / 2,
                        y: e.alignAttr.y + (h.height - l.height) / 2,
                        rotationOriginX: (e.width || 0) / 2,
                        rotationOriginY: (e.height || 0) / 2
                    }), p && s.height >= 0) this.justifyDataLabel(e, i, e.alignAttr, h, s, o);
                    else if (ht(i.crop, !0)) {
                        let { x: t, y: i } = e.alignAttr;
                        g = r.isInsidePlot(t, i, {
                            paneCoordinates: !0,
                            series: this
                        }) && r.isInsidePlot(t + h.width - 1, i + h.height - 1, {
                            paneCoordinates: !0,
                            series: this
                        });
                    }
                    i.shape && !d && e[o ? "attr" : "animate"]({
                        anchorX: u[0],
                        anchorY: u[1]
                    });
                }
                o && a && (e.placed = !1), g || a && !p ? (e.show(), e.placed = !0) : (e.hide(), e.placed = !1);
            }
            function s() {
                return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
            }
            function o(t) {
                let e = this.hasRendered || 0, i = this.initDataLabelsGroup().attr({
                    opacity: +e
                });
                return !e && i && (this.visible && i.show(), this.options.animation ? i.animate({
                    opacity: 1
                }, t) : i.attr({
                    opacity: 1
                })), i;
            }
            function r(t) {
                let e;
                t = t || this.points;
                let i = this, s = i.chart, o = i.options, r = s.renderer, { backgroundColor: a, plotBackgroundColor: l } = s.options.chart, d = r.getContrast(n4(l) && l || n4(a) && a || "#000000"), c = h(i), { animation: p, defer: g } = c[0], u = g ? n0(s, p, i) : {
                    defer: 0,
                    duration: 0
                };
                n5(this, "drawDataLabels"), i.hasDataLabels?.() && (e = this.initDataLabels(u), t.forEach((t)=>{
                    let a = t.dataLabels || [];
                    hi(n(c, t.dlOptions || t.options?.dataLabels)).forEach((n, h)=>{
                        let l = n.enabled && (t.visible || t.dataLabelOnHidden) && (!t.isNull || t.dataLabelOnNull) && function(t, e) {
                            let i = e.filter;
                            if (i) {
                                let e = i.operator, s = t[i.property], o = i.value;
                                return ">" === e && s > o || "<" === e && s < o || ">=" === e && s >= o || "<=" === e && s <= o || "==" === e && s == o || "===" === e && s === o || "!=" === e && s != o || "!==" === e && s !== o;
                            }
                            return !0;
                        }(t, n), { backgroundColor: c, borderColor: p, distance: g, style: u = {} } = n, f, m, x, y = {}, b = a[h], v = !b, k;
                        l && (m = n2(f = ht(n[t.formatPrefix + "Format"], n.format)) ? n1(f, t, s) : (n[t.formatPrefix + "Formatter"] || n.formatter).call(t, n), x = n.rotation, !s.styledMode && (u.color = ht(n.color, u.color, n4(i.color) ? i.color : void 0, "#000000"), "contrast" === u.color ? ("none" !== c && (k = c), t.contrastColor = r.getContrast("auto" !== k && k || t.color || i.color), u.color = k || !n2(g) && n.inside || 0 > he(g || 0) || o.stacking ? t.contrastColor : d) : delete t.contrastColor, o.cursor && (u.cursor = o.cursor)), y = {
                            r: n.borderRadius || 0,
                            rotation: x,
                            padding: n.padding,
                            zIndex: 1
                        }, s.styledMode || (y.fill = "auto" === c ? t.color : c, y.stroke = "auto" === p ? t.color : p, y["stroke-width"] = n.borderWidth), n7(y, (t, e)=>{
                            void 0 === t && delete y[e];
                        })), !b || l && n2(m) && !!b.div == !!n.useHTML && (b.rotation && n.rotation || b.rotation === n.rotation) || (b = void 0, v = !0), l && n2(m) && (b ? y.text = m : (b = r.label(m, 0, 0, n.shape, void 0, void 0, n.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + t.colorIndex + " " + (n.className || "") + (n.useHTML ? " highcharts-tracker" : "")), b && (b.options = n, b.attr(y), s.styledMode ? u.width && b.css({
                            width: u.width,
                            textOverflow: u.textOverflow,
                            whiteSpace: u.whiteSpace
                        }) : b.css(u).shadow(n.shadow), n5(b, "beforeAddingDataLabel", {
                            labelOptions: n,
                            point: t
                        }), b.added || b.add(e), i.alignDataLabel(t, b, n, void 0, v), b.isActive = !0, a[h] && a[h] !== b && a[h].destroy(), a[h] = b));
                    });
                    let h = a.length;
                    for(; h--;)a[h] && a[h].isActive ? a[h].isActive = !1 : (a[h]?.destroy(), a.splice(h, 1));
                    t.dataLabel = a[0], t.dataLabels = a;
                })), n5(this, "afterDrawDataLabels");
            }
            function a(t, e, i, s, o, r) {
                let a = this.chart, n = e.align, h = e.verticalAlign, l = t.box ? 0 : t.padding || 0, d = a.inverted ? this.yAxis : this.xAxis, c = d ? d.left - a.plotLeft : 0, p = a.inverted ? this.xAxis : this.yAxis, g = p ? p.top - a.plotTop : 0, { x: u = 0, y: f = 0 } = e, m, x;
                return (m = (i.x || 0) + l + c) < 0 && ("right" === n && u >= 0 ? (e.align = "left", e.inside = !0) : u -= m, x = !0), (m = (i.x || 0) + s.width - l + c) > a.plotWidth && ("left" === n && u <= 0 ? (e.align = "right", e.inside = !0) : u += a.plotWidth - m, x = !0), (m = i.y + l + g) < 0 && ("bottom" === h && f >= 0 ? (e.verticalAlign = "top", e.inside = !0) : f -= m, x = !0), (m = (i.y || 0) + s.height - l + g) > a.plotHeight && ("top" === h && f <= 0 ? (e.verticalAlign = "bottom", e.inside = !0) : f += a.plotHeight - m, x = !0), x && (e.x = u, e.y = f, t.placed = !r, t.align(e, void 0, o)), x;
            }
            function n(t, e) {
                let i = [], s;
                if (n9(t) && !n9(e)) i = t.map(function(t) {
                    return n8(t, e);
                });
                else if (n9(e) && !n9(t)) i = e.map(function(e) {
                    return n8(t, e);
                });
                else if (n9(t) || n9(e)) {
                    if (n9(t) && n9(e)) for(s = Math.max(t.length, e.length); s--;)i[s] = n8(t[s], e[s]);
                } else i = n8(t, e);
                return i;
            }
            function h(t) {
                let e = t.chart.options.plotOptions;
                return hi(n(n(e?.series?.dataLabels, e?.[t.type]?.dataLabels), t.options.dataLabels));
            }
            function l(t, e, i, s, o) {
                let r = this.chart, a = r.inverted, n = this.xAxis, h = n.reversed, l = ((a ? e.height : e.width) || 0) / 2, d = t.pointWidth, c = d ? d / 2 : 0;
                e.startXPos = a ? o.x : h ? -l - c : n.width - l + c, e.startYPos = a ? h ? this.yAxis.height - l + c : -l - c : o.y, s ? "hidden" === e.visibility && (e.show(), e.attr({
                    opacity: 0
                }).animate({
                    opacity: 1
                })) : e.attr({
                    opacity: 1
                }).animate({
                    opacity: 0
                }, void 0, e.hide), r.hasRendered && (i && e.attr({
                    x: e.startXPos,
                    y: e.startYPos
                }), e.placed = !0);
            }
            t.compose = function(t) {
                let n = t.prototype;
                n.initDataLabels || (n.initDataLabels = o, n.initDataLabelsGroup = s, n.alignDataLabel = i, n.drawDataLabels = r, n.justifyDataLabel = a, n.setDataLabelStartPos = l, n.hasDataLabels = e);
            };
        }(g || (g = {}));
        let hs = g, { composed: ho } = k, { series: hr } = rd, { merge: ha, pick: hn, pushUnique: hh } = $;
        !function(t) {
            function e(t, e, i, s, o) {
                let r = this.chart.inverted, a = t.series, n = (a.xAxis ? a.xAxis.len : this.chart.plotSizeX) || 0, h = (a.yAxis ? a.yAxis.len : this.chart.plotSizeY) || 0, l = t.dlBox || t.shapeArgs, d = hn(t.below, t.plotY > hn(this.translatedThreshold, h)), c = hn(i.inside, !!this.options.stacking);
                if (l) {
                    if (s = ha(l), !("allow" === i.overflow && !1 === i.crop)) {
                        s.y < 0 && (s.height += s.y, s.y = 0);
                        let t = s.y + s.height - h;
                        t > 0 && t < s.height - 1 && (s.height -= t);
                    }
                    r && (s = {
                        x: h - s.y - s.height,
                        y: n - s.x - s.width,
                        width: s.height,
                        height: s.width
                    }), c || (r ? (s.x += d ? 0 : s.width, s.width = 0) : (s.y += d ? s.height : 0, s.height = 0));
                }
                i.align = hn(i.align, !r || c ? "center" : d ? "right" : "left"), i.verticalAlign = hn(i.verticalAlign, r || c ? "middle" : d ? "top" : "bottom"), hr.prototype.alignDataLabel.call(this, t, e, i, s, o), i.inside && t.contrastColor && e.css({
                    color: t.contrastColor
                });
            }
            t.compose = function(t) {
                hs.compose(hr), hh(ho, "ColumnDataLabel") && (t.prototype.alignDataLabel = e);
            };
        }(u || (u = {}));
        let hl = u, { extend: hd, merge: hc } = $;
        class hp extends nQ {
        }
        hp.defaultOptions = hc(nQ.defaultOptions, {}), hd(hp.prototype, {
            inverted: !0
        }), rd.registerSeriesType("bar", hp);
        let { column: hg, line: hu } = rd.seriesTypes, { addEvent: hf, extend: hm, merge: hx } = $;
        class hy extends hu {
            applyJitter() {
                let t = this, e = this.options.jitter, i = this.points.length;
                e && this.points.forEach(function(s, o) {
                    [
                        "x",
                        "y"
                    ].forEach(function(r, a) {
                        if (e[r] && !s.isNull) {
                            let n = `plot${r.toUpperCase()}`, h = t[`${r}Axis`], l = e[r] * h.transA;
                            if (h && !h.logarithmic) {
                                let t = Math.max(0, (s[n] || 0) - l), e = Math.min(h.len, (s[n] || 0) + l);
                                s[n] = t + (e - t) * function(t) {
                                    let e = 1e4 * Math.sin(t);
                                    return e - Math.floor(e);
                                }(o + a * i), "x" === r && (s.clientX = s.plotX);
                            }
                        }
                    });
                });
            }
            drawGraph() {
                this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
            }
        }
        hy.defaultOptions = hx(hu.defaultOptions, {
            lineWidth: 0,
            findNearestPointBy: "xy",
            jitter: {
                x: 0,
                y: 0
            },
            marker: {
                enabled: !0
            },
            tooltip: {
                headerFormat: '<span style="color:{point.color}"></span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
            }
        }), hm(hy.prototype, {
            drawTracker: hg.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: [
                "group",
                "markerGroup",
                "dataLabelsGroup"
            ]
        }), hf(hy, "afterTranslate", function() {
            this.applyJitter();
        }), rd.registerSeriesType("scatter", hy);
        let { deg2rad: hb } = k, { fireEvent: hv, isNumber: hk, pick: hw, relativeLength: hM } = $;
        !function(t) {
            t.getCenter = function() {
                let t = this.options, e = this.chart, i = 2 * (t.slicedOffset || 0), s = e.plotWidth - 2 * i, o = e.plotHeight - 2 * i, r = t.center, a = Math.min(s, o), n = t.thickness, h, l = t.size, d = t.innerSize || 0, c, p;
                "string" == typeof l && (l = parseFloat(l)), "string" == typeof d && (d = parseFloat(d));
                let g = [
                    hw(r?.[0], "50%"),
                    hw(r?.[1], "50%"),
                    hw(l && l < 0 ? void 0 : t.size, "100%"),
                    hw(d && d < 0 ? void 0 : t.innerSize || 0, "0%")
                ];
                for(!e.angular || this instanceof rY || (g[3] = 0), c = 0; c < 4; ++c)p = g[c], h = c < 2 || 2 === c && /%$/.test(p), g[c] = hM(p, [
                    s,
                    o,
                    a,
                    g[2]
                ][c]) + (h ? i : 0);
                return g[3] > g[2] && (g[3] = g[2]), hk(n) && 2 * n < g[2] && n > 0 && (g[3] = g[2] - 2 * n), hv(this, "afterGetCenter", {
                    positions: g
                }), g;
            }, t.getStartAndEndRadians = function(t, e) {
                let i = hk(t) ? t : 0, s = hk(e) && e > i && e - i < 360 ? e : i + 360;
                return {
                    start: hb * (i + -90),
                    end: hb * (s + -90)
                };
            };
        }(f || (f = {}));
        let hS = f, { setAnimation: hT } = tR, { addEvent: hC, defined: hA, extend: hP, isNumber: hL, pick: hO, relativeLength: hE } = $;
        class hI extends oF {
            getConnectorPath(t) {
                let e = t.dataLabelPosition, i = t.options || {}, s = i.connectorShape, o = this.connectorShapes[s] || s;
                return e && o.call(this, {
                    ...e.computed,
                    alignment: e.alignment
                }, e.connectorPosition, i) || [];
            }
            getTranslate() {
                return this.sliced && this.slicedTranslation || {
                    translateX: 0,
                    translateY: 0
                };
            }
            haloPath(t) {
                let e = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {
                    innerR: e.r - 1,
                    start: e.start,
                    end: e.end,
                    borderRadius: e.borderRadius
                });
            }
            constructor(t, e, i){
                super(t, e, i), this.half = 0, this.name ?? (this.name = "Slice");
                let s = (t)=>{
                    this.slice("select" === t.type);
                };
                hC(this, "select", s), hC(this, "unselect", s);
            }
            isValid() {
                return hL(this.y) && this.y >= 0;
            }
            setVisible(t, e = !0) {
                t !== this.visible && this.update({
                    visible: t ?? !this.visible
                }, e, void 0, !1);
            }
            slice(t, e, i) {
                let s = this.series;
                hT(i, s.chart), e = hO(e, !0), this.sliced = this.options.sliced = t = hA(t) ? t : !this.sliced, s.options.data[s.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
            }
        }
        hP(hI.prototype, {
            connectorShapes: {
                fixedOffset: function(t, e, i) {
                    let s = e.breakAt, o = e.touchingSliceAt, r = i.softConnector ? [
                        "C",
                        t.x + ("left" === t.alignment ? -5 : 5),
                        t.y,
                        2 * s.x - o.x,
                        2 * s.y - o.y,
                        s.x,
                        s.y
                    ] : [
                        "L",
                        s.x,
                        s.y
                    ];
                    return [
                        [
                            "M",
                            t.x,
                            t.y
                        ],
                        r,
                        [
                            "L",
                            o.x,
                            o.y
                        ]
                    ];
                },
                straight: function(t, e) {
                    let i = e.touchingSliceAt;
                    return [
                        [
                            "M",
                            t.x,
                            t.y
                        ],
                        [
                            "L",
                            i.x,
                            i.y
                        ]
                    ];
                },
                crookedLine: function(t, e, i) {
                    let { angle: s = this.angle || 0, breakAt: o, touchingSliceAt: r } = e, { series: a } = this, [n, h, l] = a.center, d = l / 2, { plotLeft: c, plotWidth: p } = a.chart, g = "left" === t.alignment, { x: u, y: f } = t, m = o.x;
                    if (i.crookDistance) {
                        let t = hE(i.crookDistance, 1);
                        m = g ? n + d + (p + c - n - d) * (1 - t) : c + (n - d) * t;
                    } else m = n + (h - f) * Math.tan(s - Math.PI / 2);
                    let x = [
                        [
                            "M",
                            u,
                            f
                        ]
                    ];
                    return (g ? m <= u && m >= o.x : m >= u && m <= o.x) && x.push([
                        "L",
                        m,
                        f
                    ]), x.push([
                        "L",
                        o.x,
                        o.y
                    ], [
                        "L",
                        r.x,
                        r.y
                    ]), x;
                }
            }
        });
        let { getStartAndEndRadians: hD } = hS, { noop: hB } = k, { clamp: hN, extend: hz, fireEvent: hR, merge: hW, pick: hH } = $;
        class hX extends rY {
            animate(t) {
                let e = this, i = e.points, s = e.startAngleRad;
                t || i.forEach(function(t) {
                    let i = t.graphic, o = t.shapeArgs;
                    i && o && (i.attr({
                        r: hH(t.startR, e.center && e.center[3] / 2),
                        start: s,
                        end: s
                    }), i.animate({
                        r: o.r,
                        start: o.start,
                        end: o.end
                    }, e.options.animation));
                });
            }
            drawEmpty() {
                let t, e;
                let i = this.startAngleRad, s = this.endAngleRad, o = this.options;
                0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({
                    d: e6.arc(t, e, this.center[2] / 2, 0, {
                        start: i,
                        end: s,
                        innerR: this.center[3] / 2
                    })
                }), this.chart.styledMode || this.graph.attr({
                    "stroke-width": o.borderWidth,
                    fill: o.fillColor || "none",
                    stroke: o.color || "#cccccc"
                })) : this.graph && (this.graph = this.graph.destroy());
            }
            drawPoints() {
                let t = this.chart.renderer;
                this.points.forEach(function(e) {
                    e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);
                });
            }
            generatePoints() {
                super.generatePoints(), this.updateTotals();
            }
            getX(t, e, i, s) {
                let o = this.center, r = this.radii ? this.radii[i.index] || 0 : o[2] / 2, a = s.dataLabelPosition, n = a?.distance || 0, h = Math.asin(hN((t - o[1]) / (r + n), -1, 1));
                return o[0] + Math.cos(h) * (r + n) * (e ? -1 : 1) + (n > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);
            }
            hasData() {
                return !!this.dataTable.rowCount;
            }
            redrawPoints() {
                let t, e, i, s;
                let o = this, r = o.chart;
                this.drawEmpty(), o.group && !r.styledMode && o.group.shadow(o.options.shadow), o.points.forEach(function(a) {
                    let n = {};
                    e = a.graphic, !a.isNull && e ? (s = a.shapeArgs, t = a.getTranslate(), r.styledMode || (i = o.pointAttribs(a, a.selected && "select")), a.delayedRendering ? (e.setRadialReference(o.center).attr(s).attr(t), r.styledMode || e.attr(i).attr({
                        "stroke-linejoin": "round"
                    }), a.delayedRendering = !1) : (e.setRadialReference(o.center), r.styledMode || hW(!0, n, i), hW(!0, n, s, t), e.animate(n)), e.attr({
                        visibility: a.visible ? "inherit" : "hidden"
                    }), e.addClass(a.getClassName(), !0)) : e && (a.graphic = e.destroy());
                });
            }
            sortByAngle(t, e) {
                t.sort(function(t, i) {
                    return void 0 !== t.angle && (i.angle - t.angle) * e;
                });
            }
            translate(t) {
                hR(this, "translate"), this.generatePoints();
                let e = this.options, i = e.slicedOffset, s = hD(e.startAngle, e.endAngle), o = this.startAngleRad = s.start, r = (this.endAngleRad = s.end) - o, a = this.points, n = e.ignoreHiddenPoint, h = a.length, l, d, c, p, g, u, f, m = 0;
                for(t || (this.center = t = this.getCenter()), u = 0; u < h; u++){
                    f = a[u], l = o + m * r, f.isValid() && (!n || f.visible) && (m += f.percentage / 100), d = o + m * r;
                    let e = {
                        x: t[0],
                        y: t[1],
                        r: t[2] / 2,
                        innerR: t[3] / 2,
                        start: Math.round(1e3 * l) / 1e3,
                        end: Math.round(1e3 * d) / 1e3
                    };
                    f.shapeType = "arc", f.shapeArgs = e, (c = (d + l) / 2) > 1.5 * Math.PI ? c -= 2 * Math.PI : c < -Math.PI / 2 && (c += 2 * Math.PI), f.slicedTranslation = {
                        translateX: Math.round(Math.cos(c) * i),
                        translateY: Math.round(Math.sin(c) * i)
                    }, p = Math.cos(c) * t[2] / 2, g = Math.sin(c) * t[2] / 2, f.tooltipPos = [
                        t[0] + .7 * p,
                        t[1] + .7 * g
                    ], f.half = c < -Math.PI / 2 || c > Math.PI / 2 ? 1 : 0, f.angle = c;
                }
                hR(this, "afterTranslate");
            }
            updateTotals() {
                let t = this.points, e = t.length, i = this.options.ignoreHiddenPoint, s, o, r = 0;
                for(s = 0; s < e; s++)(o = t[s]).isValid() && (!i || o.visible) && (r += o.y);
                for(s = 0, this.total = r; s < e; s++)(o = t[s]).percentage = r > 0 && (o.visible || !i) ? o.y / r * 100 : 0, o.total = r;
            }
        }
        hX.defaultOptions = hW(rY.defaultOptions, {
            borderRadius: 3,
            center: [
                null,
                null
            ],
            clip: !1,
            colorByPoint: !0,
            dataLabels: {
                connectorPadding: 5,
                connectorShape: "crookedLine",
                crookDistance: void 0,
                distance: 30,
                enabled: !0,
                formatter: function() {
                    return this.isNull ? void 0 : this.name;
                },
                softConnector: !0,
                x: 0
            },
            fillColor: void 0,
            ignoreHiddenPoint: !0,
            inactiveOtherPoints: !0,
            legendType: "point",
            marker: null,
            size: null,
            showInLegend: !1,
            slicedOffset: 10,
            stickyTracking: !1,
            tooltip: {
                followPointer: !0
            },
            borderColor: "#ffffff",
            borderWidth: 1,
            lineWidth: void 0,
            states: {
                hover: {
                    brightness: .1
                }
            }
        }), hz(hX.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawTracker: nQ.prototype.drawTracker,
            getCenter: hS.getCenter,
            getSymbol: hB,
            invertible: !1,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: nQ.prototype.pointAttribs,
            pointClass: hI,
            requireSorting: !1,
            searchPoint: hB,
            trackerGroups: [
                "group",
                "dataLabelsGroup"
            ]
        }), rd.registerSeriesType("pie", hX);
        let { composed: hF, noop: hG } = k, { distribute: hY } = ed, { series: hj } = rd, { arrayMax: hU, clamp: h$, defined: hV, pick: h_, pushUnique: hq, relativeLength: hZ } = $;
        !function(t) {
            let e = {
                radialDistributionY: function(t, e) {
                    return (e.dataLabelPosition?.top || 0) + t.distributeBox.pos;
                },
                radialDistributionX: function(t, e, i, s, o) {
                    let r = o.dataLabelPosition;
                    return t.getX(i < (r?.top || 0) + 2 || i > (r?.bottom || 0) - 2 ? s : i, e.half, e, o);
                },
                justify: function(t, e, i, s) {
                    return s[0] + (t.half ? -1 : 1) * (i + (e.dataLabelPosition?.distance || 0));
                },
                alignToPlotEdges: function(t, e, i, s) {
                    let o = t.getBBox().width;
                    return e ? o + s : i - o - s;
                },
                alignToConnectors: function(t, e, i, s) {
                    let o = 0, r;
                    return t.forEach(function(t) {
                        (r = t.dataLabel.getBBox().width) > o && (o = r);
                    }), e ? o + s : i - o - s;
                }
            };
            function i(t, e) {
                let i = Math.PI / 2, { start: s = 0, end: o = 0 } = t.shapeArgs || {}, r = t.angle || 0;
                e > 0 && s < i && o > i && r > i / 2 && r < 1.5 * i && (r = r <= i ? Math.max(i / 2, (s + i) / 2) : Math.min(1.5 * i, (i + o) / 2));
                let { center: a, options: n } = this, h = a[2] / 2, l = Math.cos(r), d = Math.sin(r), c = a[0] + l * h, p = a[1] + d * h, g = Math.min((n.slicedOffset || 0) + (n.borderWidth || 0), e / 5);
                return {
                    natural: {
                        x: c + l * e,
                        y: p + d * e
                    },
                    computed: {},
                    alignment: e < 0 ? "center" : t.half ? "right" : "left",
                    connectorPosition: {
                        angle: r,
                        breakAt: {
                            x: c + l * g,
                            y: p + d * g
                        },
                        touchingSliceAt: {
                            x: c,
                            y: p
                        }
                    },
                    distance: e
                };
            }
            function s() {
                let t = this, e = t.points, i = t.chart, s = i.plotWidth, o = i.plotHeight, r = i.plotLeft, a = Math.round(i.chartWidth / 3), n = t.center, h = n[2] / 2, l = n[1], d = [
                    [],
                    []
                ], c = [
                    0,
                    0,
                    0,
                    0
                ], p = t.dataLabelPositioners, g, u, f, m = 0;
                t.visible && t.hasDataLabels?.() && (e.forEach((t)=>{
                    (t.dataLabels || []).forEach((t)=>{
                        t.shortened && (t.attr({
                            width: "auto"
                        }).css({
                            width: "auto",
                            textOverflow: "clip"
                        }), t.shortened = !1);
                    });
                }), hj.prototype.drawDataLabels.apply(t), e.forEach((t)=>{
                    (t.dataLabels || []).forEach((e, i)=>{
                        let s = n[2] / 2, o = e.options, r = hZ(o?.distance || 0, s);
                        0 === i && d[t.half].push(t), !hV(o?.style?.width) && e.getBBox().width > a && (e.css({
                            width: Math.round(.7 * a) + "px"
                        }), e.shortened = !0), e.dataLabelPosition = this.getDataLabelPosition(t, r), m = Math.max(m, r);
                    });
                }), d.forEach((e, a)=>{
                    let d = e.length, g = [], x, y, b = 0, v;
                    d && (t.sortByAngle(e, a - .5), m > 0 && (x = Math.max(0, l - h - m), y = Math.min(l + h + m, i.plotHeight), e.forEach((t)=>{
                        (t.dataLabels || []).forEach((e)=>{
                            let s = e.dataLabelPosition;
                            s && s.distance > 0 && (s.top = Math.max(0, l - h - s.distance), s.bottom = Math.min(l + h + s.distance, i.plotHeight), b = e.getBBox().height || 21, e.lineHeight = i.renderer.fontMetrics(e.text || e).h + 2 * e.padding, t.distributeBox = {
                                target: (e.dataLabelPosition?.natural.y || 0) - s.top + e.lineHeight / 2,
                                size: b,
                                rank: t.y
                            }, g.push(t.distributeBox));
                        });
                    }), hY(g, v = y + b - x, v / 5)), e.forEach((i)=>{
                        (i.dataLabels || []).forEach((l)=>{
                            let d = l.options || {}, m = i.distributeBox, x = l.dataLabelPosition, y = x?.natural.y || 0, b = d.connectorPadding || 0, v = l.lineHeight || 21, k = (v - l.getBBox().height) / 2, w = 0, M = y, S = "inherit";
                            if (x) {
                                if (g && hV(m) && x.distance > 0 && (void 0 === m.pos ? S = "hidden" : (f = m.size, M = p.radialDistributionY(i, l))), d.justify) w = p.justify(i, l, h, n);
                                else switch(d.alignTo){
                                    case "connectors":
                                        w = p.alignToConnectors(e, a, s, r);
                                        break;
                                    case "plotEdges":
                                        w = p.alignToPlotEdges(l, a, s, r);
                                        break;
                                    default:
                                        w = p.radialDistributionX(t, i, M - k, y, l);
                                }
                                if (x.attribs = {
                                    visibility: S,
                                    align: x.alignment
                                }, x.posAttribs = {
                                    x: w + (d.x || 0) + (({
                                        left: b,
                                        right: -b
                                    })[x.alignment] || 0),
                                    y: M + (d.y || 0) - v / 2
                                }, x.computed.x = w, x.computed.y = M - k, h_(d.crop, !0)) {
                                    let t;
                                    w - (u = l.getBBox().width) < b && 1 === a ? (t = Math.round(u - w + b), c[3] = Math.max(t, c[3])) : w + u > s - b && 0 === a && (t = Math.round(w + u - s + b), c[1] = Math.max(t, c[1])), M - f / 2 < 0 ? c[0] = Math.max(Math.round(-M + f / 2), c[0]) : M + f / 2 > o && (c[2] = Math.max(Math.round(M + f / 2 - o), c[2])), x.sideOverflow = t;
                                }
                            }
                        });
                    }));
                }), (0 === hU(c) || this.verifyDataLabelOverflow(c)) && (this.placeDataLabels(), this.points.forEach((e)=>{
                    (e.dataLabels || []).forEach((s)=>{
                        let { connectorColor: o, connectorWidth: r = 1 } = s.options || {}, a = s.dataLabelPosition;
                        if (r) {
                            let n;
                            g = s.connector, a && a.distance > 0 ? (n = !g, g || (s.connector = g = i.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e.colorIndex + (e.className ? " " + e.className : "")).add(t.dataLabelsGroup)), i.styledMode || g.attr({
                                "stroke-width": r,
                                stroke: o || e.color || "#666666"
                            }), g[n ? "attr" : "animate"]({
                                d: e.getConnectorPath(s)
                            }), g.attr({
                                visibility: a.attribs?.visibility
                            })) : g && (s.connector = g.destroy());
                        }
                    });
                })));
            }
            function o() {
                this.points.forEach((t)=>{
                    (t.dataLabels || []).forEach((t)=>{
                        let e = t.dataLabelPosition;
                        e ? (e.sideOverflow && (t.css({
                            width: Math.max(t.getBBox().width - e.sideOverflow, 0) + "px",
                            textOverflow: (t.options?.style || {}).textOverflow || "ellipsis"
                        }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? "animate" : "attr"](e.posAttribs), t.moved = !0) : t && t.attr({
                            y: -9999
                        });
                    }), delete t.distributeBox;
                }, this);
            }
            function r(t) {
                let e = this.center, i = this.options, s = i.center, o = i.minSize || 80, r = o, a = null !== i.size;
                return !a && (null !== s[0] ? r = Math.max(e[2] - Math.max(t[1], t[3]), o) : (r = Math.max(e[2] - t[1] - t[3], o), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? r = h$(r, o, e[2] - Math.max(t[0], t[2])) : (r = h$(r, o, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), r < e[2] ? (e[2] = r, e[3] = Math.min(i.thickness ? Math.max(0, r - 2 * i.thickness) : Math.max(0, hZ(i.innerSize || 0, r)), r), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : a = !0), a;
            }
            t.compose = function(t) {
                if (hs.compose(hj), hq(hF, "PieDataLabel")) {
                    let a = t.prototype;
                    a.dataLabelPositioners = e, a.alignDataLabel = hG, a.drawDataLabels = s, a.getDataLabelPosition = i, a.placeDataLabels = o, a.verifyDataLabelOverflow = r;
                }
            };
        }(m || (m = {}));
        let hK = m;
        !function(t) {
            t.getCenterOfPoints = function(t) {
                let e = t.reduce((t, e)=>(t.x += e.x, t.y += e.y, t), {
                    x: 0,
                    y: 0
                });
                return {
                    x: e.x / t.length,
                    y: e.y / t.length
                };
            }, t.getDistanceBetweenPoints = function(t, e) {
                return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
            }, t.getAngleBetweenPoints = function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y);
            }, t.pointInPolygon = function({ x: t, y: e }, i) {
                let s = i.length, o, r, a = !1;
                for(o = 0, r = s - 1; o < s; r = o++){
                    let [s, n] = i[o], [h, l] = i[r];
                    n > e != l > e && t < (h - s) * (e - n) / (l - n) + s && (a = !a);
                }
                return a;
            };
        }(x || (x = {}));
        let { pointInPolygon: hJ } = x, { addEvent: hQ, fireEvent: h0, objectEach: h1, pick: h2 } = $;
        function h3(t) {
            let e = t.length, i = (t, e)=>!(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y), s = (t, e)=>{
                for (let i of t)if (hJ({
                    x: i[0],
                    y: i[1]
                }, e)) return !0;
                return !1;
            }, o, r, a, n, h, l = !1;
            for(let i = 0; i < e; i++)(o = t[i]) && (o.oldOpacity = o.opacity, o.newOpacity = 1, o.absoluteBox = function(t) {
                if (t && (!t.alignAttr || t.placed)) {
                    let e = t.box ? 0 : t.padding || 0, i = t.alignAttr || {
                        x: t.attr("x"),
                        y: t.attr("y")
                    }, s = t.getBBox();
                    return t.width = s.width, t.height = s.height, {
                        x: i.x + (t.parentGroup?.translateX || 0) + e,
                        y: i.y + (t.parentGroup?.translateY || 0) + e,
                        width: (t.width || 0) - 2 * e,
                        height: (t.height || 0) - 2 * e,
                        polygon: s?.polygon
                    };
                }
            }(o));
            t.sort((t, e)=>(e.labelrank || 0) - (t.labelrank || 0));
            for(let o = 0; o < e; ++o){
                n = (r = t[o]) && r.absoluteBox;
                let l = n?.polygon;
                for(let d = o + 1; d < e; ++d){
                    h = (a = t[d]) && a.absoluteBox;
                    let e = !1;
                    if (n && h && r !== a && 0 !== r.newOpacity && 0 !== a.newOpacity && "hidden" !== r.visibility && "hidden" !== a.visibility) {
                        let t = h.polygon;
                        if (l && t && l !== t ? s(l, t) && (e = !0) : i(n, h) && (e = !0), e) {
                            let t = r.labelrank < a.labelrank ? r : a, e = t.text;
                            t.newOpacity = 0, e?.element.querySelector("textPath") && e.hide();
                        }
                    }
                }
            }
            for (let e of t)h5(e, this) && (l = !0);
            l && h0(this, "afterHideAllOverlappingLabels");
        }
        function h5(t, e) {
            let i, s, o = !1;
            return t && (s = t.newOpacity, t.oldOpacity !== s && (t.hasClass("highcharts-data-label") ? (t[s ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), i = function() {
                e.styledMode || t.css({
                    pointerEvents: s ? "auto" : "none"
                });
            }, o = !0, t[t.isOld ? "animate" : "attr"]({
                opacity: s
            }, void 0, i), h0(e, "afterHideOverlappingLabel")) : t.attr({
                opacity: s
            })), t.isOld = !0), o;
        }
        function h6() {
            let t = this, e = [];
            for (let i of t.labelCollectors || [])e = e.concat(i());
            for (let i of t.yAxis || [])i.stacking && i.options.stackLabels && !i.options.stackLabels.allowOverlap && h1(i.stacking.stacks, (t)=>{
                h1(t, (t)=>{
                    t.label && e.push(t.label);
                });
            });
            for (let i of t.series || [])if (i.visible && i.hasDataLabels?.()) {
                let s = (i)=>{
                    for (let s of i)s.visible && (s.dataLabels || []).forEach((i)=>{
                        let o = i.options || {};
                        i.labelrank = h2(o.labelrank, s.labelrank, s.shapeArgs?.height), o.allowOverlap ?? Number(o.distance) > 0 ? (i.oldOpacity = i.opacity, i.newOpacity = 1, h5(i, t)) : e.push(i);
                    });
                };
                s(i.nodes || []), s(i.points);
            }
            this.hideOverlappingLabels(e);
        }
        let h9 = {
            compose: function(t) {
                let e = t.prototype;
                e.hideOverlappingLabels || (e.hideOverlappingLabels = h3, hQ(t, "render", h6));
            }
        }, { defaultOptions: h4 } = tm, { noop: h8 } = k, { addEvent: h7, extend: lt, isObject: le, merge: li, relativeLength: ls } = $, lo = {
            radius: 0,
            scope: "stack",
            where: void 0
        }, lr = h8, la = h8;
        function ln(t, e, i, s, o = {}) {
            let r = lr(t, e, i, s, o), { innerR: a = 0, r: n = i, start: h = 0, end: l = 0 } = o;
            if (o.open || !o.borderRadius) return r;
            let d = l - h, c = Math.sin(d / 2), p = Math.max(Math.min(ls(o.borderRadius || 0, n - a), (n - a) / 2, n * c / (1 + c)), 0), g = Math.min(p, d / Math.PI * 2 * a), u = r.length - 1;
            for(; u--;)!function(t, e, i) {
                let s, o, r;
                let a = t[e], n = t[e + 1];
                if ("Z" === n[0] && (n = t[0]), ("M" === a[0] || "L" === a[0]) && "A" === n[0] ? (s = a, o = n, r = !0) : "A" === a[0] && ("M" === n[0] || "L" === n[0]) && (s = n, o = a), s && o && o.params) {
                    let a = o[1], n = o[5], h = o.params, { start: l, end: d, cx: c, cy: p } = h, g = n ? a - i : a + i, u = g ? Math.asin(i / g) : 0, f = n ? u : -u, m = Math.cos(u) * g;
                    r ? (h.start = l + f, s[1] = c + m * Math.cos(l), s[2] = p + m * Math.sin(l), t.splice(e + 1, 0, [
                        "A",
                        i,
                        i,
                        0,
                        0,
                        1,
                        c + a * Math.cos(h.start),
                        p + a * Math.sin(h.start)
                    ])) : (h.end = d - f, o[6] = c + a * Math.cos(h.end), o[7] = p + a * Math.sin(h.end), t.splice(e + 1, 0, [
                        "A",
                        i,
                        i,
                        0,
                        0,
                        1,
                        c + m * Math.cos(d),
                        p + m * Math.sin(d)
                    ])), o[4] = Math.abs(h.end - h.start) < Math.PI ? 0 : 1;
                }
            }(r, u, u > 1 ? g : p);
            return r;
        }
        function lh() {
            if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
                let { options: t, yAxis: e } = this, i = "percent" === t.stacking, s = h4.plotOptions?.[this.type]?.borderRadius, o = ll(t.borderRadius, le(s) ? s : {}), r = e.options.reversed;
                for (let s of this.points){
                    let { shapeArgs: a } = s;
                    if ("roundedRect" === s.shapeType && a) {
                        let { width: n = 0, height: h = 0, y: l = 0 } = a, d = l, c = h;
                        if ("stack" === o.scope && s.stackTotal) {
                            let o = e.translate(i ? 100 : s.stackTotal, !1, !0, !1, !0), r = e.translate(t.threshold || 0, !1, !0, !1, !0), a = this.crispCol(0, Math.min(o, r), 0, Math.abs(o - r));
                            d = a.y, c = a.height;
                        }
                        let p = (s.negative ? -1 : 1) * (r ? -1 : 1) == -1, g = o.where;
                        !g && this.is("waterfall") && Math.abs((s.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (g = "all"), g || (g = "end");
                        let u = Math.min(ls(o.radius, n), n / 2, "all" === g ? h / 2 : 1 / 0) || 0;
                        "end" === g && (p && (d -= u), c += u), lt(a, {
                            brBoxHeight: c,
                            brBoxY: d,
                            r: u
                        });
                    }
                }
            }
        }
        function ll(t, e) {
            return le(t) || (t = {
                radius: t || 0
            }), li(lo, e, t);
        }
        function ld() {
            let t = ll(this.options.borderRadius);
            for (let e of this.points){
                let i = e.shapeArgs;
                i && (i.borderRadius = ls(t.radius, (i.r || 0) - (i.innerR || 0)));
            }
        }
        function lc(t, e, i, s, o = {}) {
            let r = la(t, e, i, s, o), { r: a = 0, brBoxHeight: n = s, brBoxY: h = e } = o, l = e - h, d = h + n - (e + s), c = l - a > -.1 ? 0 : a, p = d - a > -.1 ? 0 : a, g = Math.max(c && l, 0), u = Math.max(p && d, 0), f = [
                t + c,
                e
            ], m = [
                t + i - c,
                e
            ], x = [
                t + i,
                e + c
            ], y = [
                t + i,
                e + s - p
            ], b = [
                t + i - p,
                e + s
            ], v = [
                t + p,
                e + s
            ], k = [
                t,
                e + s - p
            ], w = [
                t,
                e + c
            ], M = (t, e)=>Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));
            if (g) {
                let t = M(c, c - g);
                f[0] -= t, m[0] += t, x[1] = w[1] = e + c - g;
            }
            if (s < c - g) {
                let o = M(c, c - g - s);
                x[0] = y[0] = t + i - c + o, b[0] = Math.min(x[0], b[0]), v[0] = Math.max(y[0], v[0]), k[0] = w[0] = t + c - o, x[1] = w[1] = e + s;
            }
            if (u) {
                let t = M(p, p - u);
                b[0] += t, v[0] -= t, y[1] = k[1] = e + s - p + u;
            }
            if (s < p - u) {
                let o = M(p, p - u - s);
                x[0] = y[0] = t + i - p + o, m[0] = Math.min(x[0], m[0]), f[0] = Math.max(y[0], f[0]), k[0] = w[0] = t + p - o, y[1] = k[1] = e;
            }
            return r.length = 0, r.push([
                "M",
                ...f
            ], [
                "L",
                ...m
            ], [
                "A",
                c,
                c,
                0,
                0,
                1,
                ...x
            ], [
                "L",
                ...y
            ], [
                "A",
                p,
                p,
                0,
                0,
                1,
                ...b
            ], [
                "L",
                ...v
            ], [
                "A",
                p,
                p,
                0,
                0,
                1,
                ...k
            ], [
                "L",
                ...w
            ], [
                "A",
                c,
                c,
                0,
                0,
                1,
                ...f
            ], [
                "Z"
            ]), r;
        }
        let { diffObjects: lp, extend: lg, find: lu, merge: lf, pick: lm, uniqueKey: lx } = $;
        !function(t) {
            function e(t, e) {
                let i = t.condition;
                (i.callback || function() {
                    return this.chartWidth <= lm(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= lm(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= lm(i.minWidth, 0) && this.chartHeight >= lm(i.minHeight, 0);
                }).call(this) && e.push(t._id);
            }
            function i(t, e) {
                let i = this.options.responsive, s = this.currentResponsive, o = [], r;
                !e && i && i.rules && i.rules.forEach((t)=>{
                    void 0 === t._id && (t._id = lx()), this.matchResponsiveRule(t, o);
                }, this);
                let a = lf(...o.map((t)=>lu((i || {}).rules || [], (e)=>e._id === t)).map((t)=>t && t.chartOptions));
                a.isResponsiveOptions = !0, o = o.toString() || void 0;
                let n = s && s.ruleIds;
                o === n || (s && (this.currentResponsive = void 0, this.updatingResponsive = !0, this.update(s.undoOptions, t, !0), this.updatingResponsive = !1), o ? ((r = lp(a, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {
                    ruleIds: o,
                    mergedOptions: a,
                    undoOptions: r
                }, this.updatingResponsive || this.update(a, t, !0)) : this.currentResponsive = void 0);
            }
            t.compose = function(t) {
                let s = t.prototype;
                return s.matchResponsiveRule || lg(s, {
                    matchResponsiveRule: e,
                    setResponsive: i
                }), t;
            };
        }(y || (y = {}));
        let ly = y;
        k.AST = tK, k.Axis = sR, k.Chart = aG, k.Color = tk, k.DataLabel = hs, k.DataTableCore = re, k.Fx = tC, k.HTMLElement = iZ, k.Legend = ai, k.LegendSymbol = rr, k.OverlappingDataLabels = k.OverlappingDataLabels || h9, k.PlotLineOrBand = s4, k.Point = oF, k.Pointer = o9, k.RendererRegistry = er, k.Series = rY, k.SeriesRegistry = rd, k.StackItem = a8, k.SVGElement = ej, k.SVGRenderer = iR, k.Templating = eo, k.Tick = sa, k.Time = td, k.Tooltip = ok, k.animate = tR.animate, k.animObject = tR.animObject, k.chart = aG.chart, k.color = tk.parse, k.dateFormat = eo.dateFormat, k.defaultOptions = tm.defaultOptions, k.distribute = ed.distribute, k.format = eo.format, k.getDeferredAnimation = tR.getDeferredAnimation, k.getOptions = tm.getOptions, k.numberFormat = eo.numberFormat, k.seriesType = rd.seriesType, k.setAnimation = tR.setAnimation, k.setOptions = tm.setOptions, k.stop = tR.stop, k.time = tm.defaultTime, k.timers = tC.timers, ({
            compose: function(t, e, i) {
                let s = t.types.pie;
                if (!e.symbolCustomAttribs.includes("borderRadius")) {
                    let o = i.prototype.symbols;
                    h7(t, "afterColumnTranslate", lh, {
                        order: 9
                    }), h7(s, "afterTranslate", ld), e.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), lr = o.arc, la = o.roundedRect, o.arc = ln, o.roundedRect = lc;
                }
            },
            optionsToObject: ll
        }).compose(k.Series, k.SVGElement, k.SVGRenderer), hl.compose(k.Series.types.column), hs.compose(k.Series), sG.compose(k.Axis), iZ.compose(k.SVGRenderer), ai.compose(k.Chart), s$.compose(k.Axis), h9.compose(k.Chart), hK.compose(k.Series.types.pie), s4.compose(k.Chart, k.Axis), o9.compose(k.Chart), ly.compose(k.Chart), a0.compose(k.Axis, k.Chart, k.Series), ny.compose(k.Axis, k.Chart, k.Series), ok.compose(k.Pointer), $.extend(k, $);
        let lb = k;
        return v.default;
    })());
}}),
"[project]/node_modules/highcharts-react-official/dist/highcharts-react.min.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
!function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = e(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)")) : ("TURBOPACK unreachable", undefined);
}("undefined" != typeof self ? self : this, function(t) {
    return function(t) {
        function e(n) {
            if (r[n]) return r[n].exports;
            var o = r[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return t[n].call(o.exports, o, o.exports, e), o.l = !0, o.exports;
        }
        var r = {};
        return e.m = t, e.c = r, e.d = function(t, r, n) {
            e.o(t, r) || Object.defineProperty(t, r, {
                configurable: !1,
                enumerable: !0,
                get: n
            });
        }, e.n = function(t) {
            var r = t && t.__esModule ? function() {
                return t.default;
            } : function() {
                return t;
            };
            return e.d(r, "a", r), r;
        }, e.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e);
        }, e.p = "", e(e.s = 0);
    }([
        function(t, e, r) {
            "use strict";
            function n() {
                return n = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : ("TURBOPACK unreachable", undefined), n.apply(this, arguments);
            }
            function o(t) {
                return a(t) || i(t) || u(t) || c();
            }
            function c() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function u(t, e) {
                if (t) {
                    if ("string" == typeof t) return f(t, e);
                    var r = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? f(t, e) : void 0;
                }
            }
            function i(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }
            function a(t) {
                if (Array.isArray(t)) return f(t);
            }
            function f(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for(var r = 0, n = new Array(e); r < e; r++)n[r] = t[r];
                return n;
            }
            function s(t) {
                "@babel/helpers - typeof";
                return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t;
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                })(t);
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), r.d(e, "HighchartsReact", function() {
                return d;
            });
            var p = r(1), l = r.n(p), y = "undefined" != typeof window ? p.useLayoutEffect : p.useEffect, d = Object(p.memo)(Object(p.forwardRef)(function(t, e) {
                var r = Object(p.useRef)(), c = Object(p.useRef)(), u = Object(p.useRef)(t.constructorType), i = Object(p.useRef)(t.highcharts);
                return y(function() {
                    function e() {
                        var e = t.highcharts || "object" === ("undefined" == typeof window ? "undefined" : s(window)) && window.Highcharts, n = t.constructorType || "chart";
                        e ? e[n] ? t.options ? c.current = e[n](r.current, t.options, t.callback) : console.warn('The "options" property was not passed.') : console.warn('The "constructorType" property is incorrect or some required module is not imported.') : console.warn('The "highcharts" property was not passed.');
                    }
                    if (c.current) {
                        if (!1 !== t.allowChartUpdate) if (t.constructorType !== u.current || t.highcharts !== i.current) u.current = t.constructorType, i.current = t.highcharts, e();
                        else if (!t.immutable && c.current) {
                            var n;
                            (n = c.current).update.apply(n, [
                                t.options
                            ].concat(o(t.updateArgs || [
                                !0,
                                !0
                            ])));
                        } else e();
                    } else e();
                }, [
                    t.options,
                    t.allowChartUpdate,
                    t.updateArgs,
                    t.containerProps,
                    t.highcharts,
                    t.constructorType
                ]), y(function() {
                    return function() {
                        c.current && (c.current.destroy(), c.current = null);
                    };
                }, []), Object(p.useImperativeHandle)(e, function() {
                    return {
                        get chart () {
                            return c.current;
                        },
                        container: r
                    };
                }, []), l.a.createElement("div", n({}, t.containerProps, {
                    ref: r
                }));
            }));
            e.default = d;
        },
        function(e, r) {
            e.exports = t;
        }
    ]);
}); //# sourceMappingURL=highcharts-react.min.js.map
}}),
"[project]/node_modules/highcharts/modules/map.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
!/**
 * Highcharts JS v12.1.2 (2024-12-21)
 * @module highcharts/modules/color-axis
 * @requires highcharts
 *
 * ColorAxis module
 *
 * (c) 2012-2024 Pawel Potaczek
 *
 * License: www.highcharts.com/license
 */ function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = e(t._Highcharts, t._Highcharts.Axis, t._Highcharts.Color, t._Highcharts.LegendSymbol, t._Highcharts.SeriesRegistry, t._Highcharts.SVGElement, t._Highcharts.Series, t._Highcharts.Chart, t._Highcharts.SVGRenderer, t._Highcharts.Templating, t._Highcharts.Series.types.scatter, t._Highcharts.Point) : ("TURBOPACK unreachable", undefined);
}("undefined" == typeof window ? this : window, (t, e, i, s, o, r, a, n, l, h, p, d)=>(()=>{
        "use strict";
        let c;
        var u, m, g, f, b, y, x, M = {
            532: (t)=>{
                t.exports = e;
            },
            960: (t)=>{
                t.exports = n;
            },
            620: (t)=>{
                t.exports = i;
            },
            500: (t)=>{
                t.exports = s;
            },
            260: (t)=>{
                t.exports = d;
            },
            28: (t)=>{
                t.exports = r;
            },
            540: (t)=>{
                t.exports = l;
            },
            632: (t)=>{
                t.exports = p;
            },
            820: (t)=>{
                t.exports = a;
            },
            512: (t)=>{
                t.exports = o;
            },
            984: (t)=>{
                t.exports = h;
            },
            944: (e)=>{
                e.exports = t;
            }
        }, v = {};
        function w(t) {
            var e = v[t];
            if (void 0 !== e) return e.exports;
            var i = v[t] = {
                exports: {}
            };
            return M[t](i, i.exports, w), i.exports;
        }
        w.n = (t)=>{
            var e = t && t.__esModule ? ()=>t.default : ()=>t;
            return w.d(e, {
                a: e
            }), e;
        }, w.d = (t, e)=>{
            for(var i in e)w.o(e, i) && !w.o(t, i) && Object.defineProperty(t, i, {
                enumerable: !0,
                get: e[i]
            });
        }, w.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e);
        var C = {};
        w.d(C, {
            default: ()=>sD
        });
        var T = w(944), L = w.n(T), P = w(532), A = w.n(P), k = w(620), j = w.n(k);
        let { parse: z } = j(), { addEvent: S, extend: I, merge: B, pick: E, splat: D } = L();
        !function(t) {
            let e;
            function i() {
                let { userOptions: t } = this;
                this.colorAxis = [], t.colorAxis && (t.colorAxis = D(t.colorAxis), t.colorAxis.map((t)=>new e(this, t)));
            }
            function s(t) {
                let e = this.chart.colorAxis || [], i = (e)=>{
                    let i = t.allItems.indexOf(e);
                    -1 !== i && (this.destroyItem(t.allItems[i]), t.allItems.splice(i, 1));
                }, s = [], o, r;
                for(e.forEach(function(t) {
                    (o = t.options) && o.showInLegend && (o.dataClasses && o.visible ? s = s.concat(t.getDataClassLegendSymbols()) : o.visible && s.push(t), t.series.forEach(function(t) {
                        (!t.options.showInLegend || o.dataClasses) && ("point" === t.options.legendType ? t.points.forEach(function(t) {
                            i(t);
                        }) : i(t));
                    }));
                }), r = s.length; r--;)t.allItems.unshift(s[r]);
            }
            function o(t) {
                t.visible && t.item.legendColor && t.item.legendItem.symbol.attr({
                    fill: t.item.legendColor
                });
            }
            function r(t) {
                this.chart.colorAxis?.forEach((e)=>{
                    e.update({}, t.redraw);
                });
            }
            function a() {
                (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
            }
            function n() {
                let t = this.axisTypes;
                t ? -1 === t.indexOf("colorAxis") && t.push("colorAxis") : this.axisTypes = [
                    "colorAxis"
                ];
            }
            function l(t) {
                let e = this, i = t ? "show" : "hide";
                e.visible = e.options.visible = !!t, [
                    "graphic",
                    "dataLabel"
                ].forEach(function(t) {
                    e[t] && e[t][i]();
                }), this.series.buildKDTree();
            }
            function h() {
                let t = this, e = this.getPointsCollection(), i = this.options.nullColor, s = this.colorAxis, o = this.colorKey;
                e.forEach((e)=>{
                    let r = e.getNestedProperty(o), a = e.options.color || (e.isNull || null === e.value ? i : s && void 0 !== r ? s.toColor(r, e) : e.color || t.color);
                    a && e.color !== a && (e.color = a, "point" === t.options.legendType && e.legendItem && e.legendItem.label && t.chart.legend.colorizeItem(e, e.visible));
                });
            }
            function p() {
                this.elem.attr("fill", z(this.start).tweenTo(z(this.end), this.pos), void 0, !0);
            }
            function d() {
                this.elem.attr("stroke", z(this.start).tweenTo(z(this.end), this.pos), void 0, !0);
            }
            t.compose = function(t, c, u, m, g) {
                let f = c.prototype, b = u.prototype, y = g.prototype;
                f.collectionsWithUpdate.includes("colorAxis") || (e = t, f.collectionsWithUpdate.push("colorAxis"), f.collectionsWithInit.colorAxis = [
                    f.addColorAxis
                ], S(c, "afterCreateAxes", i), function(t) {
                    let i = t.prototype.createAxis;
                    t.prototype.createAxis = function(t, s) {
                        if ("colorAxis" !== t) return i.apply(this, arguments);
                        let o = new e(this, B(s.axis, {
                            index: this[t].length,
                            isX: !1
                        }));
                        return this.isDirtyLegend = !0, this.axes.forEach((t)=>{
                            t.series = [];
                        }), this.series.forEach((t)=>{
                            t.bindAxes(), t.isDirtyData = !0;
                        }), E(s.redraw, !0) && this.redraw(s.animation), o;
                    };
                }(c), b.fillSetter = p, b.strokeSetter = d, S(m, "afterGetAllItems", s), S(m, "afterColorizeItem", o), S(m, "afterUpdate", r), I(y, {
                    optionalAxis: "colorAxis",
                    translateColors: h
                }), I(y.pointClass.prototype, {
                    setVisible: l
                }), S(g, "afterTranslate", a, {
                    order: 1
                }), S(g, "bindAxes", n));
            }, t.pointSetVisible = l;
        }(u || (u = {}));
        let V = u, { parse: O } = j(), { merge: N } = L();
        !function(t) {
            t.initDataClasses = function(t) {
                let e = this.chart, i = this.legendItem = this.legendItem || {}, s = this.options, o = t.dataClasses || [], r, a, n = e.options.chart.colorCount, l = 0, h;
                this.dataClasses = a = [], i.labels = [];
                for(let t = 0, i = o.length; t < i; ++t)r = N(r = o[t]), a.push(r), (e.styledMode || !r.color) && ("category" === s.dataClassColor ? (e.styledMode || (n = (h = e.options.colors || []).length, r.color = h[l]), r.colorIndex = l, ++l === n && (l = 0)) : r.color = O(s.minColor).tweenTo(O(s.maxColor), i < 2 ? .5 : t / (i - 1)));
            }, t.initStops = function() {
                let t = this.options, e = this.stops = t.stops || [
                    [
                        0,
                        t.minColor || ""
                    ],
                    [
                        1,
                        t.maxColor || ""
                    ]
                ];
                for(let t = 0, i = e.length; t < i; ++t)e[t].color = O(e[t][1]);
            }, t.normalizedValue = function(t) {
                let e = this.max || 0, i = this.min || 0;
                return this.logarithmic && (t = this.logarithmic.log2lin(t)), 1 - (e - t) / (e - i || 1);
            }, t.toColor = function(t, e) {
                let i, s, o, r, a, n;
                let l = this.dataClasses, h = this.stops;
                if (l) {
                    for(n = l.length; n--;)if (s = (a = l[n]).from, o = a.to, (void 0 === s || t >= s) && (void 0 === o || t <= o)) {
                        r = a.color, e && (e.dataClass = n, e.colorIndex = a.colorIndex);
                        break;
                    }
                } else {
                    for(i = this.normalizedValue(t), n = h.length; n-- && !(i > h[n][0]););
                    s = h[n] || h[n + 1], i = 1 - ((o = h[n + 1] || s)[0] - i) / (o[0] - s[0] || 1), r = s.color.tweenTo(o.color, i);
                }
                return r;
            };
        }(m || (m = {}));
        let G = m;
        var X = w(500), R = w.n(X), H = w(512), W = w.n(H);
        let { defaultOptions: Y } = L(), { series: U } = W(), { defined: F, extend: Z, fireEvent: _, isArray: K, isNumber: q, merge: $, pick: J, relativeLength: Q } = L();
        Y.colorAxis = $(Y.xAxis, {
            lineWidth: 0,
            minPadding: 0,
            maxPadding: 0,
            gridLineColor: "#ffffff",
            gridLineWidth: 1,
            tickPixelInterval: 72,
            startOnTick: !0,
            endOnTick: !0,
            offset: 0,
            marker: {
                animation: {
                    duration: 50
                },
                width: .01,
                color: "#999999"
            },
            labels: {
                distance: 8,
                overflow: "justify",
                rotation: 0
            },
            minColor: "#e6e9ff",
            maxColor: "#0022ff",
            tickLength: 5,
            showInLegend: !0
        });
        class tt extends A() {
            static compose(t, e, i, s) {
                V.compose(tt, t, e, i, s);
            }
            constructor(t, e){
                super(t, e), this.coll = "colorAxis", this.visible = !0, this.init(t, e);
            }
            init(t, e) {
                let i = t.options.legend || {}, s = e.layout ? "vertical" !== e.layout : "vertical" !== i.layout;
                this.side = e.side || s ? 2 : 1, this.reversed = e.reversed || !s, this.opposite = !s, super.init(t, e, "colorAxis"), this.userOptions = e, K(t.userOptions.colorAxis) && (t.userOptions.colorAxis[this.index] = e), e.dataClasses && this.initDataClasses(e), this.initStops(), this.horiz = s, this.zoomEnabled = !1;
            }
            hasData() {
                return !!(this.tickPositions || []).length;
            }
            setTickPositions() {
                if (!this.dataClasses) return super.setTickPositions();
            }
            setOptions(t) {
                let e = $(Y.colorAxis, t, {
                    showEmpty: !1,
                    title: null,
                    visible: this.chart.options.legend.enabled && !1 !== t.visible
                });
                super.setOptions(e), this.options.crosshair = this.options.marker;
            }
            setAxisSize() {
                let t = this.chart, e = this.legendItem?.symbol, { width: i, height: s } = this.getSize();
                e && (this.left = +e.attr("x"), this.top = +e.attr("y"), this.width = i = +e.attr("width"), this.height = s = +e.attr("height"), this.right = t.chartWidth - this.left - i, this.bottom = t.chartHeight - this.top - s, this.pos = this.horiz ? this.left : this.top), this.len = (this.horiz ? i : s) || tt.defaultLegendLength;
            }
            getOffset() {
                let t = this.legendItem?.group, e = this.chart.axisOffset[this.side];
                if (t) {
                    this.axisParent = t, super.getOffset();
                    let i = this.chart.legend;
                    i.allItems.forEach(function(t) {
                        t instanceof tt && t.drawLegendSymbol(i, t);
                    }), i.render(), this.chart.getMargins(!0), this.chart.series.some((t)=>t.isDrilling) || (this.isDirty = !0), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = e;
                }
            }
            setLegendColor() {
                let t = this.horiz, e = this.reversed, i = e ? 1 : 0, s = e ? 0 : 1, o = t ? [
                    i,
                    0,
                    s,
                    0
                ] : [
                    0,
                    s,
                    0,
                    i
                ];
                this.legendColor = {
                    linearGradient: {
                        x1: o[0],
                        y1: o[1],
                        x2: o[2],
                        y2: o[3]
                    },
                    stops: this.stops
                };
            }
            drawLegendSymbol(t, e) {
                let i = e.legendItem || {}, s = t.padding, o = t.options, r = this.options.labels, a = J(o.itemDistance, 10), n = this.horiz, { width: l, height: h } = this.getSize(), p = J(o.labelPadding, n ? 16 : 30);
                this.setLegendColor(), i.symbol || (i.symbol = this.chart.renderer.symbol("roundedRect").attr({
                    r: o.symbolRadius ?? 3,
                    zIndex: 1
                }).add(i.group)), i.symbol.attr({
                    x: 0,
                    y: (t.baseline || 0) - 11,
                    width: l,
                    height: h
                }), i.labelWidth = l + s + (n ? a : J(r.x, r.distance) + (this.maxLabelLength || 0)), i.labelHeight = h + s + (n ? p : 0);
            }
            setState(t) {
                this.series.forEach(function(e) {
                    e.setState(t);
                });
            }
            setVisible() {}
            getSeriesExtremes() {
                let t = this.series, e, i, s, o, r = t.length;
                for(this.dataMin = 1 / 0, this.dataMax = -1 / 0; r--;){
                    for (let a of (i = (o = t[r]).colorKey = J(o.options.colorKey, o.colorKey, o.pointValKey, o.zoneAxis, "y"), s = o[i + "Min"] && o[i + "Max"], [
                        i,
                        "value",
                        "y"
                    ]))if ((e = o.getColumn(a)).length) break;
                    if (s) o.minColorValue = o[i + "Min"], o.maxColorValue = o[i + "Max"];
                    else {
                        let t = U.prototype.getExtremes.call(o, e);
                        o.minColorValue = t.dataMin, o.maxColorValue = t.dataMax;
                    }
                    F(o.minColorValue) && F(o.maxColorValue) && (this.dataMin = Math.min(this.dataMin, o.minColorValue), this.dataMax = Math.max(this.dataMax, o.maxColorValue)), s || U.prototype.applyExtremes.call(o);
                }
            }
            drawCrosshair(t, e) {
                let i;
                let s = this.legendItem || {}, o = e && e.plotX, r = e && e.plotY, a = this.pos, n = this.len;
                e && ((i = this.toPixels(e.getNestedProperty(e.series.colorKey))) < a ? i = a - 2 : i > a + n && (i = a + n + 2), e.plotX = i, e.plotY = this.len - i, super.drawCrosshair(t, e), e.plotX = o, e.plotY = r, this.cross && !this.cross.addedToColorAxis && s.group && (this.cross.addClass("highcharts-coloraxis-marker").add(s.group), this.cross.addedToColorAxis = !0, this.chart.styledMode || "object" != typeof this.crosshair || this.cross.attr({
                    fill: this.crosshair.color
                })));
            }
            getPlotLinePath(t) {
                let e = this.left, i = t.translatedValue, s = this.top;
                return q(i) ? this.horiz ? [
                    [
                        "M",
                        i - 4,
                        s - 6
                    ],
                    [
                        "L",
                        i + 4,
                        s - 6
                    ],
                    [
                        "L",
                        i,
                        s
                    ],
                    [
                        "Z"
                    ]
                ] : [
                    [
                        "M",
                        e,
                        i
                    ],
                    [
                        "L",
                        e - 6,
                        i + 6
                    ],
                    [
                        "L",
                        e - 6,
                        i - 6
                    ],
                    [
                        "Z"
                    ]
                ] : super.getPlotLinePath(t);
            }
            update(t, e) {
                let i = this.chart.legend;
                this.series.forEach((t)=>{
                    t.isDirtyData = !0;
                }), (t.dataClasses && i.allItems || this.dataClasses) && this.destroyItems(), super.update(t, e), this.legendItem && this.legendItem.label && (this.setLegendColor(), i.colorizeItem(this, !0));
            }
            destroyItems() {
                let t = this.chart, e = this.legendItem || {};
                if (e.label) t.legend.destroyItem(this);
                else if (e.labels) for (let i of e.labels)t.legend.destroyItem(i);
                t.isDirtyLegend = !0;
            }
            destroy() {
                this.chart.isDirtyLegend = !0, this.destroyItems(), super.destroy(...[].slice.call(arguments));
            }
            remove(t) {
                this.destroyItems(), super.remove(t);
            }
            getDataClassLegendSymbols() {
                let t;
                let e = this, i = e.chart, s = e.legendItem && e.legendItem.labels || [], o = i.options.legend, r = J(o.valueDecimals, -1), a = J(o.valueSuffix, ""), n = (t)=>e.series.reduce((e, i)=>(e.push(...i.points.filter((e)=>e.dataClass === t)), e), []);
                return s.length || e.dataClasses.forEach((o, l)=>{
                    let h = o.from, p = o.to, { numberFormatter: d } = i, c = !0;
                    t = "", void 0 === h ? t = "< " : void 0 === p && (t = "> "), void 0 !== h && (t += d(h, r) + a), void 0 !== h && void 0 !== p && (t += " - "), void 0 !== p && (t += d(p, r) + a), s.push(Z({
                        chart: i,
                        name: t,
                        options: {},
                        drawLegendSymbol: R().rectangle,
                        visible: !0,
                        isDataClass: !0,
                        setState: (t)=>{
                            for (let e of n(l))e.setState(t);
                        },
                        setVisible: function() {
                            this.visible = c = e.visible = !c;
                            let t = [];
                            for (let e of n(l))e.setVisible(c), e.hiddenInDataClass = !c, -1 === t.indexOf(e.series) && t.push(e.series);
                            i.legend.colorizeItem(this, c), t.forEach((t)=>{
                                _(t, "afterDataClassLegendClick");
                            });
                        }
                    }, o));
                }), s;
            }
            getSize() {
                let { chart: t, horiz: e } = this, { height: i, width: s } = this.options, { legend: o } = t.options;
                return {
                    width: J(F(s) ? Q(s, t.chartWidth) : void 0, o?.symbolWidth, e ? tt.defaultLegendLength : 12),
                    height: J(F(i) ? Q(i, t.chartHeight) : void 0, o?.symbolHeight, e ? 12 : tt.defaultLegendLength)
                };
            }
        }
        tt.defaultLegendLength = 200, tt.keepProps = [
            "legendItem"
        ], Z(tt.prototype, G), Array.prototype.push.apply(A().keepProps, tt.keepProps);
        let te = L();
        te.ColorAxis = te.ColorAxis || tt, te.ColorAxis.compose(te.Chart, te.Fx, te.Legend, te.Series);
        let ti = {
            lang: {
                zoomIn: "Zoom in",
                zoomOut: "Zoom out"
            },
            mapNavigation: {
                buttonOptions: {
                    alignTo: "plotBox",
                    align: "left",
                    verticalAlign: "top",
                    x: 0,
                    width: 18,
                    height: 18,
                    padding: 5,
                    style: {
                        color: "#666666",
                        fontSize: "1em",
                        fontWeight: "bold"
                    },
                    theme: {
                        fill: "#ffffff",
                        stroke: "#e6e6e6",
                        "stroke-width": 1,
                        "text-align": "center"
                    }
                },
                buttons: {
                    zoomIn: {
                        onclick: function() {
                            this.mapZoom(.5);
                        },
                        text: "+",
                        y: 0
                    },
                    zoomOut: {
                        onclick: function() {
                            this.mapZoom(2);
                        },
                        text: "-",
                        y: 28
                    }
                },
                mouseWheelSensitivity: 1.1
            }
        }, { defined: ts, extend: to, pick: tr, wrap: ta } = L();
        !function(t) {
            let e, i = 0;
            function s(t) {
                let e = this.chart;
                t = this.normalize(t), e.options.mapNavigation.enableDoubleClickZoomTo ? e.pointer.inClass(t.target, "highcharts-tracker") && e.hoverPoint && e.hoverPoint.zoomTo() : e.isInsidePlot(t.chartX - e.plotLeft, t.chartY - e.plotTop) && e.mapZoom(.5, void 0, void 0, t.chartX, t.chartY);
            }
            function o(t) {
                let s = this.chart, o = ts((t = this.normalize(t)).wheelDelta) && -t.wheelDelta / 120 || t.deltaY || t.detail;
                Math.abs(o) >= 1 && (i += Math.abs(o), e && clearTimeout(e), e = setTimeout(()=>{
                    i = 0;
                }, 50)), i < 10 && s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop) && s.mapView && s.mapView.zoomBy(-((s.options.mapNavigation.mouseWheelSensitivity - 1) * o), void 0, [
                    t.chartX,
                    t.chartY
                ], !(1 > Math.abs(o)) && void 0);
            }
            function r(t, e, i) {
                let s = this.chart;
                if (e = t.call(this, e, i), s && s.mapView) {
                    let t = s.mapView.pixelsToLonLat({
                        x: e.chartX - s.plotLeft,
                        y: e.chartY - s.plotTop
                    });
                    t && to(e, t);
                }
                return e;
            }
            function a(t) {
                let e = this.chart.options.mapNavigation;
                e && tr(e.enableTouchZoom, e.enabled) && (this.chart.zooming.pinchType = "xy"), t.apply(this, [].slice.call(arguments, 1));
            }
            t.compose = function(t) {
                let e = t.prototype;
                e.onContainerDblClick || (to(e, {
                    onContainerDblClick: s,
                    onContainerMouseWheel: o
                }), ta(e, "normalize", r), ta(e, "zoomOption", a));
            };
        }(g || (g = {}));
        let tn = g;
        function tl(t, e, i, s, o) {
            if (o) {
                let t = o?.r || 0;
                o.brBoxY = e - t, o.brBoxHeight = s + t;
            }
            return c.roundedRect(t, e, i, s, o);
        }
        function th(t, e, i, s, o) {
            if (o) {
                let t = o?.r || 0;
                o.brBoxHeight = s + t;
            }
            return c.roundedRect(t, e, i, s, o);
        }
        let tp = {
            compose: function(t) {
                (c = t.prototype.symbols).bottombutton = tl, c.topbutton = th;
            }
        }, { setOptions: td } = L(), { composed: tc } = L(), { addEvent: tu, extend: tm, merge: tg, objectEach: tf, pick: tb, pushUnique: ty } = L();
        function tx(t) {
            t && (t.preventDefault?.(), t.stopPropagation?.(), t.cancelBubble = !0);
        }
        class tM {
            static compose(t, e, i) {
                tn.compose(e), tp.compose(i), ty(tc, "Map.Navigation") && (tu(t, "beforeRender", function() {
                    this.mapNavigation = new tM(this), this.mapNavigation.update();
                }), td(ti));
            }
            constructor(t){
                this.chart = t, this.navButtons = [];
            }
            update(t) {
                let e = this, i = e.chart, s = e.navButtons, o = function(t) {
                    this.handler.call(i, t), tx(t);
                }, r = i.options.mapNavigation;
                for(t && (r = i.options.mapNavigation = tg(i.options.mapNavigation, t)); s.length;)s.pop()?.destroy();
                if (!i.renderer.forExport && tb(r.enableButtons, r.enabled)) {
                    e.navButtonsGroup || (e.navButtonsGroup = i.renderer.g().attr({
                        zIndex: 7
                    }).add()), tf(r.buttons, (t, a)=>{
                        let n = {
                            padding: (t = tg(r.buttonOptions, t)).padding
                        };
                        !i.styledMode && t.theme && (tm(n, t.theme), n.style = tg(t.theme.style, t.style));
                        let { text: l, width: h = 0, height: p = 0, padding: d = 0 } = t, c = i.renderer.button("+" !== l && "-" !== l && l || "", 0, 0, o, n, void 0, void 0, void 0, "zoomIn" === a ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + ({
                            zoomIn: "zoom-in",
                            zoomOut: "zoom-out"
                        })[a]).attr({
                            width: h,
                            height: p,
                            title: i.options.lang[a],
                            zIndex: 5
                        }).add(e.navButtonsGroup);
                        if ("+" === l || "-" === l) {
                            let e = h + 1, s = [
                                [
                                    "M",
                                    d + 3,
                                    d + p / 2
                                ],
                                [
                                    "L",
                                    d + e - 3,
                                    d + p / 2
                                ]
                            ];
                            "+" === l && s.push([
                                "M",
                                d + e / 2,
                                d + 3
                            ], [
                                "L",
                                d + e / 2,
                                d + p - 3
                            ]), i.renderer.path(s).addClass("highcharts-button-symbol").attr(i.styledMode ? {} : {
                                stroke: t.style?.color,
                                "stroke-width": 3,
                                "stroke-linecap": "round"
                            }).add(c);
                        }
                        if (c.handler = t.onclick, tu(c.element, "dblclick", tx), s.push(c), tm(t, {
                            width: c.width,
                            height: 2 * (c.height || 0)
                        }), i.hasLoaded) c.align(t, !1, t.alignTo);
                        else {
                            let e = tu(i, "load", ()=>{
                                c.element && c.align(t, !1, t.alignTo), e();
                            });
                        }
                    });
                    let t = (t, e)=>!(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y);
                    i.hasLoaded || tu(i, "render", function() {
                        let s = i.exportingGroup?.getBBox();
                        if (s) {
                            let i = e.navButtonsGroup.getBBox();
                            if (t(s, i)) {
                                let t = -i.y - i.height + s.y - 5, o = s.y + s.height - i.y + 5, a = r.buttonOptions && r.buttonOptions.verticalAlign;
                                e.navButtonsGroup.attr({
                                    translateY: "bottom" === a ? t : o
                                });
                            }
                        }
                    });
                }
                this.updateEvents(r);
            }
            updateEvents(t) {
                let e = this.chart;
                tb(t.enableDoubleClickZoom, t.enabled) || t.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || tu(e.container, "dblclick", function(t) {
                    e.pointer.onContainerDblClick(t);
                }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick()), tb(t.enableMouseWheelZoom, t.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || tu(e.container, "wheel", function(t) {
                    if (!e.pointer.inClass(t.target, "highcharts-no-mousewheel")) {
                        let i = e.mapView?.zoom;
                        e.pointer.onContainerMouseWheel(t), i !== e.mapView?.zoom && tx(t);
                    }
                    return !1;
                }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());
            }
        }
        var tv = w(28), tw = w.n(tv);
        let { column: { prototype: tC } } = W().seriesTypes, { addEvent: tT, defined: tL } = L();
        !function(t) {
            function e(t) {
                let e = this.series, i = e.chart.renderer;
                this.moveToTopOnHover && this.graphic && (e.stateMarkerGraphic || (e.stateMarkerGraphic = new (tw())(i, "use").css({
                    pointerEvents: "none"
                }).add(this.graphic.parentGroup)), t?.state === "hover" ? (this.graphic.attr({
                    id: this.id
                }), e.stateMarkerGraphic.attr({
                    href: `${i.url}#${this.id}`,
                    visibility: "visible"
                })) : e.stateMarkerGraphic.attr({
                    href: ""
                }));
            }
            t.pointMembers = {
                dataLabelOnNull: !0,
                moveToTopOnHover: !0,
                isValid: function() {
                    return null !== this.value && this.value !== 1 / 0 && this.value !== -1 / 0 && (void 0 === this.value || !isNaN(this.value));
                }
            }, t.seriesMembers = {
                colorKey: "value",
                axisTypes: [
                    "xAxis",
                    "yAxis",
                    "colorAxis"
                ],
                parallelArrays: [
                    "x",
                    "y",
                    "value"
                ],
                pointArrayMap: [
                    "value"
                ],
                trackerGroups: [
                    "group",
                    "markerGroup",
                    "dataLabelsGroup"
                ],
                colorAttribs: function(t) {
                    let e = {};
                    return tL(t.color) && (!t.state || "normal" === t.state) && (e[this.colorProp || "fill"] = t.color), e;
                },
                pointAttribs: tC.pointAttribs
            }, t.compose = function(t) {
                return tT(t.prototype.pointClass, "afterSetState", e), t;
            };
        }(f || (f = {}));
        let tP = f;
        var tA = w(820), tk = w.n(tA);
        let { deg2rad: tj } = L(), { fireEvent: tz, isNumber: tS, pick: tI, relativeLength: tB } = L();
        !function(t) {
            t.getCenter = function() {
                let t = this.options, e = this.chart, i = 2 * (t.slicedOffset || 0), s = e.plotWidth - 2 * i, o = e.plotHeight - 2 * i, r = t.center, a = Math.min(s, o), n = t.thickness, l, h = t.size, p = t.innerSize || 0, d, c;
                "string" == typeof h && (h = parseFloat(h)), "string" == typeof p && (p = parseFloat(p));
                let u = [
                    tI(r?.[0], "50%"),
                    tI(r?.[1], "50%"),
                    tI(h && h < 0 ? void 0 : t.size, "100%"),
                    tI(p && p < 0 ? void 0 : t.innerSize || 0, "0%")
                ];
                for(!e.angular || this instanceof tk() || (u[3] = 0), d = 0; d < 4; ++d)c = u[d], l = d < 2 || 2 === d && /%$/.test(c), u[d] = tB(c, [
                    s,
                    o,
                    a,
                    u[2]
                ][d]) + (l ? i : 0);
                return u[3] > u[2] && (u[3] = u[2]), tS(n) && 2 * n < u[2] && n > 0 && (u[3] = u[2] - 2 * n), tz(this, "afterGetCenter", {
                    positions: u
                }), u;
            }, t.getStartAndEndRadians = function(t, e) {
                let i = tS(t) ? t : 0, s = tS(e) && e > i && e - i < 360 ? e : i + 360;
                return {
                    start: tj * (i + -90),
                    end: tj * (s + -90)
                };
            };
        }(b || (b = {}));
        let tE = b;
        var tD = w(960), tV = w.n(tD), tO = w(540), tN = w.n(tO);
        let { getOptions: tG } = L(), { isNumber: tX, merge: tR, pick: tH } = L();
        class tW extends tV() {
            init(t, e) {
                let i = tG().credits, s = tR({
                    chart: {
                        panning: {
                            enabled: !0,
                            type: "xy"
                        },
                        type: "map"
                    },
                    credits: {
                        mapText: tH(i.mapText, ' \xa9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'),
                        mapTextFull: tH(i.mapTextFull, "{geojson.copyright}")
                    },
                    mapView: {},
                    tooltip: {
                        followTouchMove: !1
                    }
                }, t);
                super.init(s, e);
            }
            mapZoom(t, e, i, s, o) {
                this.mapView && (tX(t) && (t = Math.log(t) / Math.log(.5)), this.mapView.zoomBy(t, tX(e) && tX(i) ? this.mapView.projection.inverse([
                    e,
                    i
                ]) : void 0, tX(s) && tX(o) ? [
                    s,
                    o
                ] : void 0));
            }
            update(t) {
                t.chart && "map" in t.chart && this.mapView?.recommendMapView(this, [
                    t.chart.map,
                    ...(this.options.series || []).map((t)=>t.mapData)
                ], !0), super.update.apply(this, arguments);
            }
        }
        !function(t) {
            t.maps = {}, t.mapChart = function(e, i, s) {
                return new t(e, i, s);
            }, t.splitPath = function(t) {
                let e;
                return e = "string" == typeof t ? (t = t.replace(/([A-Z])/gi, " $1 ").replace(/^\s*/, "").replace(/\s*$/, "")).split(/[ ,;]+/).map((t)=>/[A-Z]/i.test(t) ? t : parseFloat(t)) : t, tN().prototype.pathToSegments(e);
            };
        }(tW || (tW = {}));
        let tY = tW, tU = {
            boundsFromPath: function(t) {
                let e = -Number.MAX_VALUE, i = Number.MAX_VALUE, s = -Number.MAX_VALUE, o = Number.MAX_VALUE, r;
                if (t.forEach((t)=>{
                    let a = t[t.length - 2], n = t[t.length - 1];
                    "number" == typeof a && "number" == typeof n && (i = Math.min(i, a), e = Math.max(e, a), o = Math.min(o, n), s = Math.max(s, n), r = !0);
                }), r) return {
                    x1: i,
                    y1: o,
                    x2: e,
                    y2: s
                };
            }
        }, { boundsFromPath: tF } = tU, tZ = W().seriesTypes.scatter.prototype.pointClass, { extend: t_, isNumber: tK, pick: tq } = L();
        class t$ extends tZ {
            static getProjectedPath(t, e) {
                return t.projectedPath || (e && t.geometry ? (e.hasCoordinates = !0, t.projectedPath = e.path(t.geometry)) : t.projectedPath = t.path), t.projectedPath || [];
            }
            applyOptions(t, e) {
                let i = this.series, s = super.applyOptions(t, e), o = i.joinBy;
                if (i.mapData && i.mapMap) {
                    let t = o[1], e = super.getNestedProperty(t), r = void 0 !== e && i.mapMap[e];
                    r ? t_(s, {
                        ...r,
                        name: s.name ?? r.name
                    }) : -1 !== i.pointArrayMap.indexOf("value") && (s.value = s.value || null);
                }
                return s;
            }
            getProjectedBounds(t) {
                let e = tF(t$.getProjectedPath(this, t)), i = this.properties, s = this.series.chart.mapView;
                if (e) {
                    let o = i && i["hc-middle-lon"], r = i && i["hc-middle-lat"];
                    if (s && tK(o) && tK(r)) {
                        let i = t.forward([
                            o,
                            r
                        ]);
                        e.midX = i[0], e.midY = i[1];
                    } else {
                        let t = i && i["hc-middle-x"], s = i && i["hc-middle-y"];
                        e.midX = e.x1 + (e.x2 - e.x1) * tq(this.middleX, tK(t) ? t : .5);
                        let o = tq(this.middleY, tK(s) ? s : .5);
                        this.geometry || (o = 1 - o), e.midY = e.y2 - (e.y2 - e.y1) * o;
                    }
                    return e;
                }
            }
            onMouseOver(t) {
                L().clearTimeout(this.colorInterval), !this.isNull && this.visible || this.series.options.nullInteraction ? super.onMouseOver.call(this, t) : this.series.onMouseOut();
            }
            setVisible(t) {
                this.visible = this.options.visible = !!t, this.dataLabel && this.dataLabel[t ? "show" : "hide"](), this.graphic && this.graphic.attr(this.series.pointAttribs(this));
            }
            zoomTo(t) {
                let e = this.series.chart, i = e.mapView, s = this.bounds;
                if (i && s) {
                    let o = tK(this.insetIndex) && i.insets[this.insetIndex];
                    if (o) {
                        let t = o.projectedUnitsToPixels({
                            x: s.x1,
                            y: s.y1
                        }), e = o.projectedUnitsToPixels({
                            x: s.x2,
                            y: s.y2
                        }), r = i.pixelsToProjectedUnits({
                            x: t.x,
                            y: t.y
                        }), a = i.pixelsToProjectedUnits({
                            x: e.x,
                            y: e.y
                        });
                        s = {
                            x1: r.x,
                            y1: r.y,
                            x2: a.x,
                            y2: a.y
                        };
                    }
                    i.fitToBounds(s, void 0, !1), this.series.isDirty = !0, e.redraw(t);
                }
            }
        }
        t_(t$.prototype, {
            dataLabelOnNull: tP.pointMembers.dataLabelOnNull,
            moveToTopOnHover: tP.pointMembers.moveToTopOnHover,
            isValid: tP.pointMembers.isValid
        });
        let { isNumber: tJ } = L(), tQ = {
            center: [
                0,
                0
            ],
            fitToGeometry: void 0,
            maxZoom: void 0,
            padding: 0,
            projection: {
                name: void 0,
                parallels: void 0,
                rotation: void 0
            },
            zoom: void 0,
            insetOptions: {
                borderColor: "#cccccc",
                borderWidth: 1,
                padding: "10%",
                relativeTo: "mapBoundingBox",
                units: "percent"
            }
        };
        var t0 = w(984), t1 = w.n(t0);
        let { win: t2 } = L(), { format: t6 } = t1(), { error: t3, extend: t8, merge: t7, wrap: t9 } = L();
        !function(t) {
            function e(t) {
                return this.mapView && this.mapView.lonLatToProjectedUnits(t);
            }
            function i(t) {
                return this.mapView && this.mapView.projectedUnitsToLonLat(t);
            }
            function s(t, e) {
                let i = this.options.chart.proj4 || t2.proj4;
                if (!i) {
                    t3(21, !1, this);
                    return;
                }
                let { jsonmarginX: s = 0, jsonmarginY: o = 0, jsonres: r = 1, scale: a = 1, xoffset: n = 0, xpan: l = 0, yoffset: h = 0, ypan: p = 0 } = e, d = i(e.crs, [
                    t.lon,
                    t.lat
                ]), c = e.cosAngle || e.rotation && Math.cos(e.rotation), u = e.sinAngle || e.rotation && Math.sin(e.rotation), m = e.rotation ? [
                    d[0] * c + d[1] * u,
                    -d[0] * u + d[1] * c
                ] : d;
                return {
                    x: ((m[0] - n) * a + l) * r + s,
                    y: -(((h - m[1]) * a + p) * r - o)
                };
            }
            function o(t, e) {
                let i = this.options.chart.proj4 || t2.proj4;
                if (!i) {
                    t3(21, !1, this);
                    return;
                }
                if (null === t.y) return;
                let { jsonmarginX: s = 0, jsonmarginY: o = 0, jsonres: r = 1, scale: a = 1, xoffset: n = 0, xpan: l = 0, yoffset: h = 0, ypan: p = 0 } = e, d = {
                    x: ((t.x - s) / r - l) / a + n,
                    y: ((t.y - o) / r + p) / a + h
                }, c = e.cosAngle || e.rotation && Math.cos(e.rotation), u = e.sinAngle || e.rotation && Math.sin(e.rotation), m = i(e.crs, "WGS84", e.rotation ? {
                    x: d.x * c + -(d.y * u),
                    y: d.x * u + d.y * c
                } : d);
                return {
                    lat: m.y,
                    lon: m.x
                };
            }
            function r(t, e) {
                e || (e = Object.keys(t.objects)[0]);
                let i = t.objects[e];
                if (i["hc-decoded-geojson"] && i["hc-decoded-geojson"].title === t.title) return i["hc-decoded-geojson"];
                let s = t.arcs;
                if (t.transform) {
                    let e, i, o;
                    let r = t.arcs, { scale: a, translate: n } = t.transform;
                    s = [];
                    for(let t = 0, l = r.length; t < l; ++t){
                        let l = r[t];
                        s.push(e = []), i = 0, o = 0;
                        for(let t = 0, s = l.length; t < s; ++t)e.push([
                            (i += l[t][0]) * a[0] + n[0],
                            (o += l[t][1]) * a[1] + n[1]
                        ]);
                    }
                }
                let o = (t)=>"number" == typeof t[0] ? t.reduce((t, e, i)=>{
                        let o = e < 0 ? s[~e] : s[e];
                        return e < 0 ? (o = o.slice(0, 0 === i ? o.length : o.length - 1)).reverse() : i && (o = o.slice(1)), t.concat(o);
                    }, []) : t.map(o), r = i.geometries, a = [];
                for(let t = 0, e = r.length; t < e; ++t)a.push({
                    type: "Feature",
                    properties: r[t].properties,
                    geometry: {
                        type: r[t].type,
                        coordinates: r[t].coordinates || o(r[t].arcs)
                    }
                });
                let n = {
                    type: "FeatureCollection",
                    copyright: t.copyright,
                    copyrightShort: t.copyrightShort,
                    copyrightUrl: t.copyrightUrl,
                    features: a,
                    "hc-recommended-mapview": i["hc-recommended-mapview"],
                    bbox: t.bbox,
                    title: t.title
                };
                return i["hc-decoded-geojson"] = n, n;
            }
            function a(t, e) {
                e = t7(!0, this.options.credits, e), t.call(this, e), this.credits && this.mapCreditsFull && this.credits.attr({
                    title: this.mapCreditsFull
                });
            }
            t.compose = function(t) {
                let r = t.prototype;
                r.transformFromLatLon || (r.fromLatLonToPoint = e, r.fromPointToLatLon = i, r.transformFromLatLon = s, r.transformToLatLon = o, t9(r, "addCredits", a));
            }, t.geojson = function(t, e = "map", i) {
                let s = [], o = "Topology" === t.type ? r(t) : t, a = o.features;
                for(let t = 0, i = a.length; t < i; ++t){
                    let i;
                    let o = a[t], r = o.geometry || {}, n = r.type, l = r.coordinates, h = o.properties;
                    if (("map" === e || "mapbubble" === e) && ("Polygon" === n || "MultiPolygon" === n) ? l.length && (i = {
                        geometry: {
                            coordinates: l,
                            type: n
                        }
                    }) : "mapline" === e && ("LineString" === n || "MultiLineString" === n) ? l.length && (i = {
                        geometry: {
                            coordinates: l,
                            type: n
                        }
                    }) : "mappoint" === e && "Point" === n && l.length && (i = {
                        geometry: {
                            coordinates: l,
                            type: n
                        }
                    }), i) {
                        let t = h && (h.name || h.NAME), e = h && h.lon, o = h && h.lat;
                        s.push(t8(i, {
                            lat: "number" == typeof o ? o : void 0,
                            lon: "number" == typeof e ? e : void 0,
                            name: "string" == typeof t ? t : void 0,
                            properties: h
                        }));
                    }
                }
                return i && o.copyrightShort && (i.chart.mapCredits = t6(i.chart.options.credits?.mapText, {
                    geojson: o
                }), i.chart.mapCreditsFull = t6(i.chart.options.credits?.mapTextFull, {
                    geojson: o
                })), s;
            }, t.topo2geo = r;
        }(y || (y = {}));
        let t4 = y;
        !function(t) {
            t.getCenterOfPoints = function(t) {
                let e = t.reduce((t, e)=>(t.x += e.x, t.y += e.y, t), {
                    x: 0,
                    y: 0
                });
                return {
                    x: e.x / t.length,
                    y: e.y / t.length
                };
            }, t.getDistanceBetweenPoints = function(t, e) {
                return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
            }, t.getAngleBetweenPoints = function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y);
            }, t.pointInPolygon = function({ x: t, y: e }, i) {
                let s = i.length, o, r, a = !1;
                for(o = 0, r = s - 1; o < s; r = o++){
                    let [s, n] = i[o], [l, h] = i[r];
                    n > e != h > e && t < (l - s) * (e - n) / (h - n) + s && (a = !a);
                }
                return a;
            };
        }(x || (x = {}));
        let t5 = x;
        function et(t, e, i = !0) {
            let s = e[e.length - 1], o, r, a, n = t;
            for(let t = 0; t < e.length; t++){
                let l = n;
                o = e[t], n = [], r = i ? l[l.length - 1] : l[0];
                for(let t = 0; t < l.length; t++)ee(s, o, a = l[t]) ? (ee(s, o, r) || n.push(ei(s, o, r, a)), n.push(a)) : ee(s, o, r) && n.push(ei(s, o, r, a)), r = a;
                s = o;
            }
            return n;
        }
        function ee(t, e, i) {
            return (e[0] - t[0]) * (i[1] - t[1]) > (e[1] - t[1]) * (i[0] - t[0]);
        }
        function ei(t, e, i, s) {
            let o = [
                t[0] - e[0],
                t[1] - e[1]
            ], r = [
                i[0] - s[0],
                i[1] - s[1]
            ], a = t[0] * e[1] - t[1] * e[0], n = i[0] * s[1] - i[1] * s[0], l = 1 / (o[0] * r[1] - o[1] * r[0]), h = [
                (a * r[0] - n * o[0]) * l,
                (a * r[1] - n * o[1]) * l
            ];
            return h.isIntersection = !0, h;
        }
        let es = Math.sign || ((t)=>0 === t ? 0 : t > 0 ? 1 : -1), eo = Math.PI / 180, er = Math.PI / 2, ea = (t)=>Math.tan((er + t) / 2), en = class {
            constructor(t){
                let e = (t.parallels || []).map((t)=>t * eo), i = e[0] || 0, s = e[1] ?? i, o = Math.cos(i);
                "object" == typeof t.projectedBounds && (this.projectedBounds = t.projectedBounds);
                let r = i === s ? Math.sin(i) : Math.log(o / Math.cos(s)) / Math.log(ea(s) / ea(i));
                1e-10 > Math.abs(r) && (r = 1e-10 * (es(r) || 1)), this.n = r, this.c = o * Math.pow(ea(i), r) / r;
            }
            forward(t) {
                let { c: e, n: i, projectedBounds: s } = this, o = t[0] * eo, r = t[1] * eo;
                e > 0 ? r < -er + 1e-6 && (r = -er + 1e-6) : r > er - 1e-6 && (r = er - 1e-6);
                let a = e / Math.pow(ea(r), i), n = a * Math.sin(i * o) * 63.78137, l = (e - a * Math.cos(i * o)) * 63.78137, h = [
                    n,
                    l
                ];
                return s && (n < s.x1 || n > s.x2 || l < s.y1 || l > s.y2) && (h.outside = !0), h;
            }
            inverse(t) {
                let { c: e, n: i } = this, s = t[0] / 63.78137, o = e - t[1] / 63.78137, r = es(i) * Math.sqrt(s * s + o * o), a = Math.atan2(s, Math.abs(o)) * es(o);
                return o * i < 0 && (a -= Math.PI * es(s) * es(o)), [
                    a / i / eo,
                    (2 * Math.atan(Math.pow(e / r, 1 / i)) - er) / eo
                ];
            }
        }, el = Math.sqrt(3) / 2, eh = class {
            constructor(){
                this.bounds = {
                    x1: -200.37508342789243,
                    x2: 200.37508342789243,
                    y1: -97.52595454902263,
                    y2: 97.52595454902263
                };
            }
            forward(t) {
                let e = Math.PI / 180, i = Math.asin(el * Math.sin(t[1] * e)), s = i * i, o = s * s * s;
                return [
                    t[0] * e * Math.cos(i) * 74.03120656864502 / (el * (1.340264 + -.24331799999999998 * s + o * (.0062510000000000005 + .034164 * s))),
                    74.03120656864502 * i * (1.340264 + -.081106 * s + o * (893e-6 + .003796 * s))
                ];
            }
            inverse(t) {
                let e = t[0] / 74.03120656864502, i = t[1] / 74.03120656864502, s = 180 / Math.PI, o = i, r, a, n, l;
                for(let t = 0; t < 12 && (a = (r = o * o) * r * r, n = o * (1.340264 + -.081106 * r + a * (893e-6 + .003796 * r)) - i, o -= l = n / (1.340264 + -.24331799999999998 * r + a * (.0062510000000000005 + .034164 * r)), !(1e-9 > Math.abs(l))); ++t);
                a = (r = o * o) * r * r;
                let h = s * el * e * (1.340264 + -.24331799999999998 * r + a * (.0062510000000000005 + .034164 * r)) / Math.cos(o), p = s * Math.asin(Math.sin(o) / el);
                return Math.abs(h) > 180 ? [
                    NaN,
                    NaN
                ] : [
                    h,
                    p
                ];
            }
        }, ep = Math.PI / 4, ed = Math.PI / 180, ec = class {
            constructor(){
                this.bounds = {
                    x1: -200.37508342789243,
                    x2: 200.37508342789243,
                    y1: -146.91480769173063,
                    y2: 146.91480769173063
                };
            }
            forward(t) {
                return [
                    t[0] * ed * 63.78137,
                    79.7267125 * Math.log(Math.tan(ep + .4 * t[1] * ed))
                ];
            }
            inverse(t) {
                return [
                    t[0] / 63.78137 / ed,
                    2.5 * (Math.atan(Math.exp(.8 * (t[1] / 63.78137))) - ep) / ed
                ];
            }
        }, eu = Math.PI / 180, em = class {
            constructor(){
                this.antimeridianCutting = !1, this.bounds = {
                    x1: -63.78460826781007,
                    x2: 63.78460826781007,
                    y1: -63.78460826781007,
                    y2: 63.78460826781007
                };
            }
            forward(t) {
                let e = t[0], i = t[1] * eu, s = [
                    Math.cos(i) * Math.sin(e * eu) * 63.78460826781007,
                    63.78460826781007 * Math.sin(i)
                ];
                return (e < -90 || e > 90) && (s.outside = !0), s;
            }
            inverse(t) {
                let e = t[0] / 63.78460826781007, i = t[1] / 63.78460826781007, s = Math.sqrt(e * e + i * i), o = Math.asin(s), r = Math.sin(o);
                return [
                    Math.atan2(e * r, s * Math.cos(o)) / eu,
                    Math.asin(s && i * r / s) / eu
                ];
            }
        }, eg = Math.PI / 180, ef = class {
            constructor(){
                this.bounds = {
                    x1: -200.37508342789243,
                    x2: 200.37508342789243,
                    y1: -200.3750834278071,
                    y2: 200.3750834278071
                }, this.maxLatitude = 85.0511287798;
            }
            forward(t) {
                let e = Math.sin(t[1] * eg), i = [
                    63.78137 * t[0] * eg,
                    63.78137 * Math.log((1 + e) / (1 - e)) / 2
                ];
                return Math.abs(t[1]) > this.maxLatitude && (i.outside = !0), i;
            }
            inverse(t) {
                return [
                    t[0] / (63.78137 * eg),
                    (2 * Math.atan(Math.exp(t[1] / 63.78137)) - Math.PI / 2) / eg
                ];
            }
        }, { clipLineString: eb, clipPolygon: ey } = {
            clipLineString: function(t, e) {
                let i = [], s = et(t, e, !1);
                for(let t = 1; t < s.length; t++)s[t].isIntersection && s[t - 1].isIntersection && (i.push(s.splice(0, t)), t = 0), t === s.length - 1 && i.push(s);
                return i;
            },
            clipPolygon: et
        }, { clamp: ex, erase: eM } = L(), ev = 2 * Math.PI / 360, ew = (t)=>(t < -180 && (t += 360), t > 180 && (t -= 360), t), eC = (t)=>(1 - Math.cos(t)) / 2, eT = (t, e)=>{
            let i = Math.cos, s = t[1] * ev, o = t[0] * ev, r = e[1] * ev, a = e[0] * ev;
            return eC(r - s) + i(s) * i(r) * eC(a - o);
        };
        class eL {
            static add(t, e) {
                eL.registry[t] = e;
            }
            static distance(t, e) {
                let { atan2: i, sqrt: s } = Math, o = eT(t, e);
                return 6371e3 * (2 * i(s(o), s(1 - o)));
            }
            static geodesic(t, e, i, s = 5e5) {
                let { atan2: o, cos: r, sin: a, sqrt: n } = Math, l = eL.distance, h = t[1] * ev, p = t[0] * ev, d = e[1] * ev, c = e[0] * ev, u = r(h) * r(p), m = r(d) * r(c), g = r(h) * a(p), f = r(d) * a(c), b = a(h), y = a(d), x = l(t, e), M = x / 6371e3, v = a(M), w = Math.round(x / s), C = [];
                if (i && C.push(t), w > 1) {
                    let t = 1 / w;
                    for(let e = t; e < .999; e += t){
                        let t = a((1 - e) * M) / v, i = a(e * M) / v, s = t * u + i * m, r = t * g + i * f, l = o(t * b + i * y, n(s * s + r * r)), h = o(r, s);
                        C.push([
                            h / ev,
                            l / ev
                        ]);
                    }
                }
                return i && C.push(e), C;
            }
            static insertGeodesics(t) {
                let e = t.length - 1;
                for(; e--;)if (Math.max(Math.abs(t[e][0] - t[e + 1][0]), Math.abs(t[e][1] - t[e + 1][1])) > 10) {
                    let i = eL.geodesic(t[e], t[e + 1]);
                    i.length && t.splice(e + 1, 0, ...i);
                }
            }
            static toString(t) {
                let { name: e, rotation: i } = t || {};
                return [
                    e,
                    i && i.join(",")
                ].join(";");
            }
            constructor(t = {}){
                this.hasCoordinates = !1, this.hasGeoProjection = !1, this.maxLatitude = 90, this.options = t;
                let { name: e, projectedBounds: i, rotation: s } = t;
                this.rotator = s ? this.getRotator(s) : void 0;
                let o = e ? eL.registry[e] : void 0;
                o && (this.def = new o(t));
                let { def: r, rotator: a } = this;
                r && (this.maxLatitude = r.maxLatitude || 90, this.hasGeoProjection = !0), a && r ? (this.forward = (t)=>r.forward(a.forward(t)), this.inverse = (t)=>a.inverse(r.inverse(t))) : r ? (this.forward = (t)=>r.forward(t), this.inverse = (t)=>r.inverse(t)) : a && (this.forward = a.forward, this.inverse = a.inverse), this.bounds = "world" === i ? r && r.bounds : i;
            }
            lineIntersectsBounds(t) {
                let { x1: e, x2: i, y1: s, y2: o } = this.bounds || {}, r = (t, e, i)=>{
                    let [s, o] = t, r = e ? 0 : 1;
                    if ("number" == typeof i && s[e] >= i != o[e] >= i) {
                        let t = (i - s[e]) / (o[e] - s[e]), a = s[r] + t * (o[r] - s[r]);
                        return e ? [
                            a,
                            i
                        ] : [
                            i,
                            a
                        ];
                    }
                }, a, n = t[0];
                return (a = r(t, 0, e)) ? (n = a, t[1] = a) : (a = r(t, 0, i)) && (n = a, t[1] = a), (a = r(t, 1, s)) ? n = a : (a = r(t, 1, o)) && (n = a), n;
            }
            getRotator(t) {
                let e = t[0] * ev, i = (t[1] || 0) * ev, s = (t[2] || 0) * ev, o = Math.cos(i), r = Math.sin(i), a = Math.cos(s), n = Math.sin(s);
                if (0 !== e || 0 !== i || 0 !== s) return {
                    forward: (t)=>{
                        let i = t[0] * ev + e, s = t[1] * ev, l = Math.cos(s), h = Math.cos(i) * l, p = Math.sin(i) * l, d = Math.sin(s), c = d * o + h * r;
                        return [
                            Math.atan2(p * a - c * n, h * o - d * r) / ev,
                            Math.asin(c * a + p * n) / ev
                        ];
                    },
                    inverse: (t)=>{
                        let i = t[0] * ev, s = t[1] * ev, l = Math.cos(s), h = Math.cos(i) * l, p = Math.sin(i) * l, d = Math.sin(s), c = d * a - p * n;
                        return [
                            (Math.atan2(p * a + d * n, h * o + c * r) - e) / ev,
                            Math.asin(c * o - h * r) / ev
                        ];
                    }
                };
            }
            forward(t) {
                return t;
            }
            inverse(t) {
                return t;
            }
            cutOnAntimeridian(t, e) {
                let i;
                let s = [], o = [
                    t
                ];
                for(let i = 0, o = t.length; i < o; ++i){
                    let o = t[i], r = t[i - 1];
                    if (!i) {
                        if (!e) continue;
                        r = t[t.length - 1];
                    }
                    let a = r[0], n = o[0];
                    if ((a < -90 || a > 90) && (n < -90 || n > 90) && a > 0 != n > 0) {
                        let t = ex((180 - (a + 360) % 360) / ((n + 360) % 360 - (a + 360) % 360), 0, 1), e = r[1] + t * (o[1] - r[1]);
                        s.push({
                            i,
                            lat: e,
                            direction: a < 0 ? 1 : -1,
                            previousLonLat: r,
                            lonLat: o
                        });
                    }
                }
                if (s.length) {
                    if (e) {
                        s.length % 2 == 1 && (i = s.slice().sort((t, e)=>Math.abs(e.lat) - Math.abs(t.lat))[0], eM(s, i));
                        let e = s.length - 2;
                        for(; e >= 0;){
                            let i = s[e].i, r = ew(180 + 1e-6 * s[e].direction), a = ew(180 - 1e-6 * s[e].direction), n = t.splice(i, s[e + 1].i - i, ...eL.geodesic([
                                r,
                                s[e].lat
                            ], [
                                r,
                                s[e + 1].lat
                            ], !0));
                            n.push(...eL.geodesic([
                                a,
                                s[e + 1].lat
                            ], [
                                a,
                                s[e].lat
                            ], !0)), o.push(n), e -= 2;
                        }
                        if (i) for(let t = 0; t < o.length; t++){
                            let { direction: e, lat: s } = i, r = o[t], a = r.indexOf(i.lonLat);
                            if (a > -1) {
                                let t = (s < 0 ? -1 : 1) * this.maxLatitude, o = ew(180 + 1e-6 * e), n = ew(180 - 1e-6 * e), l = eL.geodesic([
                                    o,
                                    s
                                ], [
                                    o,
                                    t
                                ], !0);
                                for(let i = o + 120 * e; i > -180 && i < 180; i += 120 * e)l.push([
                                    i,
                                    t
                                ]);
                                l.push(...eL.geodesic([
                                    n,
                                    t
                                ], [
                                    n,
                                    i.lat
                                ], !0)), r.splice(a, 0, ...l);
                                break;
                            }
                        }
                    } else {
                        let e = s.length;
                        for(; e--;){
                            let i = s[e].i, r = t.splice(i, t.length, [
                                ew(180 + 1e-6 * s[e].direction),
                                s[e].lat
                            ]);
                            r.unshift([
                                ew(180 - 1e-6 * s[e].direction),
                                s[e].lat
                            ]), o.push(r);
                        }
                    }
                }
                return o;
            }
            path(t) {
                let e;
                let { bounds: i, def: s, rotator: o } = this, r = [], a = "Polygon" === t.type || "MultiPolygon" === t.type, n = this.hasGeoProjection, l = !s || !1 !== s.antimeridianCutting, h = l ? o : void 0, p = l && s || this;
                i && (e = [
                    [
                        i.x1,
                        i.y1
                    ],
                    [
                        i.x2,
                        i.y1
                    ],
                    [
                        i.x2,
                        i.y2
                    ],
                    [
                        i.x1,
                        i.y2
                    ]
                ]);
                let d = (t)=>{
                    let s = t.map((t)=>{
                        if (l) {
                            h && (t = h.forward(t));
                            let e = t[0];
                            1e-6 > Math.abs(e - 180) && (e = e < 180 ? 179.999999 : 180.000001), t = [
                                e,
                                t[1]
                            ];
                        }
                        return t;
                    }), o = [
                        s
                    ];
                    n && (eL.insertGeodesics(s), l && (o = this.cutOnAntimeridian(s, a))), o.forEach((t)=>{
                        let s, o;
                        if (t.length < 2) return;
                        let h = !1, d = !1, c = (t)=>{
                            h ? r.push([
                                "L",
                                t[0],
                                t[1]
                            ]) : (r.push([
                                "M",
                                t[0],
                                t[1]
                            ]), h = !0);
                        }, u = !1, m = !1, g = t.map((t)=>{
                            let e = p.forward(t);
                            return e.outside ? u = !0 : m = !0, e[1] === 1 / 0 ? e[1] = 1e10 : e[1] === -1 / 0 && (e[1] = -1e10), e;
                        });
                        if (l) {
                            if (a && g.push(g[0]), u) {
                                if (!m) return;
                                if (e) {
                                    if (a) g = ey(g, e);
                                    else if (i) {
                                        eb(g, e).forEach((t)=>{
                                            h = !1, t.forEach(c);
                                        });
                                        return;
                                    }
                                }
                            }
                            g.forEach(c);
                        } else for(let e = 0; e < g.length; e++){
                            let i = t[e], r = g[e];
                            r.outside ? d = !0 : (a && !s && (s = i, t.push(i), g.push(r)), d && o && (a && n ? eL.geodesic(o, i).forEach((t)=>c(p.forward(t))) : h = !1), c(r), o = i, d = !1);
                        }
                    });
                };
                return "LineString" === t.type ? d(t.coordinates) : "MultiLineString" === t.type ? t.coordinates.forEach((t)=>d(t)) : "Polygon" === t.type ? (t.coordinates.forEach((t)=>d(t)), r.length && r.push([
                    "Z"
                ])) : "MultiPolygon" === t.type && (t.coordinates.forEach((t)=>{
                    t.forEach((t)=>d(t));
                }), r.length && r.push([
                    "Z"
                ])), r;
            }
        }
        eL.registry = {
            EqualEarth: eh,
            LambertConformalConic: en,
            Miller: ec,
            Orthographic: em,
            WebMercator: ef
        };
        let { composed: eP } = L(), { pointInPolygon: eA } = t5, { topo2geo: ek } = t4, { boundsFromPath: ej } = tU, { addEvent: ez, clamp: eS, crisp: eI, fireEvent: eB, isArray: eE, isNumber: eD, isObject: eV, isString: eO, merge: eN, pick: eG, pushUnique: eX, relativeLength: eR } = L(), eH = {};
        function eW(t, e) {
            let { width: i, height: s } = e;
            return Math.log(400.979322 / Math.max((t.x2 - t.x1) / (i / 256), (t.y2 - t.y1) / (s / 256))) / Math.log(2);
        }
        function eY(t) {
            t.seriesOptions.mapData && this.mapView?.recommendMapView(this, [
                this.options.chart.map,
                t.seriesOptions.mapData
            ], this.options.drilldown?.mapZooming);
        }
        class eU {
            static compose(t) {
                eX(eP, "MapView") && (eH = t.maps, ez(t, "afterInit", function() {
                    this.mapView = new eU(this, this.options.mapView);
                }, {
                    order: 0
                }), ez(t, "addSeriesAsDrilldown", eY), ez(t, "afterDrillUp", eY));
            }
            static compositeBounds(t) {
                if (t.length) return t.slice(1).reduce((t, e)=>(t.x1 = Math.min(t.x1, e.x1), t.y1 = Math.min(t.y1, e.y1), t.x2 = Math.max(t.x2, e.x2), t.y2 = Math.max(t.y2, e.y2), t), eN(t[0]));
            }
            static mergeInsets(t, e) {
                let i = (t)=>{
                    let e = {};
                    return t.forEach((t, i)=>{
                        e[t && t.id || `i${i}`] = t;
                    }), e;
                }, s = eN(i(t), i(e));
                return Object.keys(s).map((t)=>s[t]);
            }
            constructor(t, e){
                this.allowTransformAnimation = !0, this.eventsToUnbind = [], this.insets = [], this.padding = [
                    0,
                    0,
                    0,
                    0
                ], this.recommendedMapView = {}, this instanceof eF || this.recommendMapView(t, [
                    t.options.chart.map,
                    ...(t.options.series || []).map((t)=>t.mapData)
                ]), this.userOptions = e || {};
                let i = eN(tQ, this.recommendedMapView, e), s = this.recommendedMapView?.insets, o = e && e.insets;
                s && o && (i.insets = eU.mergeInsets(s, o)), this.chart = t, this.center = i.center, this.options = i, this.projection = new eL(i.projection), this.playingField = t.plotBox, this.zoom = i.zoom || 0, this.minZoom = i.minZoom, this.createInsets(), this.eventsToUnbind.push(ez(t, "afterSetChartSize", ()=>{
                    this.playingField = this.getField(), (void 0 === this.minZoom || this.minZoom === this.zoom) && (this.fitToBounds(void 0, void 0, !1), !this.chart.hasRendered && eD(this.userOptions.zoom) && (this.zoom = this.userOptions.zoom), this.userOptions.center && eN(!0, this.center, this.userOptions.center));
                })), this.setUpEvents();
            }
            createInsets() {
                let t = this.options, e = t.insets;
                e && e.forEach((e)=>{
                    let i = new eF(this, eN(t.insetOptions, e));
                    this.insets.push(i);
                });
            }
            fitToBounds(t, e, i = !0, s) {
                let o = t || this.getProjectedBounds();
                if (o) {
                    let r = eG(e, t ? 0 : this.options.padding), a = this.getField(!1), n = eE(r) ? r : [
                        r,
                        r,
                        r,
                        r
                    ];
                    this.padding = [
                        eR(n[0], a.height),
                        eR(n[1], a.width),
                        eR(n[2], a.height),
                        eR(n[3], a.width)
                    ], this.playingField = this.getField();
                    let l = eW(o, this.playingField);
                    t || (this.minZoom = l);
                    let h = this.projection.inverse([
                        (o.x2 + o.x1) / 2,
                        (o.y2 + o.y1) / 2
                    ]);
                    this.setView(h, l, i, s);
                }
            }
            getField(t = !0) {
                let e = t ? this.padding : [
                    0,
                    0,
                    0,
                    0
                ];
                return {
                    x: e[3],
                    y: e[0],
                    width: this.chart.plotWidth - e[1] - e[3],
                    height: this.chart.plotHeight - e[0] - e[2]
                };
            }
            getGeoMap(t) {
                if (eO(t)) return eH[t] && "Topology" === eH[t].type ? ek(eH[t]) : eH[t];
                if (eV(t, !0)) {
                    if ("FeatureCollection" === t.type) return t;
                    if ("Topology" === t.type) return ek(t);
                }
            }
            getMapBBox() {
                let t = this.getProjectedBounds(), e = this.getScale();
                if (t) {
                    let i = this.padding, s = this.projectedUnitsToPixels({
                        x: t.x1,
                        y: t.y2
                    });
                    return {
                        width: (t.x2 - t.x1) * e + i[1] + i[3],
                        height: (t.y2 - t.y1) * e + i[0] + i[2],
                        x: s.x - i[3],
                        y: s.y - i[0]
                    };
                }
            }
            getProjectedBounds() {
                let t = this.projection, e = this.chart.series.reduce((t, e)=>{
                    let i = e.getProjectedBounds && e.getProjectedBounds();
                    return i && !1 !== e.options.affectsMapView && t.push(i), t;
                }, []), i = this.options.fitToGeometry;
                if (i) {
                    if (!this.fitToGeometryCache) {
                        if ("MultiPoint" === i.type) {
                            let e = i.coordinates.map((e)=>t.forward(e)), s = e.map((t)=>t[0]), o = e.map((t)=>t[1]);
                            this.fitToGeometryCache = {
                                x1: Math.min.apply(0, s),
                                x2: Math.max.apply(0, s),
                                y1: Math.min.apply(0, o),
                                y2: Math.max.apply(0, o)
                            };
                        } else this.fitToGeometryCache = ej(t.path(i));
                    }
                    return this.fitToGeometryCache;
                }
                return this.projection.bounds || eU.compositeBounds(e);
            }
            getScale() {
                return 256 / 400.979322 * Math.pow(2, this.zoom);
            }
            getSVGTransform() {
                let { x: t, y: e, width: i, height: s } = this.playingField, o = this.projection.forward(this.center), r = this.projection.hasCoordinates ? -1 : 1, a = this.getScale(), n = a * r, l = t + i / 2 - o[0] * a, h = e + s / 2 - o[1] * n;
                return {
                    scaleX: a,
                    scaleY: n,
                    translateX: l,
                    translateY: h
                };
            }
            lonLatToPixels(t) {
                let e = this.lonLatToProjectedUnits(t);
                if (e) return this.projectedUnitsToPixels(e);
            }
            lonLatToProjectedUnits(t) {
                let e = this.chart, i = e.mapTransforms;
                if (i) {
                    for(let s in i)if (Object.hasOwnProperty.call(i, s) && i[s].hitZone) {
                        let o = e.transformFromLatLon(t, i[s]);
                        if (o && eA(o, i[s].hitZone.coordinates[0])) return o;
                    }
                    return e.transformFromLatLon(t, i.default);
                }
                for (let e of this.insets)if (e.options.geoBounds && eA({
                    x: t.lon,
                    y: t.lat
                }, e.options.geoBounds.coordinates[0])) {
                    let i = e.projection.forward([
                        t.lon,
                        t.lat
                    ]), s = e.projectedUnitsToPixels({
                        x: i[0],
                        y: i[1]
                    });
                    return this.pixelsToProjectedUnits(s);
                }
                let s = this.projection.forward([
                    t.lon,
                    t.lat
                ]);
                if (!s.outside) return {
                    x: s[0],
                    y: s[1]
                };
            }
            projectedUnitsToLonLat(t) {
                let e = this.chart, i = e.mapTransforms;
                if (i) {
                    for(let s in i)if (Object.hasOwnProperty.call(i, s) && i[s].hitZone && eA(t, i[s].hitZone.coordinates[0])) return e.transformToLatLon(t, i[s]);
                    return e.transformToLatLon(t, i.default);
                }
                let s = this.projectedUnitsToPixels(t);
                for (let t of this.insets)if (t.hitZone && eA(s, t.hitZone.coordinates[0])) {
                    let e = t.pixelsToProjectedUnits(s), i = t.projection.inverse([
                        e.x,
                        e.y
                    ]);
                    return {
                        lon: i[0],
                        lat: i[1]
                    };
                }
                let o = this.projection.inverse([
                    t.x,
                    t.y
                ]);
                return {
                    lon: o[0],
                    lat: o[1]
                };
            }
            recommendMapView(t, e, i = !1) {
                this.recommendedMapView = {};
                let s = e.map((t)=>this.getGeoMap(t)), o = [];
                s.forEach((t)=>{
                    if (t && (Object.keys(this.recommendedMapView).length || (this.recommendedMapView = t["hc-recommended-mapview"] || {}), t.bbox)) {
                        let [e, i, s, r] = t.bbox;
                        o.push({
                            x1: e,
                            y1: i,
                            x2: s,
                            y2: r
                        });
                    }
                });
                let r = o.length && eU.compositeBounds(o);
                eB(this, "onRecommendMapView", {
                    geoBounds: r,
                    chart: t
                }, function() {
                    if (r && this.recommendedMapView) {
                        if (!this.recommendedMapView.projection) {
                            let { x1: t, y1: e, x2: i, y2: s } = r;
                            this.recommendedMapView.projection = i - t > 180 && s - e > 90 ? {
                                name: "EqualEarth",
                                parallels: [
                                    0,
                                    0
                                ],
                                rotation: [
                                    0
                                ]
                            } : {
                                name: "LambertConformalConic",
                                parallels: [
                                    e,
                                    s
                                ],
                                rotation: [
                                    -(t + i) / 2
                                ]
                            };
                        }
                        this.recommendedMapView.insets || (this.recommendedMapView.insets = void 0);
                    }
                }), this.geoMap = s[0], i && t.hasRendered && !t.userOptions.mapView?.projection && this.recommendedMapView && this.update(this.recommendedMapView);
            }
            redraw(t) {
                this.chart.series.forEach((t)=>{
                    t.useMapGeometry && (t.isDirty = !0);
                }), this.chart.redraw(t);
            }
            setView(t, e, i = !0, s) {
                t && (this.center = t), "number" == typeof e && ("number" == typeof this.minZoom && (e = Math.max(e, this.minZoom)), "number" == typeof this.options.maxZoom && (e = Math.min(e, this.options.maxZoom)), eD(e) && (this.zoom = e));
                let o = this.getProjectedBounds();
                if (o) {
                    let t = this.projection.forward(this.center), { x: e, y: i, width: s, height: r } = this.playingField, a = this.getScale(), n = this.projectedUnitsToPixels({
                        x: o.x1,
                        y: o.y1
                    }), l = this.projectedUnitsToPixels({
                        x: o.x2,
                        y: o.y2
                    }), h = [
                        (o.x1 + o.x2) / 2,
                        (o.y1 + o.y2) / 2
                    ];
                    if (!this.chart.series.some((t)=>t.isDrilling)) {
                        let o = n.x, p = l.y, d = l.x, c = n.y;
                        d - o < s ? t[0] = h[0] : o < e && d < e + s ? t[0] += Math.max(o - e, d - s - e) / a : d > e + s && o > e && (t[0] += Math.min(d - s - e, o - e) / a), c - p < r ? t[1] = h[1] : p < i && c < i + r ? t[1] -= Math.max(p - i, c - r - i) / a : c > i + r && p > i && (t[1] -= Math.min(c - r - i, p - i) / a), this.center = this.projection.inverse(t);
                    }
                    this.insets.forEach((t)=>{
                        t.options.field && (t.hitZone = t.getHitZone(), t.playingField = t.getField());
                    }), this.render();
                }
                eB(this, "afterSetView"), i && this.redraw(s);
            }
            projectedUnitsToPixels(t) {
                let e = this.getScale(), i = this.projection.forward(this.center), s = this.playingField, o = s.x + s.width / 2, r = s.y + s.height / 2;
                return {
                    x: o - e * (i[0] - t.x),
                    y: r + e * (i[1] - t.y)
                };
            }
            pixelsToLonLat(t) {
                return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(t));
            }
            pixelsToProjectedUnits(t) {
                let { x: e, y: i } = t, s = this.getScale(), o = this.projection.forward(this.center), r = this.playingField, a = r.x + r.width / 2, n = r.y + r.height / 2;
                return {
                    x: o[0] + (e - a) / s,
                    y: o[1] - (i - n) / s
                };
            }
            setUpEvents() {
                let t, e, i;
                let { chart: s } = this, o = (o)=>{
                    let { lastTouches: r, pinchDown: a } = s.pointer, n = this.projection, l = o.touches, { mouseDownX: h, mouseDownY: p } = s, d = 0;
                    if (a?.length === 1 ? (h = a[0].chartX, p = a[0].chartY) : a?.length === 2 && (h = (a[0].chartX + a[1].chartX) / 2, p = (a[0].chartY + a[1].chartY) / 2), l?.length === 2 && r && (d = Math.log(Math.sqrt(Math.pow(r[0].chartX - r[1].chartX, 2) + Math.pow(r[0].chartY - r[1].chartY, 2)) / Math.sqrt(Math.pow(l[0].chartX - l[1].chartX, 2) + Math.pow(l[0].chartY - l[1].chartY, 2))) / Math.log(.5)), eD(h) && eD(p)) {
                        let r = `${h},${p}`, { chartX: a, chartY: c } = o.originalEvent;
                        l?.length === 2 && (a = (l[0].chartX + l[1].chartX) / 2, c = (l[0].chartY + l[1].chartY) / 2), r !== e && (e = r, t = this.projection.forward(this.center), i = (this.projection.options.rotation || [
                            0,
                            0
                        ]).slice());
                        let u = n.def && n.def.bounds, m = u && eW(u, this.playingField) || -1 / 0;
                        if ("Orthographic" === n.options.name && 2 > (l?.length || 0) && (this.minZoom || 1 / 0) < 1.3 * m) {
                            let t = 440 / (this.getScale() * Math.min(s.plotWidth, s.plotHeight));
                            if (i) {
                                let e = (h - a) * t - i[0], o = eS(-i[1] - (p - c) * t, -80, 80), r = this.zoom;
                                this.update({
                                    projection: {
                                        rotation: [
                                            -e,
                                            -o
                                        ]
                                    }
                                }, !1), this.fitToBounds(void 0, void 0, !1), this.zoom = r, s.redraw(!1);
                            }
                        } else if (eD(a) && eD(c)) {
                            let e = this.getScale(), i = this.projection.hasCoordinates ? 1 : -1, s = this.projection.inverse([
                                t[0] + (h - a) / e,
                                t[1] - (p - c) / e * i
                            ]);
                            isNaN(s[0] + s[1]) || this.zoomBy(d, s, void 0, !1);
                        }
                        o.preventDefault();
                    }
                };
                ez(s, "pan", o), ez(s, "touchpan", o), ez(s, "selection", (t)=>{
                    if (t.resetSelection) this.zoomBy();
                    else {
                        let e = t.x - s.plotLeft, i = t.y - s.plotTop, { y: o, x: r } = this.pixelsToProjectedUnits({
                            x: e,
                            y: i
                        }), { y: a, x: n } = this.pixelsToProjectedUnits({
                            x: e + t.width,
                            y: i + t.height
                        });
                        this.fitToBounds({
                            x1: r,
                            y1: o,
                            x2: n,
                            y2: a
                        }, void 0, !0, !t.originalEvent.touches && void 0), /^touch/.test(t.originalEvent.type) || s.showResetZoom(), t.preventDefault();
                    }
                });
            }
            render() {
                this.group || (this.group = this.chart.renderer.g("map-view").attr({
                    zIndex: 4
                }).add());
            }
            update(t, e = !0, i) {
                let s = t.projection, o = s && eL.toString(s) !== eL.toString(this.options.projection), r = !1;
                eN(!0, this.userOptions, t), eN(!0, this.options, t), "insets" in t && (this.insets.forEach((t)=>t.destroy()), this.insets.length = 0, r = !0), (o || "fitToGeometry" in t) && delete this.fitToGeometryCache, (o || r) && (this.chart.series.forEach((t)=>{
                    let e = t.transformGroups;
                    if (t.clearBounds && t.clearBounds(), t.isDirty = !0, t.isDirtyData = !0, r && e) for(; e.length > 1;){
                        let t = e.pop();
                        t && t.destroy();
                    }
                }), o && (this.projection = new eL(this.options.projection)), r && this.createInsets(), !t.center && Object.hasOwnProperty.call(t, "zoom") && !eD(t.zoom) && this.fitToBounds(void 0, void 0, !1)), t.center || eD(t.zoom) ? this.setView(this.options.center, t.zoom, !1) : "fitToGeometry" in t && this.fitToBounds(void 0, void 0, !1), e && this.chart.redraw(i);
            }
            zoomBy(t, e, i, s) {
                let o = this.chart, r = this.projection.forward(this.center);
                if ("number" == typeof t) {
                    let a, n, l;
                    let h = this.zoom + t;
                    if (i) {
                        let [t, e] = i, s = this.getScale(), a = t - o.plotLeft - o.plotWidth / 2, h = e - o.plotTop - o.plotHeight / 2;
                        n = r[0] + a / s, l = r[1] + h / s;
                    }
                    if ("number" == typeof n && "number" == typeof l) {
                        let t = 1 - Math.pow(2, this.zoom) / Math.pow(2, h), e = r[0] - n, i = r[1] - l;
                        r[0] -= e * t, r[1] += i * t, a = this.projection.inverse(r);
                    }
                    this.setView(e || a, h, void 0, s);
                } else this.fitToBounds(void 0, void 0, void 0, s);
            }
        }
        class eF extends eU {
            constructor(t, e){
                if (super(t.chart, e), this.id = e.id, this.mapView = t, this.options = eN({
                    center: [
                        0,
                        0
                    ]
                }, t.options.insetOptions, e), this.allBounds = [], this.options.geoBounds) {
                    let e = t.projection.path(this.options.geoBounds);
                    this.geoBoundsProjectedBox = ej(e), this.geoBoundsProjectedPolygon = e.map((t)=>[
                            t[1] || 0,
                            t[2] || 0
                        ]);
                }
            }
            getField(t = !0) {
                let e = this.hitZone;
                if (e) {
                    let i = t ? this.padding : [
                        0,
                        0,
                        0,
                        0
                    ], s = e.coordinates[0], o = s.map((t)=>t[0]), r = s.map((t)=>t[1]), a = Math.min.apply(0, o) + i[3], n = Math.max.apply(0, o) - i[1], l = Math.min.apply(0, r) + i[0], h = Math.max.apply(0, r) - i[2];
                    if (eD(a) && eD(l)) return {
                        x: a,
                        y: l,
                        width: n - a,
                        height: h - l
                    };
                }
                return super.getField.call(this, t);
            }
            getHitZone() {
                let { chart: t, mapView: e, options: i } = this, { coordinates: s } = i.field || {};
                if (s) {
                    let o = s[0];
                    if ("percent" === i.units) {
                        let s = "mapBoundingBox" === i.relativeTo && e.getMapBBox() || eN(t.plotBox, {
                            x: 0,
                            y: 0
                        });
                        o = o.map((t)=>[
                                eR(`${t[0]}%`, s.width, s.x),
                                eR(`${t[1]}%`, s.height, s.y)
                            ]);
                    }
                    return {
                        type: "Polygon",
                        coordinates: [
                            o
                        ]
                    };
                }
            }
            getProjectedBounds() {
                return eU.compositeBounds(this.allBounds);
            }
            isInside(t) {
                let { geoBoundsProjectedBox: e, geoBoundsProjectedPolygon: i } = this;
                return !!(e && t.x >= e.x1 && t.x <= e.x2 && t.y >= e.y1 && t.y <= e.y2 && i && eA(t, i));
            }
            render() {
                let { chart: t, mapView: e, options: i } = this, s = i.borderPath || i.field;
                if (s && e.group) {
                    let o = !0;
                    this.border || (this.border = t.renderer.path().addClass("highcharts-mapview-inset-border").add(e.group), o = !1), t.styledMode || this.border.attr({
                        stroke: i.borderColor,
                        "stroke-width": i.borderWidth
                    });
                    let r = this.border.strokeWidth(), a = "mapBoundingBox" === i.relativeTo && e.getMapBBox() || e.playingField, n = (s.coordinates || []).reduce((e, s)=>s.reduce((e, s, o)=>{
                            let [n, l] = s;
                            return "percent" === i.units && (n = t.plotLeft + eR(`${n}%`, a.width, a.x), l = t.plotTop + eR(`${l}%`, a.height, a.y)), n = eI(n, r), l = eI(l, r), e.push(0 === o ? [
                                "M",
                                n,
                                l
                            ] : [
                                "L",
                                n,
                                l
                            ]), e;
                        }, e), []);
                    this.border[o ? "animate" : "attr"]({
                        d: n
                    });
                }
            }
            destroy() {
                this.border && (this.border = this.border.destroy()), this.eventsToUnbind.forEach((t)=>t());
            }
            setUpEvents() {}
        }
        let { animObject: eZ, stop: e_ } = L(), { noop: eK } = L(), { splitPath: eq } = tY, { column: e$, scatter: eJ } = W().seriesTypes, { extend: eQ, find: e0, fireEvent: e1, getNestedProperty: e2, isArray: e6, defined: e3, isNumber: e8, isObject: e7, merge: e9, objectEach: e4, pick: e5, splat: it } = L();
        class ie extends eJ {
            constructor(){
                super(...arguments), this.processedData = [];
            }
            animate(t) {
                let { chart: e, group: i } = this, s = eZ(this.options.animation);
                t ? i.attr({
                    translateX: e.plotLeft + e.plotWidth / 2,
                    translateY: e.plotTop + e.plotHeight / 2,
                    scaleX: .001,
                    scaleY: .001
                }) : i.animate({
                    translateX: e.plotLeft,
                    translateY: e.plotTop,
                    scaleX: 1,
                    scaleY: 1
                }, s);
            }
            clearBounds() {
                this.points.forEach((t)=>{
                    delete t.bounds, delete t.insetIndex, delete t.projectedPath;
                }), delete this.bounds;
            }
            doFullTranslate() {
                return !!(this.isDirtyData || this.chart.isResizing || !this.hasRendered);
            }
            drawMapDataLabels() {
                super.drawDataLabels(), this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
            }
            drawPoints() {
                let t = this, { chart: e, group: i, transformGroups: s = [] } = this, { mapView: o, renderer: r } = e;
                if (o) {
                    this.transformGroups = s, s[0] || (s[0] = r.g().add(i));
                    for(let t = 0, e = o.insets.length; t < e; ++t)s[t + 1] || s.push(r.g().add(i));
                    this.doFullTranslate() && (this.points.forEach((t)=>{
                        let { graphic: e } = t;
                        t.group = s["number" == typeof t.insetIndex ? t.insetIndex + 1 : 0], e && e.parentGroup !== t.group && e.add(t.group);
                    }), e$.prototype.drawPoints.apply(this), this.points.forEach((i)=>{
                        let s = i.graphic;
                        if (s) {
                            let o = s.animate, r = "";
                            i.name && (r += "highcharts-name-" + i.name.replace(/ /g, "-").toLowerCase()), i.properties && i.properties["hc-key"] && (r += " highcharts-key-" + i.properties["hc-key"].toString().toLowerCase()), r && s.addClass(r), e.styledMode && s.css(this.pointAttribs(i, i.selected && "select" || void 0)), s.attr({
                                visibility: !i.visible && (i.visible || i.isNull) ? "hidden" : "inherit"
                            }), s.animate = function(i, r, a) {
                                let n = e8(i["stroke-width"]) && !e8(s["stroke-width"]), l = e8(s["stroke-width"]) && !e8(i["stroke-width"]);
                                if (n || l) {
                                    let o = e5(t.getStrokeWidth(t.options), 1) / (e.mapView && e.mapView.getScale() || 1);
                                    n && (s["stroke-width"] = o), l && (i["stroke-width"] = o);
                                }
                                return o.call(s, i, r, l ? function() {
                                    s.element.removeAttribute("stroke-width"), delete s["stroke-width"], a && a.apply(this, arguments);
                                } : a);
                            };
                        }
                    })), s.forEach((i, s)=>{
                        let a = (0 === s ? o : o.insets[s - 1]).getSVGTransform(), n = e5(this.getStrokeWidth(this.options), 1), l = a.scaleX, h = a.scaleY > 0 ? 1 : -1, p = (e)=>{
                            (t.points || []).forEach((t)=>{
                                let i;
                                let s = t.graphic;
                                s && s["stroke-width"] && (i = this.getStrokeWidth(t.options)) && s.attr({
                                    "stroke-width": i / e
                                });
                            });
                        };
                        if (r.globalAnimation && e.hasRendered && o.allowTransformAnimation) {
                            let t = Number(i.attr("translateX")), e = Number(i.attr("translateY")), s = Number(i.attr("scaleX")), o = (o, r)=>{
                                let d = s + (l - s) * r.pos;
                                i.attr({
                                    translateX: t + (a.translateX - t) * r.pos,
                                    translateY: e + (a.translateY - e) * r.pos,
                                    scaleX: d,
                                    scaleY: d * h,
                                    "stroke-width": n / d
                                }), p(d);
                            }, d = e9(eZ(r.globalAnimation)), c = d.step;
                            d.step = function() {
                                c && c.apply(this, arguments), o.apply(this, arguments);
                            }, i.attr({
                                animator: 0
                            }).animate({
                                animator: 1
                            }, d, (function() {
                                "boolean" != typeof r.globalAnimation && r.globalAnimation.complete && r.globalAnimation.complete({
                                    applyDrilldown: !0
                                }), e1(this, "mapZoomComplete");
                            }).bind(this));
                        } else e_(i), i.attr(e9(a, {
                            "stroke-width": n / l
                        })), p(l);
                    }), this.isDrilling || this.drawMapDataLabels();
                }
            }
            getProjectedBounds() {
                if (!this.bounds && this.chart.mapView) {
                    let { insets: t, projection: e } = this.chart.mapView, i = [];
                    (this.points || []).forEach((s)=>{
                        if (s.path || s.geometry) {
                            if ("string" == typeof s.path ? s.path = eq(s.path) : e6(s.path) && "M" === s.path[0] && (s.path = this.chart.renderer.pathToSegments(s.path)), !s.bounds) {
                                let i = s.getProjectedBounds(e);
                                if (i) {
                                    s.labelrank = e5(s.labelrank, (i.x2 - i.x1) * (i.y2 - i.y1));
                                    let { midX: e, midY: o } = i;
                                    if (t && e8(e) && e8(o)) {
                                        let r = e0(t, (t)=>t.isInside({
                                                x: e,
                                                y: o
                                            }));
                                        r && (delete s.projectedPath, (i = s.getProjectedBounds(r.projection)) && r.allBounds.push(i), s.insetIndex = t.indexOf(r));
                                    }
                                    s.bounds = i;
                                }
                            }
                            s.bounds && void 0 === s.insetIndex && i.push(s.bounds);
                        }
                    }), this.bounds = eU.compositeBounds(i);
                }
                return this.bounds;
            }
            getStrokeWidth(t) {
                let e = this.pointAttrToOptions;
                return t[e && e["stroke-width"] || "borderWidth"];
            }
            hasData() {
                return !!this.dataTable.rowCount;
            }
            pointAttribs(t, e) {
                let { mapView: i, styledMode: s } = t.series.chart, o = s ? this.colorAttribs(t) : e$.prototype.pointAttribs.call(this, t, e), r = this.getStrokeWidth(t.options);
                if (e) {
                    let i = e9(this.options.states && this.options.states[e], t.options.states && t.options.states[e] || {}), s = this.getStrokeWidth(i);
                    e3(s) && (r = s), o.stroke = i.borderColor ?? t.color;
                }
                r && i && (r /= i.getScale());
                let a = this.getStrokeWidth(this.options);
                return o.dashstyle && i && e8(a) && (r = a / i.getScale()), t.visible || (o.fill = this.options.nullColor), e3(r) ? o["stroke-width"] = r : delete o["stroke-width"], o["stroke-linecap"] = o["stroke-linejoin"] = this.options.linecap, o;
            }
            updateData() {
                return !this.processedData && super.updateData.apply(this, arguments);
            }
            setData(t, e = !0, i, s) {
                delete this.bounds, super.setData(t, !1, void 0, s), this.processData(), this.generatePoints(), e && this.chart.redraw(i);
            }
            dataColumnKeys() {
                return this.pointArrayMap;
            }
            processData() {
                let t, e, i;
                let s = this.options, o = s.data, r = this.chart, a = r.options.chart, n = this.joinBy, l = s.keys || this.pointArrayMap, h = [], p = {}, d = this.chart.mapView, c = d && (e7(s.mapData, !0) ? d.getGeoMap(s.mapData) : d.geoMap), u = r.mapTransforms = a.mapTransforms || c && c["hc-transform"] || r.mapTransforms;
                u && e4(u, (t)=>{
                    t.rotation && (t.cosAngle = Math.cos(t.rotation), t.sinAngle = Math.sin(t.rotation));
                }), e6(s.mapData) ? i = s.mapData : c && "FeatureCollection" === c.type && (this.mapTitle = c.title, i = L().geojson(c, this.type, this)), this.processedData = [];
                let m = this.processedData;
                if (o) {
                    let t;
                    for(let e = 0, i = o.length; e < i; ++e){
                        if (e8(t = o[e])) m[e] = {
                            value: t
                        };
                        else if (e6(t)) {
                            let i = 0;
                            m[e] = {}, !s.keys && t.length > l.length && "string" == typeof t[0] && (m[e]["hc-key"] = t[0], ++i);
                            for(let s = 0; s < l.length; ++s, ++i)l[s] && void 0 !== t[i] && (l[s].indexOf(".") > 0 ? t$.prototype.setNestedProperty(m[e], t[i], l[s]) : m[e][l[s]] = t[i]);
                        } else m[e] = o[e];
                        n && "_i" === n[0] && (m[e]._i = e);
                    }
                }
                if (i) {
                    this.mapData = i, this.mapMap = {};
                    for(let s = 0; s < i.length; s++)e = (t = i[s]).properties, t._i = s, n[0] && e && e[n[0]] && (t[n[0]] = e[n[0]]), p[t[n[0]]] = t;
                    if (this.mapMap = p, n[1]) {
                        let t = n[1];
                        m.forEach((e)=>{
                            let i = e2(t, e);
                            p[i] && h.push(p[i]);
                        });
                    }
                    if (s.allAreas) {
                        if (n[1]) {
                            let t = n[1];
                            m.forEach((e)=>{
                                h.push(e2(t, e));
                            });
                        }
                        let t = "|" + h.map(function(t) {
                            return t && t[n[0]];
                        }).join("|") + "|";
                        i.forEach((e)=>{
                            n[0] && -1 !== t.indexOf("|" + e[n[0]] + "|") || m.push(e9(e, {
                                value: null
                            }));
                        });
                    }
                }
                this.dataTable.rowCount = m.length;
            }
            setOptions(t) {
                let e = super.setOptions(t), i = e.joinBy;
                return null === e.joinBy && (i = "_i"), i && (this.joinBy = it(i), this.joinBy[1] || (this.joinBy[1] = this.joinBy[0])), e;
            }
            translate() {
                let t = this.doFullTranslate(), e = this.chart.mapView, i = e && e.projection;
                if (this.chart.hasRendered && (this.isDirtyData || !this.hasRendered) && (this.processData(), this.generatePoints(), delete this.bounds, !e || e.userOptions.center || e8(e.userOptions.zoom) || e.zoom !== e.minZoom ? this.getProjectedBounds() : e.fitToBounds(void 0, void 0, !1)), e) {
                    let s = e.getSVGTransform();
                    this.points.forEach((o)=>{
                        let r = e8(o.insetIndex) && e.insets[o.insetIndex].getSVGTransform() || s;
                        r && o.bounds && e8(o.bounds.midX) && e8(o.bounds.midY) && (o.plotX = o.bounds.midX * r.scaleX + r.translateX, o.plotY = o.bounds.midY * r.scaleY + r.translateY), t && (o.shapeType = "path", o.shapeArgs = {
                            d: t$.getProjectedPath(o, i)
                        }), o.hiddenInDataClass || (o.projectedPath && !o.projectedPath.length ? o.setVisible(!1) : o.visible || o.setVisible(!0));
                    });
                }
                e1(this, "afterTranslate");
            }
            update(t) {
                t.mapData && this.chart.mapView?.recommendMapView(this.chart, [
                    this.chart.options.chart.map,
                    ...(this.chart.options.series || []).map((e, i)=>i === this._i ? t.mapData : e.mapData)
                ], !0), super.update.apply(this, arguments);
            }
        }
        ie.defaultOptions = e9(eJ.defaultOptions, {
            affectsMapView: !0,
            animation: !1,
            dataLabels: {
                crop: !1,
                formatter: function() {
                    let { numberFormatter: t } = this.series.chart, { value: e } = this.point;
                    return tJ(e) ? t(e, -1) : this.point.name || "";
                },
                inside: !0,
                overflow: !1,
                padding: 0,
                verticalAlign: "middle"
            },
            linecap: "round",
            marker: null,
            nullColor: "#f7f7f7",
            stickyTracking: !1,
            tooltip: {
                followPointer: !0,
                pointFormat: "{point.name}: {point.value}<br/>"
            },
            turboThreshold: 0,
            allAreas: !0,
            borderColor: "#e6e6e6",
            borderWidth: 1,
            joinBy: "hc-key",
            states: {
                hover: {
                    halo: void 0,
                    borderColor: "#666666",
                    borderWidth: 2
                },
                normal: {
                    animation: !0
                },
                select: {
                    color: "#cccccc"
                }
            },
            legendSymbol: "rectangle"
        }), eQ(ie.prototype, {
            type: "map",
            axisTypes: tP.seriesMembers.axisTypes,
            colorAttribs: tP.seriesMembers.colorAttribs,
            colorKey: tP.seriesMembers.colorKey,
            directTouch: !0,
            drawDataLabels: eK,
            drawGraph: eK,
            forceDL: !0,
            getCenter: tE.getCenter,
            getExtremesFromAll: !0,
            getSymbol: eK,
            isCartesian: !1,
            parallelArrays: tP.seriesMembers.parallelArrays,
            pointArrayMap: tP.seriesMembers.pointArrayMap,
            pointClass: t$,
            preserveAspectRatio: !0,
            searchPoint: eK,
            trackerGroups: tP.seriesMembers.trackerGroups,
            useMapGeometry: !0
        }), tP.compose(ie), W().registerSeriesType("map", ie);
        let ii = ie, { extend: is, merge: io } = L();
        class ir extends ii {
            pointAttribs(t, e) {
                let i = super.pointAttribs(t, e);
                return i.fill = this.options.fillColor, i;
            }
        }
        ir.defaultOptions = io(ii.defaultOptions, {
            lineWidth: 1,
            fillColor: "none",
            legendSymbol: "lineMarker"
        }), is(ir.prototype, {
            type: "mapline",
            colorProp: "stroke",
            pointAttrToOptions: {
                stroke: "color",
                "stroke-width": "lineWidth"
            }
        }), W().registerSeriesType("mapline", ir);
        let { scatter: ia } = W().seriesTypes, { isNumber: il } = L();
        class ih extends ia.prototype.pointClass {
            isValid() {
                return !!(this.options.geometry || il(this.x) && il(this.y) || il(this.options.lon) && il(this.options.lat));
            }
        }
        w(632);
        let { noop: ip } = L(), { map: id, scatter: ic } = W().seriesTypes, { extend: iu, fireEvent: im, isNumber: ig, merge: ib } = L();
        class iy extends ic {
            constructor(){
                super(...arguments), this.clearBounds = id.prototype.clearBounds;
            }
            drawDataLabels() {
                super.drawDataLabels(), this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
            }
            projectPoint(t) {
                let e = this.chart.mapView;
                if (e) {
                    let { geometry: i, lon: s, lat: o } = t, r = i && "Point" === i.type && i.coordinates;
                    if (ig(s) && ig(o) && (r = [
                        s,
                        o
                    ]), r) return e.lonLatToProjectedUnits({
                        lon: r[0],
                        lat: r[1]
                    });
                }
            }
            translate() {
                let t = this.chart.mapView;
                if (this.generatePoints(), this.getProjectedBounds && this.isDirtyData && (delete this.bounds, this.getProjectedBounds()), t) {
                    let e = t.getSVGTransform(), { hasCoordinates: i } = t.projection;
                    this.points.forEach((s)=>{
                        let o, { x: r, y: a } = s, n = ig(s.insetIndex) && t.insets[s.insetIndex].getSVGTransform() || e, l = this.projectPoint(s.options) || s.properties && this.projectPoint(s.properties);
                        if (l ? (r = l.x, a = l.y) : s.bounds && (r = s.bounds.midX, a = s.bounds.midY, n && ig(r) && ig(a) && (s.plotX = r * n.scaleX + n.translateX, s.plotY = a * n.scaleY + n.translateY, o = !0)), ig(r) && ig(a)) {
                            if (!o) {
                                let e = t.projectedUnitsToPixels({
                                    x: r,
                                    y: a
                                });
                                s.plotX = e.x, s.plotY = i ? e.y : this.chart.plotHeight - e.y;
                            }
                        } else s.y = s.plotX = s.plotY = void 0;
                        s.isInside = this.isPointInside(s), s.zone = this.zones.length ? s.getZone() : void 0;
                    });
                }
                im(this, "afterTranslate");
            }
        }
        iy.defaultOptions = ib(ic.defaultOptions, {
            dataLabels: {
                crop: !1,
                defer: !1,
                enabled: !0,
                formatter: function() {
                    return this.point.name;
                },
                overflow: !1,
                style: {
                    color: "#000000"
                }
            },
            legendSymbol: "lineMarker"
        }), tN().prototype.symbols.mapmarker = (t, e, i, s, o)=>{
            let r, a;
            let n = o && "legend" === o.context;
            n ? (r = t + i / 2, a = e + s) : o && "number" == typeof o.anchorX && "number" == typeof o.anchorY ? (r = o.anchorX, a = o.anchorY) : (r = t + i / 2, a = e + s / 2, e -= s);
            let l = n ? s / 3 : s / 2;
            return [
                [
                    "M",
                    r,
                    a
                ],
                [
                    "C",
                    r,
                    a,
                    r - l,
                    e + 1.5 * l,
                    r - l,
                    e + l
                ],
                [
                    "A",
                    l,
                    l,
                    1,
                    1,
                    1,
                    r + l,
                    e + l
                ],
                [
                    "C",
                    r + l,
                    e + 1.5 * l,
                    r,
                    a,
                    r,
                    a
                ],
                [
                    "Z"
                ]
            ];
        }, iu(iy.prototype, {
            type: "mappoint",
            axisTypes: [
                "colorAxis"
            ],
            forceDL: !0,
            isCartesian: !1,
            pointClass: ih,
            searchPoint: ip,
            useMapGeometry: !0
        }), W().registerSeriesType("mappoint", iy);
        let ix = {
            borderColor: void 0,
            borderWidth: 2,
            className: void 0,
            color: void 0,
            connectorClassName: void 0,
            connectorColor: void 0,
            connectorDistance: 60,
            connectorWidth: 1,
            enabled: !1,
            labels: {
                className: void 0,
                allowOverlap: !1,
                format: "",
                formatter: void 0,
                align: "right",
                style: {
                    fontSize: "0.9em",
                    color: "#000000"
                },
                x: 0,
                y: 0
            },
            maxSize: 60,
            minSize: 10,
            legendIndex: 0,
            ranges: {
                value: void 0,
                borderColor: void 0,
                color: void 0,
                connectorColor: void 0
            },
            sizeBy: "area",
            sizeByAbsoluteValue: !1,
            zIndex: 1,
            zThreshold: 0
        }, { parse: iM } = j(), { noop: iv } = L(), { arrayMax: iw, arrayMin: iC, isNumber: iT, merge: iL, pick: iP, stableSort: iA } = L(), ik = class {
            constructor(t, e){
                this.setState = iv, this.init(t, e);
            }
            init(t, e) {
                this.options = t, this.visible = !0, this.chart = e.chart, this.legend = e;
            }
            addToLegend(t) {
                t.splice(this.options.legendIndex, 0, this);
            }
            drawLegendSymbol(t) {
                let e;
                let i = iP(t.options.itemDistance, 20), s = this.legendItem || {}, o = this.options, r = o.ranges, a = o.connectorDistance;
                if (!r || !r.length || !iT(r[0].value)) {
                    t.options.bubbleLegend.autoRanges = !0;
                    return;
                }
                iA(r, function(t, e) {
                    return e.value - t.value;
                }), this.ranges = r, this.setOptions(), this.render();
                let n = this.getMaxLabelSize(), l = this.ranges[0].radius, h = 2 * l;
                e = (e = a - l + n.width) > 0 ? e : 0, this.maxLabel = n, this.movementX = "left" === o.labels.align ? e : 0, s.labelWidth = h + e + i, s.labelHeight = h + n.height / 2;
            }
            setOptions() {
                let t = this.ranges, e = this.options, i = this.chart.series[e.seriesIndex], s = this.legend.baseline, o = {
                    zIndex: e.zIndex,
                    "stroke-width": e.borderWidth
                }, r = {
                    zIndex: e.zIndex,
                    "stroke-width": e.connectorWidth
                }, a = {
                    align: this.legend.options.rtl || "left" === e.labels.align ? "right" : "left",
                    zIndex: e.zIndex
                }, n = i.options.marker.fillOpacity, l = this.chart.styledMode;
                t.forEach(function(h, p) {
                    l || (o.stroke = iP(h.borderColor, e.borderColor, i.color), o.fill = iP(h.color, e.color, 1 !== n ? iM(i.color).setOpacity(n).get("rgba") : i.color), r.stroke = iP(h.connectorColor, e.connectorColor, i.color)), t[p].radius = this.getRangeRadius(h.value), t[p] = iL(t[p], {
                        center: t[0].radius - t[p].radius + s
                    }), l || iL(!0, t[p], {
                        bubbleAttribs: iL(o),
                        connectorAttribs: iL(r),
                        labelAttribs: a
                    });
                }, this);
            }
            getRangeRadius(t) {
                let e = this.options, i = this.options.seriesIndex, s = this.chart.series[i], o = e.ranges[0].value, r = e.ranges[e.ranges.length - 1].value, a = e.minSize, n = e.maxSize;
                return s.getRadius.call(this, r, o, a, n, t);
            }
            render() {
                let t = this.legendItem || {}, e = this.chart.renderer, i = this.options.zThreshold;
                for (let s of (this.symbols || (this.symbols = {
                    connectors: [],
                    bubbleItems: [],
                    labels: []
                }), t.symbol = e.g("bubble-legend"), t.label = e.g("bubble-legend-item").css(this.legend.itemStyle || {}), t.symbol.translateX = 0, t.symbol.translateY = 0, t.symbol.add(t.label), t.label.add(t.group), this.ranges))s.value >= i && this.renderRange(s);
                this.hideOverlappingLabels();
            }
            renderRange(t) {
                let e = this.ranges[0], i = this.legend, s = this.options, o = s.labels, r = this.chart, a = r.series[s.seriesIndex], n = r.renderer, l = this.symbols, h = l.labels, p = t.center, d = Math.abs(t.radius), c = s.connectorDistance || 0, u = o.align, m = i.options.rtl, g = s.borderWidth, f = s.connectorWidth, b = e.radius || 0, y = p - d - g / 2 + f / 2, x = (y % 1 ? 1 : .5) - (f % 2 ? 0 : .5), M = n.styledMode, v = m || "left" === u ? -c : c;
                "center" === u && (v = 0, s.connectorDistance = 0, t.labelAttribs.align = "center"), l.bubbleItems.push(n.circle(b, p + x, d).attr(M ? {} : t.bubbleAttribs).addClass((M ? "highcharts-color-" + a.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (s.className || "")).add(this.legendItem.symbol)), l.connectors.push(n.path(n.crispLine([
                    [
                        "M",
                        b,
                        y
                    ],
                    [
                        "L",
                        b + v,
                        y
                    ]
                ], s.connectorWidth)).attr(M ? {} : t.connectorAttribs).addClass((M ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (s.connectorClassName || "")).add(this.legendItem.symbol));
                let w = n.text(this.formatLabel(t)).attr(M ? {} : t.labelAttribs).css(M ? {} : o.style).addClass("highcharts-bubble-legend-labels " + (s.labels.className || "")).add(this.legendItem.symbol), C = {
                    x: b + v + s.labels.x,
                    y: y + s.labels.y + .4 * w.getBBox().height
                };
                w.attr(C), h.push(w), w.placed = !0, w.alignAttr = C;
            }
            getMaxLabelSize() {
                let t, e;
                return this.symbols.labels.forEach(function(i) {
                    e = i.getBBox(!0), t = t ? e.width > t.width ? e : t : e;
                }), t || {};
            }
            formatLabel(t) {
                let e = this.options, i = e.labels.formatter, s = e.labels.format, { numberFormatter: o } = this.chart;
                return s ? t1().format(s, t, this.chart) : i ? i.call(t) : o(t.value, 1);
            }
            hideOverlappingLabels() {
                let t = this.chart, e = this.options.labels.allowOverlap, i = this.symbols;
                !e && i && (t.hideOverlappingLabels(i.labels), i.labels.forEach(function(t, e) {
                    t.newOpacity ? t.newOpacity !== t.oldOpacity && i.connectors[e].show() : i.connectors[e].hide();
                }));
            }
            getRanges() {
                let t = this.legend.bubbleLegend, e = t.chart.series, i = t.options.ranges, s, o, r = Number.MAX_VALUE, a = -Number.MAX_VALUE;
                return e.forEach(function(t) {
                    t.isBubble && !t.ignoreSeries && (o = t.getColumn("z").filter(iT)).length && (r = iP(t.options.zMin, Math.min(r, Math.max(iC(o), !1 === t.options.displayNegative ? t.options.zThreshold : -Number.MAX_VALUE))), a = iP(t.options.zMax, Math.max(a, iw(o))));
                }), s = r === a ? [
                    {
                        value: a
                    }
                ] : [
                    {
                        value: r
                    },
                    {
                        value: (r + a) / 2
                    },
                    {
                        value: a,
                        autoRanges: !0
                    }
                ], i.length && i[0].radius && s.reverse(), s.forEach(function(t, e) {
                    i && i[e] && (s[e] = iL(i[e], t));
                }), s;
            }
            predictBubbleSizes() {
                let t = this.chart, e = t.legend.options, i = e.floating, s = "horizontal" === e.layout, o = s ? t.legend.lastLineHeight : 0, r = t.plotSizeX, a = t.plotSizeY, n = t.series[this.options.seriesIndex], l = n.getPxExtremes(), h = Math.ceil(l.minPxSize), p = Math.ceil(l.maxPxSize), d = Math.min(a, r), c, u = n.options.maxSize;
                return i || !/%$/.test(u) ? c = p : (c = (d + o) * (u = parseFloat(u)) / 100 / (u / 100 + 1), (s && a - c >= r || !s && r - c >= a) && (c = p)), [
                    h,
                    Math.ceil(c)
                ];
            }
            updateRanges(t, e) {
                let i = this.legend.options.bubbleLegend;
                i.minSize = t, i.maxSize = e, i.ranges = this.getRanges();
            }
            correctSizes() {
                let t = this.legend, e = this.chart.series[this.options.seriesIndex].getPxExtremes();
                Math.abs(Math.ceil(e.maxPxSize) - this.options.maxSize) > 1 && (this.updateRanges(this.options.minSize, e.maxPxSize), t.render());
            }
        }, { setOptions: ij } = L(), { composed: iz } = L(), { addEvent: iS, objectEach: iI, pushUnique: iB, wrap: iE } = L();
        function iD(t, e, i) {
            let s, o, r;
            let a = this.legend, n = iV(this) >= 0;
            a && a.options.enabled && a.bubbleLegend && a.options.bubbleLegend.autoRanges && n ? (s = a.bubbleLegend.options, o = a.bubbleLegend.predictBubbleSizes(), a.bubbleLegend.updateRanges(o[0], o[1]), s.placed || (a.group.placed = !1, a.allItems.forEach((t)=>{
                (r = t.legendItem || {}).group && (r.group.translateY = void 0);
            })), a.render(), s.placed || (this.getMargins(), this.axes.forEach((t)=>{
                t.setScale(), t.updateNames(), iI(t.ticks, function(t) {
                    t.isNew = !0, t.isNewLabel = !0;
                });
            }), this.getMargins()), s.placed = !0, t.call(this, e, i), a.bubbleLegend.correctSizes(), iX(a, iO(a))) : (t.call(this, e, i), a && a.options.enabled && a.bubbleLegend && (a.render(), iX(a, iO(a))));
        }
        function iV(t) {
            let e = t.series, i = 0;
            for(; i < e.length;){
                if (e[i] && e[i].isBubble && e[i].visible && e[i].dataTable.rowCount) return i;
                i++;
            }
            return -1;
        }
        function iO(t) {
            let e = t.allItems, i = [], s = e.length, o, r, a, n = 0, l = 0;
            for(n = 0; n < s; n++)if (r = e[n].legendItem || {}, a = (e[n + 1] || {}).legendItem || {}, r.labelHeight && (e[n].itemHeight = r.labelHeight), e[n] === e[s - 1] || r.y !== a.y) {
                for(i.push({
                    height: 0
                }), o = i[i.length - 1]; l <= n; l++)e[l].itemHeight > o.height && (o.height = e[l].itemHeight);
                o.step = n;
            }
            return i;
        }
        function iN(t) {
            let e = this.bubbleLegend, i = this.options, s = i.bubbleLegend, o = iV(this.chart);
            e && e.ranges && e.ranges.length && (s.ranges.length && (s.autoRanges = !!s.ranges[0].autoRanges), this.destroyItem(e)), o >= 0 && i.enabled && s.enabled && (s.seriesIndex = o, this.bubbleLegend = new ik(s, this), this.bubbleLegend.addToLegend(t.allItems));
        }
        function iG(t) {
            let e;
            if (t.defaultPrevented) return !1;
            let i = t.legendItem, s = this.chart, o = i.visible;
            this && this.bubbleLegend && (i.visible = !o, i.ignoreSeries = o, e = iV(s) >= 0, this.bubbleLegend.visible !== e && (this.update({
                bubbleLegend: {
                    enabled: e
                }
            }), this.bubbleLegend.visible = e), i.visible = o);
        }
        function iX(t, e) {
            let i = t.allItems, s = t.options.rtl, o, r, a, n, l = 0;
            i.forEach((t, i)=>{
                (n = t.legendItem || {}).group && (o = n.group.translateX || 0, r = n.y || 0, ((a = t.movementX) || s && t.ranges) && (a = s ? o - t.options.maxSize / 2 : o + a, n.group.attr({
                    translateX: a
                })), i > e[l].step && l++, n.group.attr({
                    translateY: Math.round(r + e[l].height / 2)
                }), n.y = r + e[l].height / 2);
            });
        }
        let iR = {
            compose: function(t, e) {
                iB(iz, "Series.BubbleLegend") && (ij({
                    legend: {
                        bubbleLegend: ix
                    }
                }), iE(t.prototype, "drawChartBox", iD), iS(e, "afterGetAllItems", iN), iS(e, "itemClick", iG));
            }
        };
        var iH = w(260), iW = w.n(iH);
        let { seriesTypes: { scatter: { prototype: { pointClass: iY } } } } = W(), { extend: iU } = L();
        class iF extends iY {
            haloPath(t) {
                let e = (t && this.marker && this.marker.radius || 0) + t;
                if (this.series.chart.inverted) {
                    let t = this.pos() || [
                        0,
                        0
                    ], { xAxis: i, yAxis: s, chart: o } = this.series;
                    return o.renderer.symbols.circle(i.len - t[1] - e, s.len - t[0] - e, 2 * e, 2 * e);
                }
                return iW().prototype.haloPath.call(this, e);
            }
        }
        iU(iF.prototype, {
            ttBelow: !1
        });
        let iZ = iF, { parse: i_ } = j(), { composed: iK, noop: iq } = L(), { series: i$, seriesTypes: { column: { prototype: iJ }, scatter: iQ } } = W(), { addEvent: i0, arrayMax: i1, arrayMin: i2, clamp: i6, extend: i3, isNumber: i8, merge: i7, pick: i9, pushUnique: i4 } = L();
        function i5() {
            let t = this.len, { coll: e, isXAxis: i, min: s } = this, o = (this.max || 0) - (s || 0), r = 0, a = t, n = t / o, l;
            ("xAxis" === e || "yAxis" === e) && (this.series.forEach((t)=>{
                if (t.bubblePadding && t.reserveSpace()) {
                    this.allowZoomOutside = !0, l = !0;
                    let e = t.getColumn(i ? "x" : "y");
                    if (i && ((t.onPoint || t).getRadii(0, 0, t), t.onPoint && (t.radii = t.onPoint.radii)), o > 0) {
                        let i = e.length;
                        for(; i--;)if (i8(e[i]) && this.dataMin <= e[i] && e[i] <= this.max) {
                            let o = t.radii && t.radii[i] || 0;
                            r = Math.min((e[i] - s) * n - o, r), a = Math.max((e[i] - s) * n + o, a);
                        }
                    }
                }
            }), l && o > 0 && !this.logarithmic && (a -= t, n *= (t + Math.max(0, r) - Math.min(a, t)) / t, [
                [
                    "min",
                    "userMin",
                    r
                ],
                [
                    "max",
                    "userMax",
                    a
                ]
            ].forEach((t)=>{
                void 0 === i9(this.options[t[0]], this[t[1]]) && (this[t[0]] += t[2] / n);
            })));
        }
        function st() {
            let { ticks: t, tickPositions: e, dataMin: i = 0, dataMax: s = 0, categories: o } = this, r = this.options.type;
            if ((o?.length || "category" === r) && this.series.find((t)=>t.bubblePadding)) {
                let o = e.length;
                for(; o--;){
                    let r = t[e[o]], a = r.pos || 0;
                    (a > s || a < i) && r.label?.hide();
                }
            }
        }
        class se extends iQ {
            static compose(t, e, i) {
                iR.compose(e, i), i4(iK, "Series.Bubble") && (i0(t, "foundExtremes", i5), i0(t, "afterRender", st));
            }
            animate(t) {
                !t && this.points.length < this.options.animationLimit && this.points.forEach(function(t) {
                    let { graphic: e, plotX: i = 0, plotY: s = 0 } = t;
                    e && e.width && (this.hasRendered || e.attr({
                        x: i,
                        y: s,
                        width: 1,
                        height: 1
                    }), e.animate(this.markerAttribs(t), this.options.animation));
                }, this);
            }
            getRadii() {
                let t = this.getColumn("z"), e = this.getColumn("y"), i = [], s, o, r, a = this.chart.bubbleZExtremes, { minPxSize: n, maxPxSize: l } = this.getPxExtremes();
                if (!a) {
                    let t, e = Number.MAX_VALUE, i = -Number.MAX_VALUE;
                    this.chart.series.forEach((s)=>{
                        if (s.bubblePadding && s.reserveSpace()) {
                            let o = (s.onPoint || s).getZExtremes();
                            o && (e = Math.min(i9(e, o.zMin), o.zMin), i = Math.max(i9(i, o.zMax), o.zMax), t = !0);
                        }
                    }), t ? (a = {
                        zMin: e,
                        zMax: i
                    }, this.chart.bubbleZExtremes = a) : a = {
                        zMin: 0,
                        zMax: 0
                    };
                }
                for(o = 0, s = t.length; o < s; o++)r = t[o], i.push(this.getRadius(a.zMin, a.zMax, n, l, r, e && e[o]));
                this.radii = i;
            }
            getRadius(t, e, i, s, o, r) {
                let a = this.options, n = "width" !== a.sizeBy, l = a.zThreshold, h = e - t, p = .5;
                if (null === r || null === o) return null;
                if (i8(o)) {
                    if (a.sizeByAbsoluteValue && (o = Math.abs(o - l), e = h = Math.max(e - l, Math.abs(t - l)), t = 0), o < t) return i / 2 - 1;
                    h > 0 && (p = (o - t) / h);
                }
                return n && p >= 0 && (p = Math.sqrt(p)), Math.ceil(i + p * (s - i)) / 2;
            }
            hasData() {
                return !!this.dataTable.rowCount;
            }
            markerAttribs(t, e) {
                let i = super.markerAttribs(t, e), { height: s = 0, width: o = 0 } = i;
                return this.chart.inverted ? i3(i, {
                    x: (t.plotX || 0) - o / 2,
                    y: (t.plotY || 0) - s / 2
                }) : i;
            }
            pointAttribs(t, e) {
                let i = this.options.marker.fillOpacity, s = i$.prototype.pointAttribs.call(this, t, e);
                return 1 !== i && (s.fill = i_(s.fill).setOpacity(i).get("rgba")), s;
            }
            translate() {
                super.translate.call(this), this.getRadii(), this.translateBubble();
            }
            translateBubble() {
                let { data: t, options: e, radii: i } = this, { minPxSize: s } = this.getPxExtremes(), o = t.length;
                for(; o--;){
                    let r = t[o], a = i ? i[o] : 0;
                    "z" === this.zoneAxis && (r.negative = (r.z || 0) < (e.zThreshold || 0)), i8(a) && a >= s / 2 ? (r.marker = i3(r.marker, {
                        radius: a,
                        width: 2 * a,
                        height: 2 * a
                    }), r.dlBox = {
                        x: r.plotX - a,
                        y: r.plotY - a,
                        width: 2 * a,
                        height: 2 * a
                    }) : (r.shapeArgs = r.plotY = r.dlBox = void 0, r.isInside = !1);
                }
            }
            getPxExtremes() {
                let t = Math.min(this.chart.plotWidth, this.chart.plotHeight), e = (e)=>{
                    let i;
                    return "string" == typeof e && (i = /%$/.test(e), e = parseInt(e, 10)), i ? t * e / 100 : e;
                }, i = e(i9(this.options.minSize, 8)), s = Math.max(e(i9(this.options.maxSize, "20%")), i);
                return {
                    minPxSize: i,
                    maxPxSize: s
                };
            }
            getZExtremes() {
                let t = this.options, e = this.getColumn("z").filter(i8);
                if (e.length) {
                    let i = i9(t.zMin, i6(i2(e), !1 === t.displayNegative ? t.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE)), s = i9(t.zMax, i1(e));
                    if (i8(i) && i8(s)) return {
                        zMin: i,
                        zMax: s
                    };
                }
            }
            searchKDTree(t, e, i, s = iq, o = iq) {
                return s = (t, e, i)=>{
                    let s = t[i] || 0, o = e[i] || 0, r, a = !1;
                    return s < 0 && o < 0 ? (r = s - (t.marker?.radius || 0) >= o - (e.marker?.radius || 0) ? t : e, a = !0) : r = s < o ? t : e, [
                        r,
                        a
                    ];
                }, o = (t, e, i)=>!i && t > e || t < e, super.searchKDTree(t, e, i, s, o);
            }
        }
        se.defaultOptions = i7(iQ.defaultOptions, {
            dataLabels: {
                formatter: function() {
                    let { numberFormatter: t } = this.series.chart, { z: e } = this.point;
                    return i8(e) ? t(e, -1) : "";
                },
                inside: !0,
                verticalAlign: "middle"
            },
            animationLimit: 250,
            marker: {
                lineColor: null,
                lineWidth: 1,
                fillOpacity: .5,
                radius: null,
                states: {
                    hover: {
                        radiusPlus: 0
                    }
                },
                symbol: "circle"
            },
            minSize: 8,
            maxSize: "20%",
            softThreshold: !1,
            states: {
                hover: {
                    halo: {
                        size: 5
                    }
                }
            },
            tooltip: {
                pointFormat: "({point.x}, {point.y}), Size: {point.z}"
            },
            turboThreshold: 0,
            zThreshold: 0,
            zoneAxis: "z"
        }), i3(se.prototype, {
            alignDataLabel: iJ.alignDataLabel,
            applyZones: iq,
            bubblePadding: !0,
            isBubble: !0,
            keysAffectYAxis: [
                "y"
            ],
            pointArrayMap: [
                "y",
                "z"
            ],
            pointClass: iZ,
            parallelArrays: [
                "x",
                "y",
                "z"
            ],
            trackerGroups: [
                "group",
                "dataLabelsGroup"
            ],
            specialGroup: "group",
            zoneAxis: "z"
        }), i0(se, "updatedData", (t)=>{
            delete t.target.chart.bubbleZExtremes;
        }), i0(se, "remove", (t)=>{
            delete t.target.chart.bubbleZExtremes;
        }), W().registerSeriesType("bubble", se);
        let si = se, { seriesTypes: { map: { prototype: { pointClass: { prototype: ss } } } } } = W(), { extend: so } = L();
        class sr extends iZ {
            isValid() {
                return "number" == typeof this.z;
            }
        }
        so(sr.prototype, {
            applyOptions: ss.applyOptions,
            getProjectedBounds: ss.getProjectedBounds
        });
        let { seriesTypes: { map: { prototype: sa }, mappoint: { prototype: sn } } } = W(), { extend: sl, merge: sh } = L();
        class sp extends si {
            constructor(){
                super(...arguments), this.clearBounds = sa.clearBounds;
            }
            searchPoint(t, e) {
                return this.searchKDTree({
                    plotX: t.chartX - this.chart.plotLeft,
                    plotY: t.chartY - this.chart.plotTop
                }, e, t);
            }
            translate() {
                sn.translate.call(this), this.getRadii(), this.translateBubble();
            }
        }
        sp.defaultOptions = sh(si.defaultOptions, {
            lineWidth: 0,
            animationLimit: 500,
            joinBy: "hc-key",
            tooltip: {
                pointFormat: "{point.name}: {point.z}"
            }
        }), sl(sp.prototype, {
            type: "mapbubble",
            axisTypes: [
                "colorAxis"
            ],
            getProjectedBounds: sa.getProjectedBounds,
            isCartesian: !1,
            pointArrayMap: [
                "z"
            ],
            pointClass: sr,
            processData: sa.processData,
            projectPoint: sn.projectPoint,
            kdAxisArray: [
                "plotX",
                "plotY"
            ],
            setData: sa.setData,
            setOptions: sa.setOptions,
            updateData: sa.updateData,
            useMapGeometry: !0,
            xyFromShape: !0
        }), W().registerSeriesType("mapbubble", sp);
        let { scatter: { prototype: { pointClass: sd } } } = W().seriesTypes, { clamp: sc, defined: su, extend: sm, pick: sg } = L();
        class sf extends sd {
            applyOptions(t, e) {
                return (this.isNull || null === this.value) && delete this.color, super.applyOptions(t, e), this.formatPrefix = this.isNull || null === this.value ? "null" : "point", this;
            }
            getCellAttributes() {
                let t = this.series, e = t.options, i = (e.colsize || 1) / 2, s = (e.rowsize || 1) / 2, o = t.xAxis, r = t.yAxis, a = this.options.marker || t.options.marker, n = t.pointPlacementToXValue(), l = sg(this.pointPadding, e.pointPadding, 0), h = {
                    x1: sc(Math.round(o.len - o.translate(this.x - i, !1, !0, !1, !0, -n)), -o.len, 2 * o.len),
                    x2: sc(Math.round(o.len - o.translate(this.x + i, !1, !0, !1, !0, -n)), -o.len, 2 * o.len),
                    y1: sc(Math.round(r.translate(this.y - s, !1, !0, !1, !0)), -r.len, 2 * r.len),
                    y2: sc(Math.round(r.translate(this.y + s, !1, !0, !1, !0)), -r.len, 2 * r.len)
                };
                for (let t of [
                    [
                        "width",
                        "x"
                    ],
                    [
                        "height",
                        "y"
                    ]
                ]){
                    let e = t[0], i = t[1], s = i + "1", n = i + "2", p = Math.abs(h[s] - h[n]), d = a && a.lineWidth || 0, c = Math.abs(h[s] + h[n]) / 2, u = a && a[e];
                    if (su(u) && u < p) {
                        let t = u / 2 + d / 2;
                        h[s] = c - t, h[n] = c + t;
                    }
                    l && (("x" === i && o.reversed || "y" === i && !r.reversed) && (s = n, n = i + "1"), h[s] += l, h[n] -= l);
                }
                return h;
            }
            haloPath(t) {
                if (!t) return [];
                let { x: e = 0, y: i = 0, width: s = 0, height: o = 0 } = this.shapeArgs || {};
                return [
                    [
                        "M",
                        e - t,
                        i - t
                    ],
                    [
                        "L",
                        e - t,
                        i + o + t
                    ],
                    [
                        "L",
                        e + s + t,
                        i + o + t
                    ],
                    [
                        "L",
                        e + s + t,
                        i - t
                    ],
                    [
                        "Z"
                    ]
                ];
            }
            isValid() {
                return this.value !== 1 / 0 && this.value !== -1 / 0;
            }
        }
        sm(sf.prototype, {
            dataLabelOnNull: !0,
            moveToTopOnHover: !0,
            ttBelow: !1
        });
        let { isNumber: sb } = L(), { doc: sy } = L(), { defined: sx, pick: sM } = L(), { series: sv, seriesTypes: { column: sw, scatter: sC } } = W(), { prototype: { symbols: sT } } = tN(), { addEvent: sL, extend: sP, fireEvent: sA, isNumber: sk, merge: sj, pick: sz } = L(), { colorFromPoint: sS, getContext: sI } = {
            colorFromPoint: function(t, e) {
                let i = e.series.colorAxis;
                if (i) {
                    let s = i.toColor(t || 0, e).split(")")[0].split("(")[1].split(",").map((t)=>sM(parseFloat(t), parseInt(t, 10)));
                    return s[3] = 255 * sM(s[3], 1), sx(t) && e.visible || (s[3] = 0), s;
                }
                return [
                    0,
                    0,
                    0,
                    0
                ];
            },
            getContext: function(t) {
                let { canvas: e, context: i } = t;
                return e && i ? (i.clearRect(0, 0, e.width, e.height), i) : (t.canvas = sy.createElement("canvas"), t.context = t.canvas.getContext("2d", {
                    willReadFrequently: !0
                }) || void 0, t.context);
            }
        };
        class sB extends sC {
            constructor(){
                super(...arguments), this.valueMax = NaN, this.valueMin = NaN, this.isDirtyCanvas = !0;
            }
            drawPoints() {
                let t = this, e = t.options, i = e.interpolation, s = e.marker || {};
                if (i) {
                    let { image: e, chart: i, xAxis: s, yAxis: o } = t, { reversed: r = !1, len: a } = s, { reversed: n = !1, len: l } = o, h = {
                        width: a,
                        height: l
                    };
                    if (!e || t.isDirtyData || t.isDirtyCanvas) {
                        let a = sI(t), { canvas: l, options: { colsize: p = 1, rowsize: d = 1 }, points: c, points: { length: u } } = t, m = i.colorAxis && i.colorAxis[0];
                        if (l && a && m) {
                            let { min: m, max: g } = s.getExtremes(), { min: f, max: b } = o.getExtremes(), y = g - m, x = b - f, M = Math.round(y / p / 8 * 8), v = Math.round(x / d / 8 * 8), [w, C] = [
                                [
                                    M,
                                    M / y,
                                    r,
                                    "ceil"
                                ],
                                [
                                    v,
                                    v / x,
                                    !n,
                                    "floor"
                                ]
                            ].map(([t, e, i, s])=>i ? (i)=>Math[s](t - e * i) : (t)=>Math[s](e * t)), T = l.width = M + 1, L = T * (l.height = v + 1), P = (u - 1) / L, A = new Uint8ClampedArray(4 * L), k = (t, e)=>4 * Math.ceil(T * C(e - f) + w(t - m));
                            t.buildKDTree();
                            for(let t = 0; t < L; t++){
                                let e = c[Math.ceil(P * t)], { x: i, y: s } = e;
                                A.set(sS(e.value, e), k(i, s));
                            }
                            a.putImageData(new ImageData(A, T), 0, 0), e ? e.attr({
                                ...h,
                                href: l.toDataURL("image/png", 1)
                            }) : (t.directTouch = !1, t.image = i.renderer.image(l.toDataURL("image/png", 1)).attr(h).add(t.group));
                        }
                        t.isDirtyCanvas = !1;
                    } else (e.width !== a || e.height !== l) && e.attr(h);
                } else (s.enabled || t._hasPointMarkers) && (sv.prototype.drawPoints.call(t), t.points.forEach((e)=>{
                    e.graphic && (e.graphic[t.chart.styledMode ? "css" : "animate"](t.colorAttribs(e)), null === e.value && e.graphic.addClass("highcharts-null-point"));
                }));
            }
            getExtremes() {
                let { dataMin: t, dataMax: e } = sv.prototype.getExtremes.call(this, this.getColumn("value"));
                return sk(t) && (this.valueMin = t), sk(e) && (this.valueMax = e), sv.prototype.getExtremes.call(this);
            }
            getValidPoints(t, e) {
                return sv.prototype.getValidPoints.call(this, t, e, !0);
            }
            hasData() {
                return !!this.dataTable.rowCount;
            }
            init() {
                super.init.apply(this, arguments);
                let t = this.options;
                t.pointRange = sz(t.pointRange, t.colsize || 1), this.yAxis.axisPointRange = t.rowsize || 1, sT.ellipse = sT.circle, t.marker && sk(t.borderRadius) && (t.marker.r = t.borderRadius);
            }
            markerAttribs(t, e) {
                let i = t.shapeArgs || {};
                if (t.hasImage) return {
                    x: t.plotX,
                    y: t.plotY
                };
                if (e && "normal" !== e) {
                    let s = t.options.marker || {}, o = this.options.marker || {}, r = o.states && o.states[e] || {}, a = s.states && s.states[e] || {}, n = (a.width || r.width || i.width || 0) + (a.widthPlus || r.widthPlus || 0), l = (a.height || r.height || i.height || 0) + (a.heightPlus || r.heightPlus || 0);
                    return {
                        x: (i.x || 0) + ((i.width || 0) - n) / 2,
                        y: (i.y || 0) + ((i.height || 0) - l) / 2,
                        width: n,
                        height: l
                    };
                }
                return i;
            }
            pointAttribs(t, e) {
                let i = sv.prototype.pointAttribs.call(this, t, e), s = this.options || {}, o = this.chart.options.plotOptions || {}, r = o.series || {}, a = o.heatmap || {}, n = t && t.options.borderColor || s.borderColor || a.borderColor || r.borderColor, l = t && t.options.borderWidth || s.borderWidth || a.borderWidth || r.borderWidth || i["stroke-width"];
                if (i.stroke = t && t.marker && t.marker.lineColor || s.marker && s.marker.lineColor || n || this.color, i["stroke-width"] = l, e && "normal" !== e) {
                    let o = sj(s.states && s.states[e], s.marker && s.marker.states && s.marker.states[e], t && t.options.states && t.options.states[e] || {});
                    i.fill = o.color || j().parse(i.fill).brighten(o.brightness || 0).get(), i.stroke = o.lineColor || i.stroke;
                }
                return i;
            }
            translate() {
                let { borderRadius: t, marker: e } = this.options, i = e && e.symbol || "rect", s = sT[i] ? i : "rect", o = -1 !== [
                    "circle",
                    "square"
                ].indexOf(s);
                for (let e of (this.generatePoints(), this.points)){
                    let r = e.getCellAttributes(), a = Math.min(r.x1, r.x2), n = Math.min(r.y1, r.y2), l = Math.max(Math.abs(r.x2 - r.x1), 0), h = Math.max(Math.abs(r.y2 - r.y1), 0);
                    if (e.hasImage = 0 === (e.marker && e.marker.symbol || i || "").indexOf("url"), o) {
                        let t = Math.abs(l - h);
                        a = Math.min(r.x1, r.x2) + (l < h ? 0 : t / 2), n = Math.min(r.y1, r.y2) + (l < h ? t / 2 : 0), l = h = Math.min(l, h);
                    }
                    e.hasImage && (e.marker = {
                        width: l,
                        height: h
                    }), e.plotX = e.clientX = (r.x1 + r.x2) / 2, e.plotY = (r.y1 + r.y2) / 2, e.shapeType = "path", e.shapeArgs = sj(!0, {
                        x: a,
                        y: n,
                        width: l,
                        height: h
                    }, {
                        d: sT[s](a, n, l, h, {
                            r: sk(t) ? t : 0
                        })
                    });
                }
                sA(this, "afterTranslate");
            }
        }
        sB.defaultOptions = sj(sC.defaultOptions, {
            animation: !1,
            borderRadius: 0,
            borderWidth: 0,
            interpolation: !1,
            nullColor: "#f7f7f7",
            dataLabels: {
                formatter: function() {
                    let { numberFormatter: t } = this.series.chart, { value: e } = this.point;
                    return sb(e) ? t(e, -1) : "";
                },
                inside: !0,
                verticalAlign: "middle",
                crop: !1,
                overflow: "allow",
                padding: 0
            },
            marker: {
                symbol: "rect",
                radius: 0,
                lineColor: void 0,
                states: {
                    hover: {
                        lineWidthPlus: 0
                    },
                    select: {}
                }
            },
            clip: !0,
            pointRange: null,
            tooltip: {
                pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
            },
            states: {
                hover: {
                    halo: !1,
                    brightness: .2
                }
            },
            legendSymbol: "rectangle"
        }), sL(sB, "afterDataClassLegendClick", function() {
            this.isDirtyCanvas = !0, this.drawPoints();
        }), sP(sB.prototype, {
            axisTypes: tP.seriesMembers.axisTypes,
            colorKey: tP.seriesMembers.colorKey,
            directTouch: !0,
            getExtremesFromAll: !0,
            keysAffectYAxis: [
                "y"
            ],
            parallelArrays: tP.seriesMembers.parallelArrays,
            pointArrayMap: [
                "y",
                "value"
            ],
            pointClass: sf,
            specialGroup: "group",
            trackerGroups: tP.seriesMembers.trackerGroups,
            alignDataLabel: sw.prototype.alignDataLabel,
            colorAttribs: tP.seriesMembers.colorAttribs,
            getSymbol: sv.prototype.getSymbol
        }), tP.compose(sB), W().registerSeriesType("heatmap", sB); /**
 * @license Highmaps JS v12.1.2 (2024-12-21)
 * @module highcharts/modules/map
 * @requires highcharts
 *
 * Highmaps as a plugin for Highcharts or Highcharts Stock.
 *
 * (c) 2011-2024 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */ 
        let sE = L();
        sE.ColorMapComposition = tP, sE.MapChart = sE.MapChart || tY, sE.MapNavigation = sE.MapNavigation || tM, sE.MapView = sE.MapView || eU, sE.Projection = sE.Projection || eL, sE.mapChart = sE.Map = sE.MapChart.mapChart, sE.maps = sE.MapChart.maps, sE.geojson = t4.geojson, sE.topo2geo = t4.topo2geo, t4.compose(sE.Chart), sp.compose(sE.Axis, sE.Chart, sE.Legend), tM.compose(tY, sE.Pointer, sE.SVGRenderer), eU.compose(tY);
        let sD = L();
        return C.default;
    })());
}}),
"[project]/node_modules/highcharts/modules/drilldown.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
!/**
 * Highcharts JS v12.1.2 (2024-12-21)
 * @module highcharts/modules/drilldown
 * @requires highcharts
 *
 * Highcharts Drilldown module
 *
 * Author: Torstein Honsi
 * License: www.highcharts.com/license
 *
 */ function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = e(t._Highcharts, t._Highcharts.Templating, t._Highcharts.Color) : ("TURBOPACK unreachable", undefined);
}("undefined" == typeof window ? this : window, (t, e, i)=>(()=>{
        "use strict";
        var o, l = {
            620: (t)=>{
                t.exports = i;
            },
            984: (t)=>{
                t.exports = e;
            },
            944: (e)=>{
                e.exports = t;
            }
        }, r = {};
        function s(t) {
            var e = r[t];
            if (void 0 !== e) return e.exports;
            var i = r[t] = {
                exports: {}
            };
            return l[t](i, i.exports, s), i.exports;
        }
        s.n = (t)=>{
            var e = t && t.__esModule ? ()=>t.default : ()=>t;
            return s.d(e, {
                a: e
            }), e;
        }, s.d = (t, e)=>{
            for(var i in e)s.o(e, i) && !s.o(t, i) && Object.defineProperty(t, i, {
                enumerable: !0,
                get: e[i]
            });
        }, s.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e);
        var n = {};
        s.d(n, {
            default: ()=>tx
        });
        var a = s(944), d = s.n(a);
        let p = {
            lang: {
                mainBreadcrumb: "Main"
            },
            options: {
                buttonTheme: {
                    fill: "none",
                    height: 18,
                    padding: 2,
                    "stroke-width": 0,
                    zIndex: 7,
                    states: {
                        select: {
                            fill: "none"
                        }
                    },
                    style: {
                        color: "#334eff"
                    }
                },
                buttonSpacing: 5,
                floating: !1,
                format: void 0,
                relativeTo: "plotBox",
                rtl: !1,
                position: {
                    align: "left",
                    verticalAlign: "top",
                    x: 0,
                    y: void 0
                },
                separator: {
                    text: "/",
                    style: {
                        color: "#666666",
                        fontSize: "0.8em"
                    }
                },
                showFullPath: !0,
                style: {},
                useHTML: !1,
                zIndex: 7
            }
        };
        var h = s(984);
        let { format: u } = s.n(h)(), { composed: c } = d(), { addEvent: m, defined: w, extend: g, fireEvent: f, isString: b, merge: v, objectEach: y, pick: x, pushUnique: D } = d();
        function S() {
            if (this.breadcrumbs) {
                let t = this.resetZoomButton && this.resetZoomButton.getBBox(), e = this.breadcrumbs.options;
                t && "right" === e.position.align && "plotBox" === e.relativeTo && this.breadcrumbs.alignBreadcrumbsGroup(-t.width - e.buttonSpacing);
            }
        }
        function B() {
            this.breadcrumbs && (this.breadcrumbs.destroy(), this.breadcrumbs = void 0);
        }
        function L() {
            let t = this.breadcrumbs;
            if (t && !t.options.floating && t.level) {
                let e = t.options, i = e.buttonTheme, o = (i.height || 0) + 2 * (i.padding || 0) + e.buttonSpacing, l = e.position.verticalAlign;
                "bottom" === l ? (this.marginBottom = (this.marginBottom || 0) + o, t.yOffset = o) : "middle" !== l ? (this.plotTop += o, t.yOffset = -o) : t.yOffset = void 0;
            }
        }
        function O() {
            this.breadcrumbs && this.breadcrumbs.redraw();
        }
        function A(t) {
            !0 === t.resetSelection && this.breadcrumbs && this.breadcrumbs.alignBreadcrumbsGroup();
        }
        class T {
            static compose(t, e) {
                D(c, "Breadcrumbs") && (m(t, "destroy", B), m(t, "afterShowResetZoom", S), m(t, "getMargins", L), m(t, "redraw", O), m(t, "selection", A), g(e.lang, p.lang));
            }
            constructor(t, e){
                this.elementList = {}, this.isDirty = !0, this.level = 0, this.list = [];
                let i = v(t.options.drilldown && t.options.drilldown.drillUpButton, T.defaultOptions, t.options.navigation && t.options.navigation.breadcrumbs, e);
                this.chart = t, this.options = i || {};
            }
            updateProperties(t) {
                this.setList(t), this.setLevel(), this.isDirty = !0;
            }
            setList(t) {
                this.list = t;
            }
            setLevel() {
                this.level = this.list.length && this.list.length - 1;
            }
            getLevel() {
                return this.level;
            }
            getButtonText(t) {
                let e = this.chart, i = this.options, o = e.options.lang, l = x(i.format, i.showFullPath ? "{level.name}" : " {level.name}"), r = o && x(o.drillUpText, o.mainBreadcrumb), s = i.formatter && i.formatter(t) || u(l, {
                    level: t.levelOptions
                }, e) || "";
                return (b(s) && !s.length || " " === s) && w(r) && (s = i.showFullPath ? r : " " + r), s;
            }
            redraw() {
                this.isDirty && this.render(), this.group && this.group.align(), this.isDirty = !1;
            }
            render() {
                let t = this.chart, e = this.options;
                !this.group && e && (this.group = t.renderer.g("breadcrumbs-group").addClass("highcharts-no-tooltip highcharts-breadcrumbs").attr({
                    zIndex: e.zIndex
                }).add()), e.showFullPath ? this.renderFullPathButtons() : this.renderSingleButton(), this.alignBreadcrumbsGroup();
            }
            renderFullPathButtons() {
                this.destroySingleButton(), this.resetElementListState(), this.updateListElements(), this.destroyListElements();
            }
            renderSingleButton() {
                let t = this.chart, e = this.list, i = this.options.buttonSpacing;
                this.destroyListElements();
                let o = this.group ? this.group.getBBox().width : i, l = e[e.length - 2];
                !t.drillUpButton && this.level > 0 ? t.drillUpButton = this.renderButton(l, o, i) : t.drillUpButton && (this.level > 0 ? this.updateSingleButton() : this.destroySingleButton());
            }
            alignBreadcrumbsGroup(t) {
                if (this.group) {
                    let e = this.options, i = e.buttonTheme, o = e.position, l = "chart" === e.relativeTo || "spacingBox" === e.relativeTo ? void 0 : "plotBox", r = this.group.getBBox(), s = 2 * (i.padding || 0) + e.buttonSpacing;
                    o.width = r.width + s, o.height = r.height + s;
                    let n = v(o);
                    t && (n.x += t), this.options.rtl && (n.x += o.width), n.y = x(n.y, this.yOffset, 0), this.group.align(n, !0, l);
                }
            }
            renderButton(t, e, i) {
                let o = this, l = this.chart, r = o.options, s = v(r.buttonTheme), n = l.renderer.button(o.getButtonText(t), e, i, function(e) {
                    let i;
                    let l = r.events && r.events.click;
                    l && (i = l.call(o, e, t)), !1 !== i && (r.showFullPath ? e.newLevel = t.level : e.newLevel = o.level - 1, f(o, "up", e));
                }, s).addClass("highcharts-breadcrumbs-button").add(o.group);
                return l.styledMode || n.attr(r.style), n;
            }
            renderSeparator(t, e) {
                let i = this.chart, o = this.options.separator, l = i.renderer.label(o.text, t, e, void 0, void 0, void 0, !1).addClass("highcharts-breadcrumbs-separator").add(this.group);
                return i.styledMode || l.css(o.style), l;
            }
            update(t) {
                v(!0, this.options, t), this.destroy(), this.isDirty = !0;
            }
            updateSingleButton() {
                let t = this.chart, e = this.list[this.level - 1];
                t.drillUpButton && t.drillUpButton.attr({
                    text: this.getButtonText(e)
                });
            }
            destroy() {
                this.destroySingleButton(), this.destroyListElements(!0), this.group && this.group.destroy(), this.group = void 0;
            }
            destroyListElements(t) {
                let e = this.elementList;
                y(e, (i, o)=>{
                    (t || !e[o].updated) && ((i = e[o]).button && i.button.destroy(), i.separator && i.separator.destroy(), delete i.button, delete i.separator, delete e[o]);
                }), t && (this.elementList = {});
            }
            destroySingleButton() {
                this.chart.drillUpButton && (this.chart.drillUpButton.destroy(), this.chart.drillUpButton = void 0);
            }
            resetElementListState() {
                y(this.elementList, (t)=>{
                    t.updated = !1;
                });
            }
            updateListElements() {
                let t = this.elementList, e = this.options.buttonSpacing, i = this.list, o = this.options.rtl, l = o ? -1 : 1, r = function(t, e) {
                    return l * t.getBBox().width + l * e;
                }, s = function(t, e, i) {
                    t.translate(e - t.getBBox().width, i);
                }, n = this.group ? r(this.group, e) : e, a, d;
                for(let p = 0, h = i.length; p < h; ++p){
                    let u, c;
                    let m = p === h - 1;
                    t[(d = i[p]).level] ? (u = (a = t[d.level]).button, a.separator || m ? a.separator && m && (a.separator.destroy(), delete a.separator) : (n += l * e, a.separator = this.renderSeparator(n, e), o && s(a.separator, n, e), n += r(a.separator, e)), t[d.level].updated = !0) : (u = this.renderButton(d, n, e), o && s(u, n, e), n += r(u, e), m || (c = this.renderSeparator(n, e), o && s(c, n, e), n += r(c, e)), t[d.level] = {
                        button: u,
                        separator: c,
                        updated: !0
                    }), u && u.setState(m ? 2 : 0);
                }
            }
        }
        T.defaultOptions = p.options;
        var C = s(620), E = s.n(C);
        let P = {
            activeAxisLabelStyle: {
                cursor: "pointer",
                color: "#0022ff",
                fontWeight: "bold",
                textDecoration: "underline"
            },
            activeDataLabelStyle: {
                cursor: "pointer",
                color: "#0022ff",
                fontWeight: "bold",
                textDecoration: "underline"
            },
            animation: {
                duration: 500
            },
            drillUpButton: {
                position: {
                    align: "right",
                    x: -10,
                    y: 10
                }
            },
            mapZooming: !0
        }, { animObject: M } = d(), { addEvent: I, extend: V, fireEvent: k, merge: _, pick: Z, syncTimeout: G } = d();
        function N(t, e, i, o) {
            t[i ? "addClass" : "removeClass"]("highcharts-drilldown-point"), o || t.css({
                cursor: e
            });
        }
        function U(t) {
            let e = this, i = e.chart, o = i.drilldownLevels, l = M((i.options.drilldown || {}).animation), r = this.xAxis, s = i.styledMode;
            if (!t) {
                let t;
                (o || []).forEach((i)=>{
                    e.options._ddSeriesId === i.lowerSeriesOptions._ddSeriesId && (t = i.shapeArgs, !s && t && (t.fill = i.color));
                }), t.x += Z(r.oldPos, r.pos) - r.pos, e.points.forEach((i)=>{
                    let o = i.shapeArgs;
                    s || (o.fill = i.color), i.graphic && i.graphic.attr(t).animate(V(i.shapeArgs, {
                        fill: i.color || e.color
                    }), l);
                }), i.drilldown && i.drilldown.fadeInGroup(this.dataLabelsGroup), delete this.animate;
            }
        }
        function j(t) {
            let e = this, i = M((e.chart.options.drilldown || {}).animation);
            (e.trackerGroups || []).forEach((t)=>{
                e[t] && e[t].on("mouseover");
            });
            let o = e.group, l = o !== e.chart.columnGroup;
            l && delete e.group, this.points.forEach((r)=>{
                let s = r.graphic, n = t.shapeArgs;
                if (s && n) {
                    let a = ()=>{
                        s.destroy(), o && l && (o = o.destroy());
                    };
                    delete r.graphic, e.chart.styledMode || (n.fill = t.color), i.duration ? s.animate(n, _(i, {
                        complete: a
                    })) : (s.attr(n), a());
                }
            });
        }
        function F(t) {
            let e = this, i = e.drilldownLevel;
            t || (e.points.forEach((t)=>{
                let e = t.dataLabel;
                t.graphic && t.graphic.hide(), e && (e.hidden = "hidden" === e.attr("visibility"), e.hidden || (e.hide(), e.connector?.hide()));
            }), G(()=>{
                if (e.points) {
                    let t = [];
                    e.data.forEach((e)=>{
                        t.push(e);
                    }), e.nodes && (t = t.concat(e.nodes)), t.forEach((t, e)=>{
                        let o = e === (i && i.pointIndex) ? "show" : "fadeIn", l = t.dataLabel;
                        t.graphic && t.visible && t.graphic[o]("show" === o || void 0), l && !l.hidden && (l.fadeIn(), l.connector?.fadeIn());
                    });
                }
            }, Math.max(e.chart.options.drilldown.animation.duration - 50, 0)), delete this.animate);
        }
        function H(t) {
            let e = this, i = e.chart, o = e.group;
            i && o && e.options && i.options.drilldown && i.options.drilldown.animation && (t && i.mapView ? (o.attr({
                opacity: .01
            }), i.mapView.allowTransformAnimation = !1, e.options.inactiveOtherPoints = !0, e.options.enableMouseTracking = !1) : (o.animate({
                opacity: 1
            }, i.options.drilldown.animation, ()=>{
                e.options && (e.options.inactiveOtherPoints = !1, e.options.enableMouseTracking = Z(e.userOptions && e.userOptions.enableMouseTracking, !0));
            }), i.drilldown && i.drilldown.fadeInGroup(this.dataLabelsGroup)));
        }
        function z() {
            let t = this.chart;
            t && t.mapView && (t.mapView.allowTransformAnimation = !1), this.options && (this.options.inactiveOtherPoints = !0);
        }
        function R(t) {
            let e = this.chart, i = this.group;
            e && i && (t ? (i.attr({
                opacity: .01
            }), this.options && (this.options.inactiveOtherPoints = !0)) : (i.animate({
                opacity: 1
            }, (e.options.drilldown || {}).animation), e.drilldown && e.drilldown.fadeInGroup(this.dataLabelsGroup)));
        }
        function W() {
            return this.drilldown && !this.unbindDrilldownClick && (this.unbindDrilldownClick = I(this, "click", J)), this;
        }
        function q() {
            let t = this.series, e = t.chart.styledMode;
            this.drilldown && t.halo && "hover" === this.state ? N(t.halo, "pointer", !0, e) : t.halo && N(t.halo, "auto", !1, e);
        }
        function J(t) {
            let e = this.series;
            e.xAxis && !1 === (e.chart.options.drilldown || {}).allowPointDrilldown ? e.xAxis.drilldownCategory(this.x, t) : this.runDrilldown(void 0, void 0, t);
        }
        function K(t) {
            let e = t.options || {};
            e.drilldown && !this.unbindDrilldownClick ? this.unbindDrilldownClick = I(this, "click", J) : !e.drilldown && void 0 !== e.drilldown && this.unbindDrilldownClick && (this.unbindDrilldownClick = this.unbindDrilldownClick());
        }
        function Q() {
            let t = this.chart, e = t.options.drilldown.activeDataLabelStyle, i = t.renderer, o = t.styledMode;
            for (let t of this.points){
                let l = t.options.dataLabels, r = Z(t.dlOptions, l && l.style, {});
                t.drilldown && t.dataLabel && ("contrast" !== e.color || o || (r.color = i.getContrast(t.color || this.color)), l && l.color && (r.color = l.color), t.dataLabel.addClass("highcharts-drilldown-data-label"), o || t.dataLabel.css(e).css(r));
            }
        }
        function X() {
            let t = this.chart.styledMode;
            for (let e of this.points)e.drilldown && e.graphic && N(e.graphic, "pointer", !0, t);
        }
        function Y(t) {
            let e = this.chart, i = this.points, o = e.drilldownLevels[e.drilldownLevels.length - 1], l = e.options.drilldown.animation;
            if (this.is("item") && (l.duration = 0), this.center) {
                let r = o.shapeArgs, s = r.start, n = (r.end - s) / this.points.length, a = e.styledMode;
                if (!t) {
                    let t, d;
                    for(let e = 0, p = i.length; e < p; ++e)t = (d = i[e]).shapeArgs, a || (r.fill = o.color, t.fill = d.color), d.graphic && d.graphic.attr(_(r, {
                        start: s + e * n,
                        end: s + (e + 1) * n
                    }))[l ? "animate" : "attr"](t, l);
                    e.drilldown && e.drilldown.fadeInGroup(this.dataLabelsGroup), delete this.animate;
                }
            }
        }
        function $() {
            this.runDrilldown();
        }
        function tt(t, e, i) {
            let o = this.series, l = o.chart, r = l.options.drilldown || {}, s = (r.series || []).length, n;
            for(l.ddDupes || (l.ddDupes = []), l.colorCounter = l.symbolCounter = 0; s-- && !n;)r.series && r.series[s].id === this.drilldown && this.drilldown && -1 === l.ddDupes.indexOf(this.drilldown) && (n = r.series[s], l.ddDupes.push(this.drilldown));
            k(l, "drilldown", {
                point: this,
                seriesOptions: n,
                category: e,
                originalEvent: i,
                points: void 0 !== e && o.xAxis.getDDPoints(e).slice(0)
            }, (e)=>{
                let i = e.point.series && e.point.series.chart, o = e.seriesOptions;
                i && o && (t ? i.addSingleSeriesAsDrilldown(e.point, o) : i.addSeriesAsDrilldown(e.point, o));
            });
        }
        let te = {
            compose: function(t, e) {
                let i = t.prototype.pointClass, o = i.prototype;
                if (!o.doDrilldown) {
                    let { column: l, map: r, pie: s } = e;
                    if (I(i, "afterInit", W), I(i, "afterSetState", q), I(i, "update", K), o.doDrilldown = $, o.runDrilldown = tt, I(t, "afterDrawDataLabels", Q), I(t, "afterDrawTracker", X), l) {
                        let t = l.prototype;
                        t.animateDrilldown = U, t.animateDrillupFrom = j, t.animateDrillupTo = F;
                    }
                    if (r) {
                        let t = r.prototype;
                        t.animateDrilldown = H, t.animateDrillupFrom = z, t.animateDrillupTo = R;
                    }
                    if (s) {
                        let t = s.prototype;
                        t.animateDrilldown = Y, t.animateDrillupFrom = j, t.animateDrillupTo = F;
                    }
                }
            }
        }, { animObject: ti } = d(), { noop: to } = d(), { addEvent: tl, defined: tr, diffObjects: ts, extend: tn, fireEvent: ta, merge: td, objectEach: tp, pick: th, removeEvent: tu, syncTimeout: tc } = d(), tm = 1;
        function tw(t, e) {
            this.getDDPoints(t).forEach(function(i) {
                i && i.series && i.series.visible && i.runDrilldown && i.runDrilldown(!0, t, e);
            }), this.chart.applyDrilldown();
        }
        function tg(t) {
            return this.ddPoints && this.ddPoints[t] || [];
        }
        function tf(t) {
            let e = [], i = t.drilldownLevels;
            return i && i.length && (e[0] || e.push({
                level: 0,
                levelOptions: i[0].seriesOptions
            }), i.forEach(function(t) {
                let i = e[e.length - 1];
                t.levelNumber + 1 > i.level && e.push({
                    level: t.levelNumber + 1,
                    levelOptions: td({
                        name: t.lowerSeries.name
                    }, t.pointOptions)
                });
            })), e;
        }
        class tb {
            constructor(t){
                this.chart = t;
            }
            addSeriesAsDrilldown(t, e) {
                let i = this.chart || this;
                if (ta(this, "addSeriesAsDrilldown", {
                    seriesOptions: e
                }), i.mapView) {
                    if (t.series.isDrilling = !0, i.series.forEach((t)=>{
                        t.options.inactiveOtherPoints = !0, t.dataLabelsGroup?.destroy(), delete t.dataLabelsGroup;
                    }), i.options.drilldown && !i.mapView.projection.hasGeoProjection && P && !tr(ts(i.options.drilldown, P).mapZooming) && (i.options.drilldown.mapZooming = !1), i.options.drilldown && i.options.drilldown.animation && i.options.drilldown.mapZooming) {
                        i.mapView.allowTransformAnimation = !0;
                        let o = ti(i.options.drilldown.animation);
                        if ("boolean" != typeof o) {
                            let l = o.complete, r = function(o) {
                                o && o.applyDrilldown && i.mapView && (i.addSingleSeriesAsDrilldown(t, e), i.applyDrilldown(), i.mapView.allowTransformAnimation = !1);
                            };
                            o.complete = function() {
                                l && l.apply(this, arguments), r.apply(this, arguments);
                            };
                        }
                        t.zoomTo(o);
                    } else i.addSingleSeriesAsDrilldown(t, e), i.applyDrilldown();
                } else i.addSingleSeriesAsDrilldown(t, e), i.applyDrilldown();
            }
            addSingleSeriesAsDrilldown(t, e) {
                let i = this.chart || this, o = t.series, l = o.xAxis, r = o.yAxis, s = i.styledMode ? {
                    colorIndex: th(t.colorIndex, o.colorIndex)
                } : {
                    color: t.color || o.color
                }, n = o.options._levelNumber || 0;
                i.drilldownLevels || (i.drilldownLevels = []), e = tn(tn({
                    _ddSeriesId: tm++
                }, s), e);
                let a = [], d = [], p;
                (p = i.drilldownLevels[i.drilldownLevels.length - 1]) && p.levelNumber !== n && (p = void 0), o.chart.series.forEach((t)=>{
                    t.xAxis === l && (t.options._ddSeriesId = t.options._ddSeriesId || tm++, t.options.colorIndex = t.colorIndex, t.options._levelNumber = t.options._levelNumber || n, p ? (a = p.levelSeries, d = p.levelSeriesOptions) : (a.push(t), t.purgedOptions = td({
                        _ddSeriesId: t.options._ddSeriesId,
                        _levelNumber: t.options._levelNumber,
                        selected: t.options.selected
                    }, t.userOptions), d.push(t.purgedOptions)));
                });
                let h = tn({
                    levelNumber: n,
                    seriesOptions: o.options,
                    seriesPurgedOptions: o.purgedOptions,
                    levelSeriesOptions: d,
                    levelSeries: a,
                    shapeArgs: t.shapeArgs,
                    bBox: t.graphic ? t.graphic.getBBox() : {},
                    color: t.isNull ? E().parse(s.color).setOpacity(0).get() : s.color,
                    lowerSeriesOptions: e,
                    pointOptions: t.options,
                    pointIndex: t.index,
                    oldExtremes: {
                        xMin: l && l.userMin,
                        xMax: l && l.userMax,
                        yMin: r && r.userMin,
                        yMax: r && r.userMax
                    },
                    resetZoomButton: p && p.levelNumber === n ? void 0 : i.resetZoomButton
                }, s);
                i.drilldownLevels.push(h), l && l.names && (l.names.length = 0);
                let u = h.lowerSeries = i.addSeries(e, !1);
                u.options._levelNumber = n + 1, l && (l.oldPos = l.pos, l.userMin = l.userMax = null, r.userMin = r.userMax = null), u.isDrilling = !0, o.type === u.type && (u.animate = u.animateDrilldown || to, u.options.animation = !0);
            }
            applyDrilldown() {
                let t;
                let e = this.chart || this, i = e.drilldownLevels;
                i && i.length > 0 && (t = i[i.length - 1].levelNumber, e.hasCartesianSeries = i.some((t)=>t.lowerSeries.isCartesian), (e.drilldownLevels || []).forEach((i)=>{
                    e.mapView && e.options.drilldown && e.options.drilldown.mapZooming && (e.redraw(), i.lowerSeries.isDrilling = !1, e.mapView.fitToBounds(i.lowerSeries.bounds), i.lowerSeries.isDrilling = !0), i.levelNumber === t && i.levelSeries.forEach((o)=>{
                        if (e.mapView) {
                            if (o.options && o.options._levelNumber === t && o.group) {
                                let t = {};
                                e.options.drilldown && (t = e.options.drilldown.animation), o.group.animate({
                                    opacity: 0
                                }, t, ()=>{
                                    o.remove(!1), i.levelSeries.filter((t)=>Object.keys(t).length).length || (e.resetZoomButton && (e.resetZoomButton.hide(), delete e.resetZoomButton), e.pointer?.reset(), ta(e, "afterDrilldown"), e.mapView && (e.series.forEach((t)=>{
                                        t.isDirtyData = !0, t.isDrilling = !1;
                                    }), e.mapView.fitToBounds(void 0, void 0), e.mapView.allowTransformAnimation = !0), ta(e, "afterApplyDrilldown"));
                                });
                            }
                        } else o.options && o.options._levelNumber === t && o.remove(!1);
                    });
                })), e.mapView || (e.resetZoomButton && (e.resetZoomButton.hide(), delete e.resetZoomButton), e.pointer?.reset(), ta(e, "afterDrilldown"), e.hasCartesianSeries || e.axes.forEach((t)=>{
                    t.destroy(!0), t.init(e, td(t.userOptions, t.options));
                }), e.redraw(), ta(e, "afterApplyDrilldown"));
            }
            drillUp(t) {
                let e = this.chart || this;
                if (!e.drilldownLevels || 0 === e.drilldownLevels.length) return;
                ta(e, "beforeDrillUp");
                let i = e.drilldownLevels, o = i[i.length - 1].levelNumber, l = e.series, r = e.drilldownLevels.length, s = (t, i)=>{
                    let o;
                    if (l.forEach((e)=>{
                        e.options._ddSeriesId === t._ddSeriesId && (o = e);
                    }), (o = o || e.addSeries(t, !1)).type === i.type && o.animateDrillupTo && (o.animate = o.animateDrillupTo), t === p.seriesPurgedOptions) return o;
                }, n = (t)=>{
                    t.remove(!1), e.series.forEach((t)=>{
                        t.colorAxis && (t.isDirtyData = !0), t.options.inactiveOtherPoints = !1;
                    }), e.redraw();
                }, a = i.length, d, p, h;
                for(e.symbolCounter = e.colorCounter = 0; a--;){
                    let u, c;
                    if ((p = i[a]).levelNumber === o) {
                        if (i.pop(), !(u = p.lowerSeries).chart) {
                            for(d = l.length; d--;)if (l[d].options.id === p.lowerSeriesOptions.id && l[d].options._levelNumber === o + 1) {
                                u = l[d];
                                break;
                            }
                        }
                        u.dataTable.setColumn("x", []), u.xAxis && u.xAxis.names && (0 === r || a === r - 1) && (u.xAxis.names.length = 0), p.levelSeriesOptions.forEach((t)=>{
                            let e = s(t, u);
                            e && (c = e);
                        }), ta(e, "drillup", {
                            seriesOptions: p.seriesPurgedOptions || p.seriesOptions
                        }), c && (c.type === u.type && (c.drilldownLevel = p, c.options.animation = e.options.drilldown.animation, u.animateDrillupFrom && u.chart && u.animateDrillupFrom(p)), c.options._levelNumber = o);
                        let m = u;
                        if (e.mapView || m.remove(!1), c && c.xAxis && (h = p.oldExtremes, c.xAxis.setExtremes(h.xMin, h.xMax, !1), c.yAxis.setExtremes(h.yMin, h.yMax, !1)), p.resetZoomButton && (e.resetZoomButton = p.resetZoomButton), e.mapView) {
                            let i = p.levelNumber === o && t, l = e.options.drilldown && e.options.drilldown.animation && e.options.drilldown.mapZooming;
                            i ? u.remove(!1) : (u.dataLabelsGroup && (u.dataLabelsGroup.destroy(), delete u.dataLabelsGroup), e.mapView && c && (l && (u.isDrilling = !0, c.isDrilling = !0, e.redraw(!1), e.mapView.fitToBounds(u.bounds, void 0, !0, !1)), e.mapView.allowTransformAnimation = !0, ta(e, "afterDrillUp", {
                                seriesOptions: c ? c.userOptions : void 0
                            }), l ? (e.mapView.setView(void 0, th(e.mapView.minZoom, 1), !0, {
                                complete: function() {
                                    Object.prototype.hasOwnProperty.call(this, "complete") && n(u);
                                }
                            }), c._hasTracking = !1) : (e.mapView.allowTransformAnimation = !1, u.group ? u.group.animate({
                                opacity: 0
                            }, e.options.drilldown.animation, ()=>{
                                n(u), e.mapView && (e.mapView.allowTransformAnimation = !0);
                            }) : (n(u), e.mapView.allowTransformAnimation = !0)), c.isDrilling = !1));
                        } else ta(e, "afterDrillUp");
                    }
                }
                e.mapView || e.redraw(), e.ddDupes && (e.ddDupes.length = 0), ta(e, "drillupall");
            }
            fadeInGroup(t) {
                let e = ti(this.chart.options.drilldown.animation);
                t && (t.hide(), tc(()=>{
                    t && t.added && t.fadeIn();
                }, Math.max(e.duration - 50, 0)));
            }
            update(t, e) {
                let i = this.chart;
                td(!0, i.options.drilldown, t), th(e, !0) && i.redraw();
            }
        }
        !function(t) {
            function e(t) {
                let e = this.chart, i = this.getLevel() - t.newLevel, o = i > 1;
                for(let t = 0; t < i; t++)t === i - 1 && (o = !1), e.drillUp(o);
            }
            function i() {
                let t = this.options.drilldown, e = t && t.breadcrumbs;
                this.breadcrumbs || (this.breadcrumbs = new T(this, e)), this.breadcrumbs.updateProperties(tf(this));
            }
            function o() {
                this.breadcrumbs && this.breadcrumbs.updateProperties(tf(this));
            }
            function l() {
                this.drilldown = new tb(this);
            }
            function r() {
                this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy());
            }
            function s() {
                this.resetZoomButton && this.showResetZoom();
            }
            function n() {
                (this.xAxis || []).forEach((t)=>{
                    t.ddPoints = {}, t.series.forEach((e)=>{
                        let i = e.getColumn("x"), o = e.points;
                        for(let l = 0, r = i.length, s; l < r; l++)if ("number" != typeof (s = e.options.data[l]) && (s = e.pointClass.prototype.optionsToObject.call({
                            series: e
                        }, s)).drilldown) {
                            t.ddPoints[i[l]] || (t.ddPoints[i[l]] = []);
                            let r = l - (e.cropStart || 0);
                            t.ddPoints[i[l]].push(!o || !(r >= 0) || !(r < o.length) || o[r]);
                        }
                    }), tp(t.ticks, (t)=>t.drillable());
                });
            }
            function a(t) {
                let e = this.breadcrumbs, i = t.options.drilldown && t.options.drilldown.breadcrumbs;
                e && i && e.update(i);
            }
            function d(t) {
                this.attr({
                    opacity: .1,
                    visibility: "inherit"
                }).animate({
                    opacity: th(this.newOpacity, 1)
                }, t || {
                    duration: 250
                });
            }
            function p() {
                let t = this.pos, e = this.label, i = this.axis, o = "xAxis" === i.coll && i.getDDPoints, l = o && i.getDDPoints(t), r = i.chart.styledMode;
                o && (e && l && l.length ? (e.drillable = !0, e.basicStyles || r || (e.basicStyles = td(e.styles)), e.addClass("highcharts-drilldown-axis-label"), e.removeOnDrillableClick && tu(e.element, "click"), e.removeOnDrillableClick = tl(e.element, "click", function(e) {
                    e.preventDefault(), i.drilldownCategory(t, e);
                }), !r && i.chart.options.drilldown && e.css(i.chart.options.drilldown.activeAxisLabelStyle || {})) : e && e.drillable && e.removeOnDrillableClick && (r || (e.styles = {}, e.element.removeAttribute("style"), e.css(e.basicStyles)), e.removeOnDrillableClick(), e.removeClass("highcharts-drilldown-axis-label")));
            }
            t.compose = function(t, h, u, c, m, w, g) {
                te.compose(c, m);
                let f = h.prototype;
                if (!f.drillUp) {
                    let c = w.prototype.Element, m = tb.prototype, b = t.prototype, v = c.prototype, y = g.prototype;
                    b.drilldownCategory = tw, b.getDDPoints = tg, T.compose(h, u), tl(T, "up", e), f.addSeriesAsDrilldown = m.addSeriesAsDrilldown, f.addSingleSeriesAsDrilldown = m.addSingleSeriesAsDrilldown, f.applyDrilldown = m.applyDrilldown, f.drillUp = m.drillUp, tl(h, "afterDrilldown", i), tl(h, "afterDrillUp", o), tl(h, "afterInit", l), tl(h, "drillup", r), tl(h, "drillupall", s), tl(h, "render", n), tl(h, "update", a), u.drilldown = P, v.fadeIn = d, y.drillable = p;
                }
            };
        }(o || (o = {}));
        let tv = o, ty = d();
        ty.Breadcrumbs = ty.Breadcrumbs || T, tv.compose(ty.Axis, ty.Chart, ty.defaultOptions, ty.Series, ty.seriesTypes, ty.SVGRenderer, ty.Tick);
        let tx = d();
        return n.default;
    })());
}}),
"[project]/node_modules/@highcharts/map-collection/custom/world.geo.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"title\":\"World, Miller projection, medium resolution\",\"version\":\"2.3.0\",\"type\":\"FeatureCollection\",\"copyright\":\"Copyright (c) 2024 Highsoft AS, Based on data from Natural Earth\",\"copyrightShort\":\"Natural Earth\",\"copyrightUrl\":\"http://www.naturalearthdata.com\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"urn:ogc:def:crs:EPSG:54003\"}},\"hc-transform\":{\"default\":{\"crs\":\"+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs\",\"scale\":0.0000172182781654,\"jsonres\":15.5,\"jsonmarginX\":-999,\"jsonmarginY\":9851.0,\"xoffset\":-19495356.3693,\"yoffset\":12635908.1982}},\"features\":[{\"type\":\"Feature\",\"id\":\"FO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.54,\"hc-key\":\"fo\",\"hc-a2\":\"FO\",\"name\":\"Faroe Islands\",\"labelrank\":\"6\",\"country-abbrev\":\"Faeroe Is.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"FRO\",\"iso-a2\":\"FO\",\"woe-id\":\"23424816\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3991,8611],[4005,8598],[4004,8594],[3989,8605],[3991,8611]]]}},{\"type\":\"Feature\",\"id\":\"UM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.57,\"hc-middle-y\":0.58,\"hc-key\":\"um\",\"hc-a2\":\"UM\",\"name\":\"United States Minor Outlying Islands\",\"labelrank\":\"5\",\"country-abbrev\":\"U.S. MOI\",\"subregion\":\"Seven seas (open ocean)\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"UMI\",\"iso-a2\":\"UM\",\"woe-id\":\"28289407\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[-605,6652],[-606,6652],[-606,6652],[-606,6652],[-605,6652]]]}},{\"type\":\"Feature\",\"id\":\"US\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.68,\"hc-middle-y\":0.68,\"hc-key\":\"us\",\"hc-a2\":\"US\",\"name\":\"United States of America\",\"labelrank\":\"2\",\"country-abbrev\":\"U.S.A.\",\"subregion\":\"Northern America\",\"region-wb\":\"North America\",\"iso-a3\":\"USA\",\"iso-a2\":\"US\",\"woe-id\":\"23424977\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[556,8034],[559,8032],[549,8036],[550,8040],[556,8034]]],[[[558,8043],[561,8042],[558,8039],[553,8040],[558,8043]]],[[[265,8289],[268,8289],[267,8283],[263,8288],[265,8289]]],[[[263,8300],[267,8295],[264,8292],[261,8294],[263,8300]]],[[[255,8300],[267,8279],[253,8290],[251,8302],[255,8300]]],[[[306,8298],[305,8293],[298,8293],[300,8304],[306,8298]]],[[[249,8306],[250,8302],[245,8301],[244,8305],[249,8306]]],[[[292,8310],[298,8305],[294,8298],[291,8308],[292,8310]]],[[[238,8311],[244,8313],[244,8308],[238,8304],[238,8311]]],[[[249,8311],[248,8310],[244,8314],[249,8314],[249,8311]]],[[[232,8330],[237,8337],[249,8340],[245,8335],[232,8330]]],[[[272,8342],[284,8338],[278,8330],[268,8336],[272,8342]]],[[[268,8353],[268,8346],[255,8348],[259,8353],[268,8353]]],[[[282,8349],[285,8339],[276,8346],[276,8355],[282,8349]]],[[[261,8368],[271,8358],[264,8355],[259,8356],[261,8368]]],[[[234,8379],[258,8373],[253,8353],[237,8353],[234,8379]]],[[[181,8386],[179,8377],[173,8376],[177,8383],[181,8386]]],[[[158,8420],[155,8412],[152,8416],[154,8423],[158,8420]]],[[[1578,8023],[1574,8018],[1559,8010],[1556,8013],[1578,8023]]],[[[1623,7918],[1621,7909],[1614,7899],[1610,7903],[1623,7918]]],[[[1667,7934],[1667,7928],[1663,7927],[1665,7933],[1667,7934]]],[[[1724,7944],[1726,7939],[1717,7939],[1721,7943],[1724,7944]]],[[[224,8331],[215,8369],[227,8371],[236,8359],[224,8331]]],[[[-726,8256],[-740,8233],[-777,8227],[-811,8206],[-792,8230],[-757,8230],[-757,8246],[-726,8256]]],[[[193,8378],[186,8400],[202,8387],[208,8341],[193,8378]]],[[[183,8412],[177,8392],[156,8412],[174,8431],[183,8412]]],[[[199,8431],[221,8424],[229,8389],[214,8393],[199,8431]]],[[[-826,8660],[-803,8657],[-834,8641],[-862,8661],[-896,8667],[-850,8675],[-826,8660]]],[[[553,8054],[551,8053],[551,8054],[553,8054]]],[[[1261,7281],[1260,7293],[1252,7296],[1228,7335],[1206,7373],[1202,7375],[1200,7378],[1167,7387],[1143,7358],[1102,7380],[1091,7409],[1043,7449],[993,7449],[993,7434],[908,7434],[797,7472],[799,7479],[728,7473],[722,7492],[686,7523],[648,7524],[624,7541],[571,7629],[568,7651],[532,7689],[528,7720],[512,7742],[522,7777],[507,7826],[520,7864],[527,7925],[507,8030],[563,8020],[563,8024],[573,8014],[562,8025],[562,8026],[566,8031],[562,8027],[561,8054],[1379,8054],[1455,8037],[1491,8018],[1546,8016],[1503,7997],[1471,7971],[1510,7975],[1520,7963],[1574,7988],[1575,7986],[1575,7988],[1591,7997],[1601,7995],[1583,7981],[1612,7961],[1683,7971],[1697,7959],[1708,7961],[1708,7954],[1689,7936],[1622,7938],[1592,7889],[1612,7898],[1595,7842],[1598,7806],[1614,7783],[1632,7792],[1645,7831],[1636,7855],[1644,7893],[1694,7935],[1726,7918],[1730,7880],[1715,7868],[1750,7865],[1758,7833],[1755,7820],[1751,7816],[1746,7820],[1739,7807],[1727,7787],[1756,7775],[1780,7780],[1855,7817],[1862,7830],[1858,7836],[1858,7842],[1927,7844],[1955,7886],[1970,7900],[1987,7905],[1987,7905],[2082,7905],[2118,7937],[2126,7968],[2149,7996],[2192,7982],[2192,7933],[2196,7927],[2203,7927],[2202,7914],[2210,7911],[2216,7898],[2179,7882],[2181,7881],[2174,7874],[2173,7879],[2173,7879],[2164,7875],[2168,7876],[2168,7870],[2163,7871],[2161,7874],[2155,7872],[2110,7843],[2108,7787],[2041,7770],[2006,7747],[2005,7718],[1959,7656],[1937,7700],[1941,7654],[1934,7620],[1948,7620],[1956,7577],[1933,7542],[1915,7545],[1890,7517],[1854,7495],[1795,7447],[1786,7414],[1814,7342],[1829,7289],[1819,7237],[1797,7235],[1766,7277],[1746,7323],[1752,7355],[1710,7394],[1682,7378],[1650,7401],[1567,7404],[1544,7395],[1558,7358],[1533,7373],[1514,7361],[1485,7382],[1464,7376],[1411,7380],[1340,7337],[1309,7290],[1321,7262],[1289,7265],[1261,7281]]],[[[247,8324],[243,8322],[239,8327],[247,8327],[248,8327],[252,8348],[288,8301],[287,8280],[261,8307],[246,8319],[247,8324]]],[[[-425,7092],[-433,7100],[-433,7100],[-426,7097],[-425,7092],[-425,7092],[-425,7092]]],[[[-425,7092],[-390,7060],[-422,7047],[-425,7092],[-425,7092],[-425,7092]]],[[[308,8292],[307,8287],[302,8290],[308,8292],[308,8292],[308,8292]]],[[[217,8430],[220,8427],[210,8429],[210,8433],[205,8435],[148,8429],[100,8466],[54,8486],[-34,8511],[-77,8513],[-132,8528],[-131,8544],[-185,8544],[-179,8506],[-229,8506],[-240,8492],[-304,8469],[-282,8489],[-303,8495],[-289,8538],[-261,8553],[-264,8566],[-317,8528],[-328,8503],[-369,8479],[-346,8459],[-377,8422],[-432,8396],[-465,8356],[-478,8363],[-510,8328],[-540,8328],[-589,8308],[-615,8286],[-687,8268],[-679,8288],[-643,8297],[-585,8332],[-551,8327],[-555,8346],[-513,8369],[-478,8400],[-458,8457],[-516,8437],[-555,8465],[-597,8443],[-595,8484],[-613,8511],[-651,8497],[-693,8522],[-709,8506],[-741,8500],[-765,8515],[-713,8520],[-680,8544],[-726,8574],[-715,8598],[-667,8655],[-644,8644],[-615,8663],[-568,8678],[-587,8710],[-579,8735],[-637,8709],[-728,8718],[-784,8772],[-702,8808],[-655,8816],[-653,8790],[-599,8787],[-594,8837],[-655,8842],[-667,8867],[-741,8904],[-729,8932],[-673,8934],[-637,8959],[-638,8973],[-601,9009],[-570,9009],[-534,9034],[-486,9036],[-450,9061],[-399,9052],[-370,9033],[-317,9037],[-306,9015],[-225,9020],[-162,9000],[-87,8990],[-49,8997],[19,8972],[20,8520],[74,8510],[120,8473],[126,8458],[158,8488],[183,8497],[199,8475],[245,8436],[292,8359],[346,8330],[346,8304],[346,8304],[319,8284],[320,8322],[316,8323],[310,8332],[305,8326],[295,8329],[287,8349],[254,8380],[220,8428],[217,8430]]],[[[-373,8372],[-390,8391],[-344,8421],[-318,8446],[-311,8403],[-356,8377],[-413,8325],[-373,8372]]],[[[-433,7100],[-479,7115],[-446,7112],[-433,7100],[-433,7100]]],[[[308,8292],[309,8295],[309,8292],[308,8292],[308,8292],[308,8292]]]]}},{\"type\":\"Feature\",\"id\":\"JP\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.52,\"hc-middle-y\":0.66,\"hc-key\":\"jp\",\"hc-a2\":\"JP\",\"name\":\"Japan\",\"labelrank\":\"2\",\"country-abbrev\":\"Japan\",\"subregion\":\"Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"JPN\",\"iso-a2\":\"JP\",\"woe-id\":\"23424856\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[8389,7914],[8390,7917],[8398,7911],[8394,7909],[8389,7914]]],[[[8149,7526],[8129,7515],[8097,7520],[8140,7570],[8197,7578],[8232,7572],[8278,7641],[8269,7618],[8307,7629],[8314,7654],[8342,7662],[8359,7703],[8352,7721],[8369,7771],[8380,7756],[8400,7767],[8419,7706],[8391,7670],[8390,7636],[8375,7598],[8384,7580],[8357,7553],[8353,7573],[8306,7546],[8256,7542],[8267,7531],[8239,7508],[8212,7518],[8222,7544],[8172,7539],[8149,7527],[8166,7521],[8186,7539],[8200,7532],[8186,7497],[8173,7507],[8138,7480],[8130,7504],[8149,7526]]],[[[8044,7495],[8037,7525],[8057,7499],[8076,7517],[8113,7508],[8122,7487],[8101,7435],[8068,7431],[8067,7482],[8044,7495]]],[[[8380,7790],[8365,7775],[8355,7820],[8373,7846],[8401,7845],[8416,7924],[8472,7874],[8509,7860],[8522,7839],[8483,7831],[8455,7794],[8413,7818],[8367,7806],[8380,7790]]]]}},{\"type\":\"Feature\",\"id\":\"SC\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.58,\"hc-middle-y\":0.41,\"hc-key\":\"sc\",\"hc-a2\":\"SC\",\"name\":\"Seychelles\",\"labelrank\":\"6\",\"country-abbrev\":\"Syc.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"SYC\",\"iso-a2\":\"SC\",\"woe-id\":\"23424941\",\"continent\":\"Seven seas (open ocean)\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5849,6344],[5852,6341],[5851,6337],[5843,6348],[5849,6344]]]}},{\"type\":\"Feature\",\"id\":\"IN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.34,\"hc-middle-y\":0.43,\"hc-key\":\"in\",\"hc-a2\":\"IN\",\"name\":\"India\",\"labelrank\":\"2\",\"country-abbrev\":\"India\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"IND\",\"iso-a2\":\"IN\",\"woe-id\":\"23424848\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[6818,7133],[6820,7134],[6820,7126],[6817,7128],[6818,7133]]],[[[6819,7322],[6840,7326],[6842,7305],[6869,7285],[6937,7293],[6923,7319],[6953,7324],[7012,7369],[7032,7360],[7057,7370],[7092,7333],[7074,7306],[7024,7278],[7023,7255],[6996,7195],[6973,7200],[6969,7150],[6951,7137],[6939,7192],[6922,7167],[6909,7188],[6949,7229],[6935,7237],[6886,7236],[6870,7262],[6829,7277],[6818,7260],[6843,7237],[6816,7220],[6837,7209],[6832,7189],[6847,7142],[6823,7124],[6820,7141],[6792,7124],[6767,7075],[6740,7073],[6699,7023],[6646,6986],[6647,6972],[6586,6945],[6580,6925],[6588,6875],[6574,6835],[6574,6783],[6504,6717],[6476,6742],[6454,6807],[6424,6859],[6410,6911],[6384,6956],[6360,7072],[6367,7093],[6351,7149],[6344,7113],[6310,7098],[6291,7105],[6258,7137],[6287,7155],[6241,7174],[6227,7195],[6247,7208],[6280,7205],[6313,7222],[6265,7289],[6295,7328],[6337,7325],[6368,7360],[6381,7388],[6416,7427],[6415,7446],[6438,7461],[6400,7495],[6393,7534],[6410,7548],[6453,7539],[6490,7559],[6513,7572],[6527,7544],[6546,7534],[6542,7507],[6563,7480],[6530,7473],[6541,7434],[6608,7397],[6589,7383],[6579,7353],[6660,7310],[6714,7305],[6751,7281],[6795,7274],[6820,7286],[6819,7322]]]]}},{\"type\":\"Feature\",\"id\":\"FR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.28,\"hc-middle-y\":0.04,\"hc-key\":\"fr\",\"hc-a2\":\"FR\",\"name\":\"France\",\"labelrank\":\"2\",\"country-abbrev\":\"Fr.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"FRA\",\"iso-a2\":\"FR\",\"woe-id\":\"-90\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[2537,7972],[2531,7971],[2530,7983],[2533,7975],[2537,7972]]],[[[4485,7820],[4477,7774],[4465,7781],[4462,7817],[4485,7820]]],[[[9164,5848],[9155,5806],[9109,5833],[9082,5858],[9076,5879],[9141,5830],[9164,5848]]],[[[6256,4904],[6297,4899],[6285,4876],[6245,4876],[6256,4904]]],[[[2331,7017],[2334,7019],[2334,7016],[2331,7017]]],[[[4427,7861],[4426,7860],[4425,7859],[4424,7860],[4423,7858],[4385,7835],[4321,7852],[4294,7830],[4298,7812],[4279,7808],[4263,7812],[4262,7812],[4262,7812],[4255,7814],[4255,7818],[4246,7818],[4203,7821],[4151,7846],[4160,7853],[4173,7943],[4145,7980],[4120,7997],[4065,8019],[4064,8038],[4112,8049],[4124,8036],[4163,8041],[4147,8082],[4197,8065],[4210,8081],[4250,8101],[4251,8127],[4279,8135],[4327,8092],[4376,8075],[4381,8071],[4392,8072],[4447,8053],[4429,8001],[4386,7963],[4389,7952],[4391,7955],[4393,7956],[4405,7957],[4405,7947],[4412,7939],[4400,7909],[4427,7861]]],[[[2596,6636],[2603,6648],[2632,6639],[2670,6598],[2632,6543],[2583,6547],[2601,6581],[2587,6623],[2596,6636]]]]}},{\"type\":\"Feature\",\"id\":\"FM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.52,\"hc-key\":\"fm\",\"hc-a2\":\"FM\",\"name\":\"Federated States of Micronesia\",\"labelrank\":\"6\",\"country-abbrev\":\"F.S.M.\",\"subregion\":\"Micronesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"FSM\",\"iso-a2\":\"FM\",\"woe-id\":\"23424815\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8899,6684],[8902,6683],[8902,6679],[8899,6679],[8899,6684]]]}},{\"type\":\"Feature\",\"id\":\"CN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.41,\"hc-middle-y\":0.56,\"hc-key\":\"cn\",\"hc-a2\":\"CN\",\"name\":\"China\",\"labelrank\":\"2\",\"country-abbrev\":\"China\",\"subregion\":\"Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"CHN\",\"iso-a2\":\"CN\",\"woe-id\":\"23424781\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[7429,7050],[7456,7076],[7488,7081],[7498,7067],[7481,7036],[7459,7021],[7429,7031],[7429,7050]]],[[[6842,7305],[6840,7326],[6819,7322],[6773,7330],[6756,7323],[6729,7336],[6699,7367],[6683,7364],[6640,7401],[6608,7397],[6541,7434],[6530,7473],[6563,7480],[6542,7507],[6546,7534],[6527,7544],[6513,7572],[6500,7571],[6482,7577],[6459,7605],[6416,7624],[6411,7627],[6426,7631],[6423,7675],[6395,7677],[6389,7707],[6399,7728],[6446,7748],[6450,7736],[6482,7759],[6521,7763],[6529,7774],[6584,7803],[6602,7838],[6581,7906],[6646,7924],[6668,7986],[6719,7972],[6741,7981],[6750,8032],[6795,8058],[6801,8059],[6810,8061],[6814,8039],[6847,8016],[6885,8003],[6906,7963],[6901,7912],[6979,7903],[7034,7879],[7064,7822],[7220,7815],[7232,7803],[7282,7788],[7326,7787],[7372,7807],[7453,7813],[7526,7857],[7511,7885],[7528,7908],[7575,7895],[7603,7919],[7637,7921],[7664,7953],[7714,7968],[7756,7963],[7762,7975],[7722,8015],[7698,8015],[7696,8015],[7691,8008],[7642,8005],[7632,8021],[7667,8086],[7699,8074],[7742,8093],[7740,8107],[7768,8158],[7788,8176],[7766,8201],[7790,8222],[7862,8234],[7935,8210],[8005,8075],[8043,8071],[8086,8027],[8093,8004],[8135,8005],[8192,8031],[8204,8005],[8185,7988],[8178,7951],[8146,7907],[8138,7916],[8121,7913],[8090,7899],[8099,7870],[8091,7827],[8078,7815],[8057,7831],[8053,7812],[8004,7796],[8007,7774],[7962,7785],[7943,7758],[7895,7730],[7838,7706],[7799,7682],[7804,7705],[7833,7744],[7800,7758],[7778,7733],[7751,7722],[7736,7698],[7699,7695],[7708,7662],[7731,7662],[7749,7627],[7787,7651],[7812,7637],[7845,7637],[7787,7604],[7742,7557],[7773,7532],[7791,7478],[7819,7454],[7824,7420],[7794,7408],[7836,7385],[7812,7368],[7814,7337],[7794,7326],[7749,7262],[7758,7244],[7731,7235],[7661,7167],[7610,7163],[7593,7144],[7576,7170],[7574,7142],[7489,7118],[7466,7084],[7461,7122],[7422,7134],[7409,7122],[7366,7149],[7372,7161],[7329,7180],[7289,7154],[7245,7162],[7234,7150],[7217,7146],[7222,7111],[7206,7124],[7177,7120],[7170,7139],[7146,7143],[7157,7171],[7138,7175],[7130,7203],[7101,7195],[7103,7234],[7133,7260],[7132,7313],[7098,7343],[7092,7333],[7057,7370],[7032,7360],[7012,7369],[6953,7324],[6923,7319],[6882,7338],[6842,7305]]]]}},{\"type\":\"Feature\",\"id\":\"PT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.46,\"hc-middle-y\":0.5,\"hc-key\":\"pt\",\"hc-a2\":\"PT\",\"name\":\"Portugal\",\"labelrank\":\"2\",\"country-abbrev\":\"Port.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"PRT\",\"iso-a2\":\"PT\",\"woe-id\":\"23424925\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3984,7629],[3937,7624],[3944,7663],[3922,7681],[3946,7754],[3944,7795],[4009,7795],[4020,7781],[3998,7762],[3997,7692],[3984,7629]]]}},{\"type\":\"Feature\",\"id\":\"SW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.86,\"hc-middle-y\":0.57,\"hc-key\":\"sw\",\"hc-a2\":\"SW\",\"name\":\"Serranilla Bank\",\"labelrank\":\"5\",\"country-abbrev\":\"S.B.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"-99\",\"iso-a2\":\"SW\",\"woe-id\":\"-99\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1870,6950],[1870,6950],[1870,6950],[1870,6950]]]}},{\"type\":\"Feature\",\"id\":\"SH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.54,\"hc-middle-y\":0.51,\"hc-key\":\"sh\",\"hc-a2\":\"SH\",\"name\":\"Scarborough Reef\",\"labelrank\":\"6\",\"country-abbrev\":\"S.R.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"-99\",\"iso-a2\":\"SH\",\"woe-id\":\"-99\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7699,6929],[7698,6929],[7698,6929],[7698,6929],[7699,6929]]]}},{\"type\":\"Feature\",\"id\":\"BR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.54,\"hc-middle-y\":0.34,\"hc-key\":\"br\",\"hc-a2\":\"BR\",\"name\":\"Brazil\",\"labelrank\":\"2\",\"country-abbrev\":\"Brazil\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"BRA\",\"iso-a2\":\"BR\",\"woe-id\":\"23424768\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[2729,6474],[2767,6471],[2755,6436],[2702,6426],[2696,6461],[2729,6474]]],[[[2615,5450],[2627,5475],[2626,5480],[2554,5539],[2542,5531],[2517,5563],[2494,5561],[2549,5623],[2606,5658],[2604,5706],[2584,5708],[2584,5709],[2583,5712],[2594,5736],[2594,5755],[2559,5759],[2553,5800],[2530,5817],[2483,5817],[2488,5852],[2478,5876],[2496,5937],[2471,5965],[2469,5993],[2419,5995],[2409,6069],[2369,6077],[2332,6104],[2293,6110],[2263,6149],[2262,6192],[2226,6186],[2177,6154],[2139,6155],[2108,6153],[2111,6200],[2091,6185],[2061,6183],[2007,6256],[2034,6290],[2040,6327],[2103,6356],[2128,6354],[2143,6437],[2125,6474],[2131,6529],[2181,6529],[2206,6540],[2219,6515],[2258,6498],[2301,6525],[2324,6550],[2303,6552],[2286,6596],[2377,6604],[2401,6632],[2424,6629],[2437,6595],[2423,6558],[2431,6534],[2459,6514],[2509,6538],[2528,6536],[2543,6553],[2583,6547],[2632,6543],[2670,6598],[2688,6593],[2700,6543],[2723,6528],[2725,6479],[2679,6465],[2701,6426],[2743,6421],[2788,6463],[2869,6439],[2879,6399],[2908,6412],[2969,6393],[3017,6395],[3062,6370],[3101,6334],[3149,6327],[3171,6267],[3156,6207],[3109,6160],[3075,6104],[3048,6086],[3051,6007],[3043,5952],[3028,5936],[3026,5900],[2985,5834],[2988,5821],[2956,5790],[2888,5790],[2811,5749],[2785,5728],[2761,5693],[2767,5650],[2757,5614],[2726,5585],[2711,5552],[2684,5560],[2677,5531],[2654,5510],[2642,5465],[2620,5444],[2615,5447],[2615,5450]]]]}},{\"type\":\"Feature\",\"id\":\"KI\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.28,\"hc-middle-y\":0.65,\"hc-key\":\"ki\",\"hc-a2\":\"KI\",\"name\":\"Kiribati\",\"labelrank\":\"6\",\"country-abbrev\":\"Kir.\",\"subregion\":\"Micronesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"KIR\",\"iso-a2\":\"KI\",\"woe-id\":\"23424867\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[-468,6538],[-465,6533],[-460,6529],[-467,6531],[-468,6538]]]}},{\"type\":\"Feature\",\"id\":\"PH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.4,\"hc-middle-y\":0.19,\"hc-key\":\"ph\",\"hc-a2\":\"PH\",\"name\":\"Philippines\",\"labelrank\":\"2\",\"country-abbrev\":\"Phil.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"PHL\",\"iso-a2\":\"PH\",\"woe-id\":\"23424934\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[7894,6825],[7915,6827],[7892,6850],[7919,6851],[7934,6808],[7915,6812],[7907,6784],[7894,6825]]],[[[7758,6817],[7762,6844],[7775,6837],[7758,6817],[7758,6817]]],[[[7753,6809],[7752,6810],[7758,6817],[7758,6817],[7758,6816],[7753,6809],[7753,6809]]],[[[7823,6787],[7825,6841],[7859,6818],[7853,6800],[7886,6812],[7884,6786],[7855,6746],[7836,6770],[7842,6795],[7823,6787]]],[[[7891,6697],[7867,6709],[7840,6706],[7823,6668],[7827,6707],[7866,6736],[7880,6720],[7907,6747],[7929,6745],[7929,6776],[7953,6740],[7962,6694],[7951,6678],[7937,6696],[7925,6676],[7925,6643],[7891,6661],[7891,6697]]],[[[7896,6884],[7885,6826],[7867,6840],[7859,6878],[7840,6893],[7842,6869],[7816,6893],[7801,6877],[7817,6862],[7802,6841],[7776,6880],[7796,6881],[7767,6918],[7760,6966],[7777,6959],[7775,7002],[7801,7048],[7798,7035],[7834,7023],[7840,6987],[7831,6962],[7812,6952],[7817,6900],[7839,6905],[7896,6884]]],[[[7753,6809],[7757,6790],[7686,6729],[7752,6809],[7753,6809]]]]}},{\"type\":\"Feature\",\"id\":\"MX\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.51,\"hc-middle-y\":0.49,\"hc-key\":\"mx\",\"hc-a2\":\"MX\",\"name\":\"Mexico\",\"labelrank\":\"2\",\"country-abbrev\":\"Mex.\",\"subregion\":\"Central America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"MEX\",\"iso-a2\":\"MX\",\"woe-id\":\"23424900\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[1630,7094],[1622,7084],[1622,7088],[1624,7093],[1630,7094]]],[[[1038,7129],[1042,7127],[1052,7116],[1044,7121],[1038,7129]]],[[[881,7216],[885,7216],[889,7212],[889,7210],[881,7216]]],[[[875,7231],[874,7226],[871,7225],[874,7232],[875,7231]]],[[[786,7330],[784,7328],[781,7330],[786,7338],[786,7330]]],[[[696,7356],[694,7355],[692,7363],[695,7361],[696,7356]]],[[[864,7349],[866,7364],[874,7359],[871,7350],[864,7349]]],[[[836,7376],[845,7368],[847,7358],[833,7372],[836,7376]]],[[[1200,7378],[1199,7374],[1206,7373],[1228,7335],[1252,7296],[1259,7288],[1261,7281],[1289,7265],[1321,7262],[1306,7216],[1300,7155],[1321,7096],[1361,7038],[1401,7020],[1478,7034],[1505,7051],[1523,7108],[1589,7126],[1630,7115],[1609,7083],[1597,7023],[1583,7030],[1567,7012],[1558,7009],[1504,7009],[1491,6992],[1522,6966],[1482,6956],[1466,6911],[1417,6957],[1389,6967],[1339,6944],[1273,6971],[1205,6993],[1183,7012],[1133,7025],[1088,7056],[1067,7089],[1083,7121],[1064,7158],[989,7239],[956,7256],[956,7286],[923,7307],[876,7358],[847,7417],[849,7428],[804,7448],[801,7397],[832,7368],[924,7228],[922,7208],[946,7205],[956,7176],[943,7165],[930,7186],[876,7228],[873,7264],[834,7285],[790,7321],[816,7325],[820,7341],[771,7383],[760,7417],[728,7473],[799,7479],[797,7472],[908,7434],[993,7434],[993,7449],[1043,7449],[1091,7409],[1102,7380],[1143,7358],[1167,7387],[1200,7378]],[[1309,7246],[1303,7231],[1306,7218],[1313,7245],[1309,7246]]]]}},{\"type\":\"Feature\",\"id\":\"ES\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.76,\"hc-middle-y\":0.27,\"hc-key\":\"es\",\"hc-a2\":\"ES\",\"name\":\"Spain\",\"labelrank\":\"2\",\"country-abbrev\":\"Sp.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"ESP\",\"iso-a2\":\"ES\",\"woe-id\":\"23424950\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[3748,7322],[3716,7331],[3697,7330],[3726,7345],[3748,7322]]],[[[4117,7566],[4118,7565],[4117,7564],[4116,7566],[4117,7566]]],[[[4044,7586],[4046,7586],[4045,7584],[4044,7585],[4044,7586]]],[[[4045,7594],[4021,7599],[4011,7621],[3984,7629],[3997,7692],[3998,7762],[4020,7781],[4009,7795],[3944,7795],[3930,7838],[3969,7860],[3988,7852],[4098,7851],[4151,7846],[4203,7821],[4246,7818],[4249,7812],[4255,7814],[4262,7812],[4262,7813],[4262,7814],[4263,7812],[4263,7812],[4279,7808],[4298,7812],[4300,7795],[4265,7771],[4233,7763],[4194,7709],[4211,7683],[4189,7669],[4183,7644],[4154,7635],[4143,7615],[4072,7613],[4046,7594],[4045,7594]]]]}},{\"type\":\"Feature\",\"id\":\"BU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.73,\"hc-key\":\"bu\",\"hc-a2\":\"BU\",\"name\":\"Bajo Nuevo Bank (Petrel Is.)\",\"labelrank\":\"8\",\"country-abbrev\":null,\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"-99\",\"iso-a2\":\"BU\",\"woe-id\":\"-99\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1830,6948],[1830,6948],[1830,6948],[1830,6948],[1830,6948]]]}},{\"type\":\"Feature\",\"id\":\"MV\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.57,\"hc-middle-y\":0.53,\"hc-key\":\"mv\",\"hc-a2\":\"MV\",\"name\":\"Maldives\",\"labelrank\":\"5\",\"country-abbrev\":\"Mald.\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"MDV\",\"iso-a2\":\"MV\",\"woe-id\":\"23424899\",\"continent\":\"Seven seas (open ocean)\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6382,6647],[6390,6636],[6380,6637],[6384,6642],[6382,6647]]]}},{\"type\":\"Feature\",\"id\":\"SP\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.5,\"hc-key\":\"sp\",\"hc-a2\":\"SP\",\"name\":\"Spratly Islands\",\"labelrank\":\"6\",\"country-abbrev\":\"Spratly Is.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"SPI\",\"iso-a2\":\"SP\",\"woe-id\":\"23424921\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7642,6799],[7641,6799],[7641,6799],[7642,6799],[7642,6799]]]}},{\"type\":\"Feature\",\"id\":\"GB\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.69,\"hc-middle-y\":0.09,\"hc-key\":\"gb\",\"hc-a2\":\"GB\",\"name\":\"United Kingdom\",\"labelrank\":\"2\",\"country-abbrev\":\"U.K.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"GBR\",\"iso-a2\":\"GB\",\"woe-id\":\"-90\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4108,8458],[4110,8454],[4106,8453],[4102,8457],[4108,8458]]],[[[4112,8469],[4111,8462],[4116,8461],[4104,8463],[4112,8469]]],[[[4118,8472],[4113,8477],[4125,8471],[4121,8468],[4118,8472]]],[[[4173,8521],[4166,8500],[4165,8515],[4155,8520],[4173,8521]]],[[[4176,8534],[4182,8533],[4169,8530],[4171,8539],[4176,8534]]],[[[4181,8542],[4179,8536],[4175,8537],[4176,8542],[4181,8542]]],[[[1789,7055],[1792,7057],[1798,7055],[1792,7054],[1789,7055]]],[[[2080,7131],[2072,7131],[2072,7133],[2077,7133],[2080,7131]]],[[[2065,7134],[2063,7131],[2058,7131],[2062,7132],[2065,7134]]],[[[3994,8404],[3993,8427],[4018,8441],[4015,8421],[3994,8404]]],[[[2433,4774],[2454,4816],[2486,4811],[2491,4798],[2433,4774]]],[[[5210,7554],[5209,7553],[5207,7555],[5206,7555],[5206,7555],[5206,7554],[5204,7554],[5204,7555],[5205,7555],[5203,7556],[5206,7556],[5210,7558],[5210,7557],[5207,7557],[5210,7554]],[[5205,7555],[5206,7556],[5205,7556],[5205,7555]]],[[[4046,7594],[4045,7593],[4045,7594],[4046,7594]]],[[[5184,7543],[5181,7544],[5176,7544],[5178,7545],[5184,7543]]],[[[3989,8295],[4018,8305],[4040,8278],[4018,8256],[3987,8256],[3961,8270],[3989,8295]]],[[[4024,8390],[4056,8446],[4114,8447],[4083,8416],[4100,8407],[4147,8405],[4152,8396],[4110,8337],[4156,8317],[4168,8277],[4202,8256],[4214,8215],[4204,8207],[4254,8201],[4251,8174],[4225,8151],[4244,8137],[4212,8122],[4102,8117],[4043,8100],[4081,8140],[4113,8140],[4074,8163],[4046,8166],[4079,8182],[4080,8220],[4109,8227],[4119,8259],[4096,8272],[4103,8288],[4073,8289],[4075,8268],[4052,8286],[4067,8313],[4036,8351],[4008,8361],[4032,8367],[4003,8396],[4024,8390]]]]}},{\"type\":\"Feature\",\"id\":\"GR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.3,\"hc-middle-y\":0.43,\"hc-key\":\"gr\",\"hc-a2\":\"GR\",\"name\":\"Greece\",\"labelrank\":\"3\",\"country-abbrev\":\"Greece\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"GRC\",\"iso-a2\":\"GR\",\"woe-id\":\"23424833\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4984,7560],[4938,7553],[4902,7565],[4922,7573],[4984,7560]]],[[[5023,7596],[5041,7604],[5037,7593],[5028,7585],[5023,7596]]],[[[5011,7610],[5003,7612],[5010,7619],[5009,7615],[5011,7610]]],[[[5002,7626],[5006,7623],[5003,7621],[5004,7624],[5002,7626]]],[[[4952,7622],[4962,7630],[4963,7623],[4957,7611],[4952,7622]]],[[[4985,7644],[4977,7640],[4975,7641],[4978,7645],[4985,7644]]],[[[5004,7649],[5007,7647],[4999,7645],[4993,7649],[5004,7649]]],[[[4978,7677],[4980,7667],[4975,7669],[4971,7677],[4978,7677]]],[[[4959,7727],[4953,7726],[4959,7743],[4966,7743],[4959,7727]]],[[[4828,7750],[4831,7753],[4828,7750],[4826,7753],[4826,7754],[4828,7756],[4831,7756],[4854,7765],[4884,7773],[4931,7781],[4953,7770],[4985,7786],[4994,7775],[4977,7752],[4947,7761],[4907,7750],[4928,7732],[4876,7743],[4874,7728],[4958,7637],[4915,7667],[4918,7646],[4893,7656],[4878,7642],[4892,7604],[4853,7613],[4838,7665],[4798,7715],[4809,7720],[4828,7750]]],[[[4989,7700],[4994,7693],[4988,7690],[4971,7698],[4986,7702],[4988,7702],[4989,7700]]]]}},{\"type\":\"Feature\",\"id\":\"AS\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.56,\"hc-middle-y\":0.57,\"hc-key\":\"as\",\"hc-a2\":\"AS\",\"name\":\"American Samoa\",\"labelrank\":\"4\",\"country-abbrev\":\"Am. Samoa\",\"subregion\":\"Polynesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"ASM\",\"iso-a2\":\"AS\",\"woe-id\":\"23424746\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[-859,6056],[-861,6055],[-863,6052],[-866,6054],[-859,6056]]]}},{\"type\":\"Feature\",\"id\":\"DK\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.35,\"hc-middle-y\":0.49,\"hc-key\":\"dk\",\"hc-a2\":\"DK\",\"name\":\"Denmark\",\"labelrank\":\"4\",\"country-abbrev\":\"Den.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"DNK\",\"iso-a2\":\"DK\",\"woe-id\":\"23424796\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4538,8291],[4553,8278],[4544,8277],[4531,8283],[4538,8291]]],[[[4511,8288],[4516,8286],[4512,8286],[4506,8292],[4511,8288]]],[[[4576,8293],[4566,8288],[4565,8292],[4570,8294],[4576,8293]]],[[[4495,8296],[4502,8291],[4500,8287],[4494,8289],[4495,8296]]],[[[4526,8290],[4523,8282],[4520,8286],[4529,8299],[4526,8290]]],[[[4578,8322],[4559,8280],[4533,8320],[4567,8339],[4578,8322]]],[[[4484,8285],[4466,8289],[4461,8288],[4445,8357],[4495,8381],[4519,8408],[4509,8372],[4529,8353],[4516,8338],[4525,8302],[4488,8310],[4484,8285]]]]}},{\"type\":\"Feature\",\"id\":\"GL\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.55,\"hc-middle-y\":0.43,\"hc-key\":\"gl\",\"hc-a2\":\"GL\",\"name\":\"Greenland\",\"labelrank\":\"3\",\"country-abbrev\":\"Grlnd.\",\"subregion\":\"Northern America\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"GRL\",\"iso-a2\":\"GL\",\"woe-id\":\"23424828\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[2633,8910],[2635,8908],[2628,8905],[2624,8909],[2633,8910]]],[[[2656,8923],[2628,8916],[2630,8920],[2642,8923],[2656,8923]]],[[[2582,9011],[2574,9011],[2571,9017],[2578,9015],[2582,9011]]],[[[2616,9047],[2602,9051],[2613,9062],[2620,9051],[2616,9047]]],[[[2570,9117],[2557,9108],[2553,9113],[2571,9121],[2570,9117]]],[[[2552,9143],[2545,9137],[2535,9139],[2543,9143],[2552,9143]]],[[[2572,9145],[2556,9131],[2554,9142],[2564,9145],[2572,9145]]],[[[2544,9188],[2558,9180],[2554,9179],[2539,9188],[2544,9188]]],[[[2534,9206],[2543,9205],[2524,9203],[2524,9209],[2534,9206]]],[[[2528,9242],[2510,9242],[2496,9242],[2521,9246],[2528,9242]]],[[[2139,9366],[2126,9367],[2127,9369],[2140,9370],[2139,9366]]],[[[2061,9422],[2086,9417],[2076,9414],[2052,9419],[2061,9422]]],[[[2100,9424],[2119,9418],[2095,9418],[2088,9423],[2100,9424]]],[[[3690,9588],[3655,9569],[3628,9580],[3678,9596],[3690,9588]]],[[[2218,9636],[2228,9632],[2222,9631],[2218,9632],[2218,9636]]],[[[2683,9729],[2658,9730],[2626,9738],[2637,9753],[2683,9729]]],[[[2610,8952],[2619,8961],[2572,8975],[2577,9002],[2623,9002],[2661,8980],[2657,8963],[2610,8952]]],[[[2631,8765],[2626,8765],[2626,8768],[2627,8768],[2624,8771],[2612,8811],[2652,8832],[2603,8840],[2627,8897],[2686,8916],[2696,8975],[2677,8989],[2606,9011],[2584,9029],[2647,9028],[2701,9008],[2677,9040],[2647,9058],[2641,9054],[2628,9056],[2632,9066],[2636,9065],[2631,9068],[2667,9078],[2637,9080],[2624,9074],[2617,9080],[2629,9081],[2633,9081],[2599,9084],[2603,9068],[2563,9065],[2545,9082],[2553,9091],[2548,9094],[2555,9096],[2557,9095],[2575,9114],[2584,9146],[2568,9153],[2570,9153],[2556,9159],[2555,9158],[2552,9159],[2564,9178],[2541,9192],[2552,9207],[2530,9217],[2538,9235],[2510,9267],[2478,9276],[2463,9295],[2469,9316],[2398,9342],[2320,9355],[2304,9341],[2239,9349],[2231,9329],[2173,9337],[2137,9356],[2186,9374],[2115,9382],[2087,9394],[2100,9406],[2175,9418],[2222,9417],[2237,9433],[2150,9423],[2141,9438],[2088,9443],[2041,9468],[2050,9491],[2146,9510],[2185,9528],[2246,9530],[2279,9557],[2274,9591],[2214,9594],[2202,9613],[2271,9643],[2281,9658],[2335,9675],[2378,9663],[2400,9695],[2380,9712],[2465,9738],[2588,9757],[2615,9738],[2608,9698],[2633,9733],[2679,9723],[2736,9726],[2703,9741],[2687,9767],[2750,9763],[2839,9733],[2864,9715],[2891,9719],[2870,9733],[2876,9737],[2813,9756],[2770,9788],[2788,9777],[2829,9779],[2885,9759],[2877,9738],[2906,9760],[2846,9787],[2988,9787],[2850,9794],[2814,9801],[2838,9810],[2865,9802],[2879,9816],[2954,9821],[3022,9818],[3052,9816],[3056,9835],[3114,9844],[3240,9851],[3294,9849],[3443,9826],[3430,9819],[3292,9814],[3167,9796],[3259,9803],[3311,9813],[3391,9808],[3456,9816],[3478,9796],[3532,9789],[3571,9776],[3538,9755],[3318,9740],[3231,9719],[3264,9718],[3380,9734],[3473,9729],[3471,9714],[3423,9702],[3421,9689],[3499,9712],[3516,9732],[3569,9736],[3573,9695],[3518,9653],[3552,9660],[3651,9717],[3698,9699],[3735,9718],[3791,9716],[3847,9704],[3866,9691],[3808,9660],[3772,9658],[3780,9644],[3746,9634],[3698,9635],[3735,9618],[3716,9605],[3647,9598],[3600,9582],[3634,9570],[3623,9548],[3641,9533],[3613,9524],[3628,9503],[3597,9514],[3572,9475],[3569,9450],[3634,9453],[3630,9441],[3674,9435],[3630,9427],[3586,9435],[3597,9418],[3660,9407],[3648,9365],[3653,9329],[3637,9361],[3647,9379],[3595,9391],[3559,9373],[3560,9348],[3612,9348],[3630,9296],[3689,9274],[3657,9271],[3629,9229],[3573,9218],[3594,9181],[3565,9184],[3542,9170],[3492,9190],[3428,9169],[3444,9165],[3441,9166],[3478,9180],[3514,9160],[3554,9151],[3554,9138],[3524,9143],[3553,9127],[3532,9126],[3545,9106],[3481,9133],[3477,9146],[3501,9146],[3476,9150],[3457,9159],[3441,9150],[3476,9123],[3536,9094],[3520,9084],[3557,9059],[3567,9020],[3511,9014],[3484,9049],[3437,9076],[3445,9055],[3375,9038],[3366,9011],[3394,9014],[3371,9014],[3383,9030],[3452,9049],[3453,9026],[3427,9015],[3407,9015],[3376,8996],[3394,8990],[3453,9013],[3505,8997],[3540,8997],[3514,8972],[3489,8966],[3424,8922],[3372,8915],[3332,8897],[3254,8889],[3215,8864],[3216,8851],[3176,8805],[3124,8778],[3080,8766],[3076,8798],[3061,8771],[3013,8760],[3032,8753],[3009,8738],[2992,8708],[3002,8677],[2953,8623],[2939,8546],[2915,8528],[2921,8504],[2888,8501],[2857,8515],[2855,8534],[2781,8544],[2749,8569],[2741,8603],[2711,8619],[2716,8640],[2679,8665],[2683,8709],[2658,8696],[2660,8737],[2631,8765]]]]}},{\"type\":\"Feature\",\"id\":\"GU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.44,\"hc-key\":\"gu\",\"hc-a2\":\"GU\",\"name\":\"Guam\",\"labelrank\":\"6\",\"country-abbrev\":\"Guam\",\"subregion\":\"Micronesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"GUM\",\"iso-a2\":\"GU\",\"woe-id\":\"23424832\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8501,6877],[8498,6871],[8496,6877],[8503,6884],[8501,6877]]]}},{\"type\":\"Feature\",\"id\":\"MP\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.49,\"hc-key\":\"mp\",\"hc-a2\":\"MP\",\"name\":\"Northern Mariana Islands\",\"labelrank\":\"6\",\"country-abbrev\":\"N.M.I.\",\"subregion\":\"Micronesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"MNP\",\"iso-a2\":\"MP\",\"woe-id\":\"23424788\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8526,6925],[8528,6930],[8531,6932],[8529,6927],[8526,6925]]]}},{\"type\":\"Feature\",\"id\":\"PR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.65,\"hc-key\":\"pr\",\"hc-a2\":\"PR\",\"name\":\"Puerto Rico\",\"labelrank\":\"5\",\"country-abbrev\":\"P.R.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"PRI\",\"iso-a2\":\"PR\",\"woe-id\":\"23424935\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2267,7024],[2239,7013],[2212,7014],[2213,7031],[2267,7024]]]}},{\"type\":\"Feature\",\"id\":\"VI\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.19,\"hc-key\":\"vi\",\"hc-a2\":\"VI\",\"name\":\"United States Virgin Islands\",\"labelrank\":\"6\",\"country-abbrev\":\"V.I. (U.S.)\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"VIR\",\"iso-a2\":\"VI\",\"woe-id\":\"23424985\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2283,7008],[2288,7008],[2278,7005],[2279,7008],[2283,7008]]]}},{\"type\":\"Feature\",\"id\":\"CA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.29,\"hc-middle-y\":0.64,\"hc-key\":\"ca\",\"hc-a2\":\"CA\",\"name\":\"Canada\",\"labelrank\":\"2\",\"country-abbrev\":\"Can.\",\"subregion\":\"Northern America\",\"region-wb\":\"North America\",\"iso-a3\":\"CAN\",\"iso-a2\":\"CA\",\"woe-id\":\"23424775\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[1713,9425],[1665,9428],[1680,9462],[1643,9470],[1608,9466],[1608,9487],[1634,9510],[1674,9517],[1735,9510],[1777,9514],[1703,9520],[1681,9564],[1638,9573],[1639,9612],[1717,9607],[1765,9581],[1781,9562],[1787,9587],[1735,9612],[1889,9631],[1831,9632],[1931,9652],[1841,9647],[1743,9627],[1715,9642],[1699,9625],[1630,9631],[1649,9658],[1614,9633],[1551,9650],[1631,9659],[1637,9668],[1538,9660],[1523,9671],[1581,9700],[1519,9685],[1545,9704],[1475,9704],[1503,9719],[1590,9738],[1689,9729],[1630,9740],[1671,9751],[1659,9764],[1742,9752],[1829,9728],[1749,9758],[1768,9779],[1812,9771],[1783,9788],[1833,9786],[1825,9799],[1915,9793],[1945,9807],[2002,9803],[2013,9793],[2038,9809],[2136,9812],[2138,9803],[2235,9795],[2168,9776],[2203,9778],[2284,9797],[2337,9767],[2377,9766],[2384,9744],[2294,9710],[2264,9713],[2226,9694],[2125,9670],[2289,9698],[2178,9642],[2107,9600],[2083,9572],[2026,9575],[2032,9559],[1951,9546],[1907,9553],[1909,9541],[1994,9538],[1993,9525],[1945,9531],[1892,9527],[1955,9522],[1989,9509],[1984,9496],[1934,9493],[1975,9482],[1961,9465],[1901,9446],[1881,9418],[1807,9415],[1859,9401],[1848,9390],[1892,9392],[1896,9373],[1852,9352],[1863,9324],[1837,9325],[1849,9351],[1798,9340],[1807,9358],[1714,9361],[1699,9351],[1610,9360],[1531,9362],[1516,9376],[1584,9403],[1602,9416],[1587,9445],[1616,9451],[1653,9439],[1658,9421],[1713,9425]],[[1713,9425],[1714,9425],[1714,9425],[1714,9425],[1714,9425],[1714,9425],[1729,9427],[1747,9459],[1714,9425],[1714,9425],[1714,9425],[1714,9425],[1713,9425]]],[[[1858,7836],[1858,7833],[1862,7830],[1790,7820],[1752,7798],[1739,7807],[1758,7809],[1751,7816],[1755,7820],[1758,7833],[1778,7845],[1791,7914],[1827,7886],[1838,7897],[1808,7939],[1708,7954],[1708,7961],[1697,7959],[1686,8013],[1656,8016],[1639,8046],[1591,8054],[1546,8016],[1491,8018],[1455,8037],[1379,8054],[561,8054],[555,8058],[553,8054],[551,8054],[545,8069],[502,8091],[506,8102],[499,8104],[501,8103],[504,8100],[499,8097],[497,8104],[488,8106],[489,8108],[486,8110],[485,8107],[476,8108],[474,8109],[464,8111],[472,8108],[471,8108],[468,8109],[472,8107],[474,8108],[480,8106],[485,8099],[485,8098],[490,8093],[490,8093],[508,8069],[539,8044],[537,8052],[544,8047],[553,8046],[540,8044],[545,8040],[537,8028],[504,8038],[448,8070],[445,8079],[446,8079],[443,8087],[443,8087],[442,8091],[411,8096],[393,8123],[409,8127],[448,8116],[450,8117],[447,8118],[456,8118],[459,8122],[456,8125],[447,8118],[412,8138],[406,8174],[401,8161],[398,8166],[401,8173],[406,8174],[406,8175],[407,8175],[409,8178],[406,8178],[405,8179],[408,8179],[407,8183],[405,8181],[402,8201],[387,8216],[379,8197],[370,8211],[371,8215],[366,8216],[366,8220],[371,8223],[371,8217],[373,8223],[384,8218],[380,8222],[387,8253],[374,8237],[381,8240],[379,8235],[373,8232],[372,8234],[366,8227],[332,8264],[346,8293],[346,8304],[346,8330],[292,8359],[245,8436],[199,8475],[183,8497],[158,8488],[126,8458],[120,8473],[74,8510],[20,8520],[19,8972],[75,8965],[132,8936],[172,8933],[173,8954],[234,8964],[250,8959],[335,9000],[361,8992],[287,8966],[261,8941],[310,8969],[318,8952],[336,8974],[431,9004],[446,8976],[481,8955],[509,8996],[512,8957],[549,8964],[555,8982],[600,8978],[635,8959],[701,8939],[762,8928],[763,8938],[815,8916],[820,8899],[792,8901],[776,8883],[825,8871],[894,8872],[929,8885],[965,8875],[975,8854],[999,8850],[1012,8813],[1023,8842],[999,8872],[1069,8919],[1010,8895],[975,8901],[991,8919],[1064,8932],[1078,8905],[1103,8888],[1137,8887],[1191,8870],[1215,8879],[1285,8876],[1309,8866],[1275,8905],[1318,8911],[1331,8888],[1358,8902],[1341,8860],[1375,8831],[1371,8890],[1389,8888],[1427,8930],[1396,8925],[1405,8962],[1349,8984],[1339,9009],[1342,9061],[1378,9097],[1396,9099],[1380,9098],[1381,9125],[1363,9145],[1363,9192],[1377,9214],[1424,9223],[1466,9213],[1527,9207],[1478,9147],[1462,9139],[1410,9143],[1430,9125],[1411,9101],[1398,9100],[1438,9070],[1443,9037],[1487,8999],[1448,8975],[1480,8964],[1520,8932],[1525,8899],[1543,8940],[1565,8950],[1594,8924],[1580,8901],[1607,8842],[1655,8889],[1662,8924],[1690,8940],[1667,8953],[1666,8979],[1701,8983],[1715,8980],[1715,8982],[1725,8979],[1723,8978],[1752,8972],[1790,8948],[1776,8934],[1792,8919],[1751,8910],[1793,8859],[1785,8836],[1730,8804],[1700,8835],[1720,8796],[1674,8800],[1668,8815],[1628,8808],[1656,8794],[1611,8754],[1595,8754],[1542,8784],[1562,8753],[1621,8749],[1593,8699],[1561,8687],[1534,8698],[1528,8674],[1504,8670],[1505,8669],[1514,8666],[1512,8664],[1511,8666],[1505,8669],[1514,8645],[1453,8618],[1404,8545],[1390,8504],[1401,8450],[1439,8451],[1460,8395],[1454,8374],[1503,8387],[1566,8370],[1605,8336],[1693,8303],[1761,8295],[1767,8244],[1762,8210],[1837,8137],[1874,8185],[1860,8212],[1855,8257],[1837,8278],[1896,8304],[1928,8336],[1934,8367],[1917,8417],[1872,8446],[1910,8497],[1884,8545],[1903,8573],[1885,8610],[1905,8624],[1985,8603],[2018,8619],[2077,8581],[2073,8567],[2145,8542],[2132,8530],[2143,8458],[2163,8459],[2196,8424],[2251,8456],[2259,8494],[2279,8522],[2293,8517],[2299,8495],[2302,8500],[2305,8496],[2301,8493],[2299,8495],[2303,8480],[2323,8475],[2336,8445],[2383,8381],[2366,8360],[2429,8297],[2504,8272],[2482,8261],[2509,8241],[2548,8229],[2554,8180],[2513,8148],[2465,8139],[2429,8106],[2372,8097],[2354,8104],[2232,8103],[2205,8067],[2155,8046],[2129,8008],[2086,7969],[2038,7949],[1987,7905],[1970,7900],[1955,7886],[1860,7863],[1837,7844],[1858,7842],[1858,7838],[1858,7836]],[[456,8113],[455,8114],[454,8114],[456,8113]],[[544,8070],[543,8075],[540,8074],[540,8071],[544,8070]],[[424,8181],[428,8188],[413,8181],[409,8169],[424,8181]],[[1315,8873],[1309,8871],[1310,8867],[1315,8870],[1315,8873]],[[466,8061],[471,8060],[471,8063],[469,8063],[466,8061]],[[463,8065],[462,8069],[458,8069],[458,8065],[463,8065]]],[[[2286,8678],[2286,8639],[2268,8632],[2229,8643],[2201,8663],[2198,8647],[2247,8606],[2237,8590],[2170,8608],[2139,8627],[2076,8651],[2080,8670],[2048,8683],[2024,8719],[1988,8708],[1954,8719],[1928,8699],[1894,8707],[1885,8735],[1906,8760],[1956,8748],[2002,8763],[2024,8760],[1994,8794],[2039,8823],[2062,8850],[2038,8899],[2013,8904],[1964,8939],[1930,8922],[1930,8939],[1961,8950],[1899,8982],[1899,9001],[1861,9008],[1866,8984],[1778,8998],[1766,8979],[1644,8997],[1572,9016],[1546,9050],[1612,9042],[1590,9056],[1539,9063],[1530,9095],[1546,9144],[1564,9172],[1599,9197],[1631,9204],[1678,9202],[1631,9145],[1640,9100],[1686,9060],[1667,9114],[1696,9106],[1661,9135],[1676,9169],[1746,9198],[1785,9197],[1822,9141],[1805,9098],[1835,9128],[1862,9100],[1876,9132],[1901,9142],[1972,9127],[1970,9106],[2001,9104],[2000,9085],[2036,9059],[2053,9080],[2094,9059],[2066,9049],[2064,9043],[2072,9048],[2082,9041],[2103,9051],[2091,9022],[2129,9038],[2175,9022],[2212,8976],[2191,8974],[2194,8971],[2188,8967],[2194,8966],[2201,8970],[2207,8967],[2198,8965],[2209,8962],[2222,8945],[2194,8940],[2183,8927],[2180,8928],[2174,8928],[2182,8926],[2175,8917],[2219,8908],[2228,8897],[2231,8899],[2238,8899],[2237,8895],[2228,8896],[2237,8885],[2276,8889],[2307,8851],[2310,8851],[2317,8853],[2324,8851],[2323,8851],[2334,8850],[2324,8830],[2364,8838],[2380,8805],[2348,8798],[2346,8770],[2315,8760],[2319,8733],[2288,8742],[2220,8813],[2190,8809],[2212,8787],[2187,8765],[2258,8726],[2254,8713],[2286,8689],[2286,8685],[2286,8685],[2287,8680],[2292,8674],[2286,8678]],[[2063,9038],[2061,9032],[2070,9036],[2065,9034],[2063,9038]],[[2187,8974],[2164,8972],[2177,8969],[2187,8974]]],[[[2096,7974],[2093,7974],[2100,7980],[2101,7977],[2096,7974]]],[[[533,8059],[538,8053],[544,8051],[538,8052],[533,8059]]],[[[2301,8091],[2368,8068],[2357,8057],[2317,8069],[2301,8091]]],[[[495,8094],[493,8097],[495,8100],[498,8096],[495,8094]]],[[[409,8150],[403,8151],[401,8156],[405,8160],[409,8150]]],[[[1857,8175],[1850,8170],[1841,8168],[1841,8172],[1857,8175]]],[[[316,8175],[314,8174],[313,8171],[313,8177],[316,8175]]],[[[399,8172],[397,8175],[398,8179],[401,8179],[399,8172]]],[[[397,8181],[396,8177],[390,8177],[392,8181],[397,8181]]],[[[385,8190],[387,8184],[385,8182],[383,8189],[385,8190]]],[[[390,8195],[391,8191],[390,8189],[384,8195],[390,8195]]],[[[297,8200],[302,8200],[303,8197],[299,8195],[297,8200]]],[[[394,8186],[392,8196],[394,8203],[397,8191],[394,8186]]],[[[366,8203],[377,8196],[378,8191],[372,8194],[366,8203]]],[[[398,8196],[397,8198],[396,8202],[400,8203],[398,8196]]],[[[359,8213],[360,8209],[357,8209],[354,8216],[359,8213]]],[[[363,8217],[367,8211],[364,8211],[361,8219],[363,8217]]],[[[1788,8220],[1797,8219],[1809,8199],[1769,8212],[1788,8220]]],[[[1834,8218],[1836,8216],[1832,8215],[1833,8218],[1834,8218]]],[[[378,8225],[372,8224],[371,8226],[376,8233],[378,8225]]],[[[329,8230],[331,8237],[350,8227],[348,8218],[329,8230]]],[[[343,8235],[336,8236],[334,8239],[340,8242],[343,8235]]],[[[353,8238],[366,8226],[359,8220],[337,8245],[353,8238]]],[[[327,8256],[336,8254],[339,8250],[328,8243],[327,8256]]],[[[314,8276],[324,8276],[326,8266],[318,8270],[314,8276]]],[[[1852,8288],[1842,8285],[1840,8286],[1859,8290],[1852,8288]]],[[[333,8283],[332,8285],[341,8294],[338,8286],[333,8283]]],[[[1861,8337],[1867,8352],[1869,8353],[1869,8342],[1861,8337]]],[[[1843,8360],[1842,8352],[1831,8342],[1841,8352],[1843,8360]]],[[[1834,8370],[1832,8369],[1834,8374],[1838,8369],[1834,8370]]],[[[2200,8432],[2196,8433],[2197,8436],[2199,8437],[2200,8432]]],[[[2155,8463],[2146,8461],[2146,8468],[2153,8468],[2155,8463]]],[[[1818,8492],[1823,8494],[1825,8492],[1822,8490],[1818,8492]]],[[[1830,8501],[1833,8500],[1829,8496],[1825,8495],[1830,8501]]],[[[2284,8532],[2292,8519],[2283,8523],[2280,8528],[2284,8532]]],[[[2184,8533],[2191,8527],[2187,8519],[2174,8520],[2184,8533]]],[[[1883,8544],[1879,8541],[1869,8538],[1871,8541],[1883,8544]]],[[[2281,8579],[2279,8566],[2261,8578],[2274,8583],[2281,8579]]],[[[2252,8589],[2255,8585],[2247,8587],[2252,8591],[2252,8589]]],[[[1449,8594],[1442,8589],[1438,8593],[1443,8593],[1449,8594]]],[[[2273,8593],[2280,8586],[2271,8587],[2267,8591],[2273,8593]]],[[[1847,8614],[1850,8596],[1837,8578],[1824,8603],[1847,8614]]],[[[1463,8614],[1464,8616],[1470,8615],[1467,8613],[1463,8614]]],[[[2284,8621],[2293,8621],[2287,8613],[2277,8616],[2284,8621]]],[[[1894,8622],[1887,8624],[1901,8624],[1897,8621],[1894,8622]]],[[[2278,8622],[2272,8621],[2274,8624],[2278,8624],[2278,8622]]],[[[1995,8630],[2007,8628],[2009,8625],[1997,8626],[1995,8630]]],[[[2103,8635],[2121,8624],[2105,8622],[2090,8637],[2103,8635]]],[[[1767,8641],[1772,8629],[1737,8605],[1714,8619],[1732,8640],[1767,8641]]],[[[2222,8640],[2222,8639],[2213,8647],[2218,8646],[2222,8640]]],[[[1877,8666],[1899,8663],[1902,8651],[1891,8647],[1877,8666]]],[[[2300,8671],[2296,8665],[2297,8658],[2290,8672],[2300,8671]]],[[[1914,8674],[1932,8665],[1919,8662],[1906,8671],[1914,8674]]],[[[2297,8678],[2295,8679],[2295,8682],[2300,8681],[2297,8678]]],[[[1903,8691],[1897,8687],[1890,8688],[1891,8690],[1903,8691]]],[[[2277,8700],[2275,8699],[2274,8705],[2278,8702],[2277,8700]]],[[[2022,8713],[2021,8705],[2018,8705],[2017,8715],[2022,8713]]],[[[2266,8724],[2269,8720],[2255,8714],[2261,8722],[2266,8724]]],[[[2351,8774],[2357,8774],[2360,8769],[2350,8770],[2351,8774]]],[[[1732,8779],[1726,8777],[1725,8780],[1730,8780],[1732,8779]]],[[[1679,8789],[1689,8780],[1691,8765],[1678,8775],[1679,8789]]],[[[1701,8792],[1719,8784],[1729,8768],[1707,8775],[1701,8792]]],[[[1737,8802],[1744,8800],[1741,8796],[1732,8800],[1737,8802]]],[[[2352,8845],[2353,8844],[2340,8837],[2345,8845],[2352,8845]]],[[[1017,8840],[1013,8840],[1010,8844],[1011,8846],[1017,8840]]],[[[1002,8856],[1000,8852],[995,8857],[1002,8860],[1002,8856]]],[[[987,8864],[990,8864],[988,8859],[984,8863],[987,8864]]],[[[2311,8862],[2304,8863],[2306,8869],[2311,8864],[2311,8862]]],[[[1001,8864],[995,8864],[996,8870],[999,8869],[1001,8864]]],[[[843,8882],[837,8883],[852,8884],[852,8882],[843,8882]]],[[[997,8881],[992,8881],[993,8884],[996,8885],[997,8881]]],[[[964,8886],[973,8884],[971,8880],[965,8883],[964,8886]]],[[[959,8889],[960,8886],[955,8889],[955,8892],[959,8889]]],[[[944,8895],[952,8898],[942,8891],[932,8889],[944,8895]]],[[[2000,8891],[2025,8885],[2025,8875],[1996,8875],[2000,8891]]],[[[1641,8883],[1634,8873],[1624,8883],[1631,8902],[1641,8883]]],[[[890,8898],[887,8898],[889,8902],[894,8903],[890,8898]]],[[[1961,8903],[1974,8899],[1976,8864],[1952,8849],[1919,8848],[1909,8872],[1928,8900],[1961,8903]]],[[[1859,8896],[1854,8898],[1855,8904],[1865,8901],[1859,8896]]],[[[1767,8905],[1771,8904],[1768,8902],[1763,8905],[1767,8905]]],[[[2003,8899],[1996,8909],[2001,8909],[2005,8904],[2003,8899]]],[[[917,8916],[917,8914],[919,8912],[907,8911],[917,8916]]],[[[1102,8907],[1086,8915],[1097,8916],[1104,8913],[1102,8907]]],[[[1872,8919],[1870,8911],[1860,8911],[1869,8917],[1872,8919]]],[[[1993,8916],[1985,8915],[1981,8919],[1984,8921],[1993,8916]]],[[[1981,8915],[1984,8904],[1966,8913],[1971,8924],[1981,8915]]],[[[1184,8927],[1182,8916],[1167,8922],[1176,8929],[1184,8927]]],[[[1232,8934],[1224,8924],[1218,8926],[1218,8938],[1232,8934]]],[[[1236,8935],[1230,8938],[1232,8946],[1235,8943],[1236,8935]]],[[[166,8945],[168,8943],[161,8944],[162,8948],[166,8945]]],[[[1187,8943],[1188,8950],[1191,8949],[1190,8944],[1187,8943]]],[[[1516,8957],[1520,8950],[1516,8949],[1513,8957],[1516,8957]]],[[[1876,8959],[1876,8950],[1864,8933],[1847,8934],[1876,8959]]],[[[181,8968],[186,8972],[180,8962],[173,8964],[181,8968]]],[[[1779,8961],[1785,8959],[1786,8956],[1774,8960],[1779,8961]]],[[[1528,8959],[1523,8951],[1518,8955],[1523,8961],[1528,8959]]],[[[1918,8960],[1929,8958],[1914,8944],[1907,8952],[1918,8960]]],[[[1199,8967],[1208,8963],[1201,8958],[1198,8962],[1199,8967]]],[[[1336,8968],[1351,8968],[1351,8957],[1339,8963],[1336,8968]]],[[[1365,8970],[1373,8966],[1364,8955],[1363,8967],[1365,8970]]],[[[83,8969],[76,8966],[71,8969],[76,8972],[83,8969]]],[[[1890,8974],[1874,8964],[1864,8965],[1881,8977],[1890,8974]]],[[[1840,8981],[1844,8971],[1807,8973],[1823,8980],[1840,8981]]],[[[1756,8978],[1754,8977],[1746,8979],[1751,8982],[1756,8978]]],[[[1479,8982],[1481,8985],[1489,8981],[1487,8976],[1479,8982]]],[[[1315,8986],[1312,8986],[1311,8988],[1315,8988],[1315,8986]]],[[[1622,8997],[1634,8997],[1629,8989],[1611,8996],[1622,8997]]],[[[890,9007],[877,9007],[872,9011],[884,9008],[890,9007]]],[[[748,9020],[758,9020],[744,9016],[738,9020],[748,9020]]],[[[735,9020],[725,9020],[723,9021],[725,9023],[735,9020]]],[[[403,9024],[398,9023],[395,9020],[398,9026],[403,9024]]],[[[1216,9028],[1222,9027],[1230,9016],[1217,9020],[1216,9028]]],[[[2033,9068],[2043,9069],[2038,9062],[2030,9064],[2033,9068]]],[[[2046,9075],[2038,9075],[2040,9080],[2045,9081],[2046,9075]]],[[[1100,9174],[1080,9147],[1043,9179],[1041,9196],[1083,9199],[1100,9174]]],[[[1106,9352],[1117,9374],[1155,9352],[1166,9333],[1127,9326],[1106,9352]]],[[[1524,9434],[1544,9415],[1530,9407],[1498,9420],[1524,9434]]],[[[1088,9420],[1104,9404],[1081,9404],[1056,9441],[1088,9420]]],[[[1664,8007],[1660,8006],[1654,8006],[1656,8009],[1664,8007]]],[[[1600,8048],[1604,8045],[1593,8045],[1594,8049],[1600,8048]]],[[[1763,7943],[1772,7941],[1776,7924],[1734,7937],[1763,7943]]],[[[1732,7940],[1731,7937],[1726,7938],[1728,7941],[1732,7940]]],[[[1710,7953],[1718,7950],[1713,7944],[1709,7949],[1710,7953]]],[[[1938,7875],[1934,7873],[1936,7876],[1943,7877],[1938,7875]]],[[[1366,9443],[1437,9441],[1429,9423],[1355,9424],[1366,9443]]],[[[2430,7942],[2394,7922],[2378,7943],[2406,7980],[2411,7952],[2430,7942]]],[[[2364,7988],[2365,7958],[2348,7940],[2327,7957],[2361,7959],[2364,7988]]],[[[277,8210],[270,8217],[293,8221],[295,8199],[277,8210]]],[[[257,8259],[297,8258],[287,8221],[261,8230],[257,8259]]],[[[1844,8337],[1829,8330],[1851,8362],[1858,8352],[1844,8337]]],[[[1395,9317],[1429,9288],[1426,9252],[1382,9254],[1337,9272],[1349,9299],[1395,9317]]],[[[957,9478],[905,9483],[849,9475],[844,9483],[927,9507],[955,9496],[957,9478]]],[[[1358,9489],[1390,9481],[1388,9465],[1330,9444],[1302,9460],[1284,9490],[1291,9511],[1350,9498],[1358,9489]]],[[[2210,7911],[2202,7914],[2203,7927],[2195,7929],[2192,7933],[2192,7982],[2149,7996],[2126,7968],[2118,7937],[2082,7905],[1987,7905],[2022,7920],[2033,7943],[2111,7979],[2155,8025],[2239,8062],[2276,8063],[2298,8050],[2295,8032],[2262,8016],[2230,8020],[2256,8004],[2290,8010],[2271,7986],[2302,7943],[2350,7927],[2367,7937],[2394,7917],[2333,7893],[2308,7894],[2257,7848],[2239,7871],[2245,7889],[2279,7910],[2289,7938],[2249,7913],[2210,7911]]],[[[2018,7927],[2024,7931],[2021,7924],[2020,7921],[2009,7921],[2015,7925],[2012,7925],[2016,7930],[2021,7930],[2018,7927]]],[[[518,8075],[504,8083],[514,8081],[518,8075],[518,8075],[518,8075]]],[[[629,9322],[617,9345],[604,9327],[571,9328],[559,9347],[597,9359],[678,9417],[749,9430],[780,9414],[754,9406],[765,9375],[730,9364],[718,9338],[684,9302],[660,9308],[712,9340],[710,9380],[687,9377],[670,9338],[629,9322]]],[[[2606,8006],[2634,8020],[2643,7998],[2633,7971],[2596,7976],[2607,7995],[2574,7990],[2550,7973],[2552,8004],[2449,8000],[2441,8012],[2462,8038],[2521,8144],[2553,8130],[2521,8094],[2558,8090],[2552,8069],[2599,8083],[2618,8064],[2604,8038],[2629,8033],[2606,8006]]],[[[1663,8674],[1617,8670],[1645,8694],[1639,8718],[1654,8775],[1667,8783],[1687,8748],[1694,8761],[1761,8726],[1784,8700],[1824,8681],[1800,8664],[1725,8695],[1722,8679],[1673,8648],[1663,8674]]],[[[1295,8985],[1330,8964],[1360,8932],[1379,8931],[1340,8910],[1312,8914],[1248,8940],[1284,8957],[1295,8985]]],[[[1118,9032],[1191,8997],[1210,8979],[1165,8981],[1152,8958],[1175,8964],[1181,8940],[1135,8927],[1046,8948],[1043,8964],[1019,8939],[971,8925],[843,8910],[830,8948],[762,8954],[719,8990],[733,8998],[815,9008],[894,9005],[875,9018],[821,9029],[760,9020],[715,9023],[691,9046],[758,9065],[767,9075],[697,9065],[700,9081],[671,9079],[670,9095],[698,9112],[685,9123],[721,9151],[804,9178],[822,9164],[829,9134],[850,9157],[903,9140],[890,9116],[922,9133],[946,9128],[919,9156],[937,9155],[980,9131],[1007,9079],[1021,9094],[1006,9107],[996,9142],[999,9187],[1024,9167],[1044,9168],[1077,9144],[1079,9125],[1107,9076],[1100,9049],[1118,9032]]],[[[1885,9194],[1941,9161],[1939,9145],[1830,9148],[1807,9172],[1804,9199],[1885,9194]]],[[[1340,9095],[1291,9080],[1274,9059],[1217,9110],[1182,9118],[1155,9145],[1179,9161],[1198,9140],[1223,9141],[1230,9163],[1188,9184],[1204,9198],[1291,9219],[1302,9241],[1296,9210],[1318,9205],[1321,9178],[1285,9158],[1318,9154],[1331,9167],[1346,9123],[1340,9095]]],[[[596,9246],[638,9229],[700,9230],[736,9218],[782,9183],[668,9135],[638,9108],[624,9071],[551,9049],[522,9083],[467,9098],[499,9159],[531,9200],[502,9234],[596,9246]]],[[[1227,9273],[1215,9298],[1242,9311],[1158,9302],[1138,9317],[1171,9332],[1183,9360],[1242,9329],[1202,9368],[1208,9378],[1306,9362],[1313,9300],[1295,9274],[1227,9273]]],[[[938,9326],[960,9339],[928,9351],[976,9386],[984,9335],[1027,9326],[1040,9336],[1073,9326],[1073,9306],[1130,9283],[1100,9275],[1068,9293],[1058,9276],[987,9267],[975,9276],[890,9242],[830,9239],[808,9254],[857,9271],[887,9271],[912,9287],[822,9276],[820,9294],[792,9270],[717,9284],[764,9354],[794,9364],[795,9380],[808,9377],[822,9344],[851,9349],[896,9323],[902,9303],[972,9302],[974,9314],[938,9326]]],[[[1848,9265],[1825,9250],[1777,9240],[1726,9247],[1603,9240],[1567,9252],[1535,9244],[1473,9259],[1459,9285],[1470,9325],[1440,9355],[1412,9348],[1360,9357],[1331,9393],[1362,9399],[1423,9389],[1442,9371],[1490,9375],[1552,9344],[1528,9336],[1587,9303],[1652,9304],[1719,9322],[1797,9319],[1840,9300],[1841,9283],[1817,9274],[1848,9265]]],[[[933,9426],[877,9415],[845,9427],[833,9446],[816,9439],[788,9455],[811,9463],[843,9452],[918,9464],[949,9456],[933,9426]]],[[[1126,9547],[1165,9524],[1187,9528],[1249,9496],[1240,9486],[1266,9450],[1200,9447],[1205,9471],[1154,9471],[1155,9482],[1104,9475],[1087,9490],[1131,9490],[1115,9522],[1071,9525],[1076,9545],[1126,9547]]],[[[1511,9629],[1553,9627],[1562,9603],[1579,9620],[1601,9618],[1623,9584],[1617,9561],[1665,9561],[1684,9542],[1637,9527],[1563,9469],[1474,9471],[1406,9521],[1437,9534],[1477,9534],[1456,9553],[1417,9540],[1362,9550],[1334,9600],[1389,9593],[1338,9609],[1354,9630],[1379,9632],[1370,9645],[1389,9663],[1439,9666],[1403,9677],[1436,9685],[1480,9670],[1511,9629]]],[[[518,8075],[519,8073],[519,8072],[518,8075],[518,8075],[518,8075]]]]}},{\"type\":\"Feature\",\"id\":\"ST\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.55,\"hc-middle-y\":0.5,\"hc-key\":\"st\",\"hc-a2\":\"ST\",\"name\":\"Sao Tome and Principe\",\"labelrank\":\"6\",\"country-abbrev\":\"S.T.P.\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"STP\",\"iso-a2\":\"ST\",\"woe-id\":\"23424966\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4400,6481],[4396,6485],[4401,6491],[4405,6487],[4400,6481]]]}},{\"type\":\"Feature\",\"id\":\"CV\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.56,\"hc-middle-y\":0.5,\"hc-key\":\"cv\",\"hc-a2\":\"CV\",\"name\":\"Cape Verde\",\"labelrank\":\"4\",\"country-abbrev\":\"C.Vd.\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"CPV\",\"iso-a2\":\"CV\",\"woe-id\":\"23424794\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3499,6934],[3506,6928],[3507,6922],[3499,6925],[3499,6934]]]}},{\"type\":\"Feature\",\"id\":\"DM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.54,\"hc-middle-y\":0.47,\"hc-key\":\"dm\",\"hc-a2\":\"DM\",\"name\":\"Dominica\",\"labelrank\":\"6\",\"country-abbrev\":\"D'inca\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"DMA\",\"iso-a2\":\"DM\",\"woe-id\":\"23424798\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2382,6942],[2386,6936],[2383,6930],[2380,6939],[2382,6942]]]}},{\"type\":\"Feature\",\"id\":\"NL\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.99,\"hc-middle-y\":0.01,\"hc-key\":\"nl\",\"hc-a2\":\"NL\",\"name\":\"Netherlands\",\"labelrank\":\"5\",\"country-abbrev\":\"Neth.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"NLD\",\"iso-a2\":\"NL\",\"woe-id\":\"-90\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4369,8229],[4359,8225],[4360,8227],[4372,8230],[4369,8229]]],[[[2334,7016],[2331,7016],[2331,7017],[2334,7016]]],[[[4303,8146],[4315,8146],[4329,8146],[4317,8140],[4303,8146]]],[[[4417,8221],[4412,8180],[4393,8164],[4382,8122],[4353,8150],[4330,8146],[4318,8156],[4355,8209],[4396,8234],[4417,8221]]]]}},{\"type\":\"Feature\",\"id\":\"JM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.52,\"hc-key\":\"jm\",\"hc-a2\":\"JM\",\"name\":\"Jamaica\",\"labelrank\":\"4\",\"country-abbrev\":\"Jam.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"JAM\",\"iso-a2\":\"JM\",\"woe-id\":\"23424858\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1906,7029],[1943,7013],[1913,7006],[1878,7023],[1906,7029]]]}},{\"type\":\"Feature\",\"id\":\"WS\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.54,\"hc-key\":\"ws\",\"hc-a2\":\"WS\",\"name\":\"Samoa\",\"labelrank\":\"4\",\"country-abbrev\":\"Samoa\",\"subregion\":\"Polynesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"WSM\",\"iso-a2\":\"WS\",\"woe-id\":\"23424992\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[-909,6078],[-907,6069],[-916,6069],[-924,6078],[-909,6078]]]}},{\"type\":\"Feature\",\"id\":\"OM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.88,\"hc-middle-y\":0.44,\"hc-key\":\"om\",\"hc-a2\":\"OM\",\"name\":\"Oman\",\"labelrank\":\"4\",\"country-abbrev\":\"Oman\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"OMN\",\"iso-a2\":\"OM\",\"woe-id\":\"23424898\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5874,7239],[5873,7238],[5873,7241],[5876,7241],[5874,7239]]],[[[5868,7265],[5877,7275],[5874,7251],[5870,7253],[5868,7265]]],[[[5747,7045],[5836,7076],[5855,7137],[5842,7160],[5860,7228],[5877,7231],[5900,7199],[5948,7186],[5979,7145],[5916,7068],[5920,7047],[5885,7033],[5876,7013],[5849,7010],[5837,6985],[5780,6974],[5769,6994],[5747,7045]]]]}},{\"type\":\"Feature\",\"id\":\"VC\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.5,\"hc-key\":\"vc\",\"hc-a2\":\"VC\",\"name\":\"Saint Vincent and the Grenadines\",\"labelrank\":\"6\",\"country-abbrev\":\"St.V.G.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"VCT\",\"iso-a2\":\"VC\",\"woe-id\":\"23424981\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2388,6865],[2385,6871],[2389,6875],[2390,6870],[2388,6865]]]}},{\"type\":\"Feature\",\"id\":\"TR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.34,\"hc-middle-y\":0.49,\"hc-key\":\"tr\",\"hc-a2\":\"TR\",\"name\":\"Turkey\",\"labelrank\":\"2\",\"country-abbrev\":\"Tur.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"TUR\",\"iso-a2\":\"TR\",\"woe-id\":\"23424969\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4974,7732],[4969,7730],[4966,7731],[4973,7735],[4974,7732]]],[[[5035,7796],[5068,7769],[5021,7761],[5011,7748],[4977,7752],[4994,7775],[4985,7786],[5007,7799],[5035,7796]]],[[[5534,7714],[5510,7704],[5516,7656],[5532,7628],[5472,7635],[5461,7627],[5457,7634],[5384,7614],[5338,7620],[5291,7617],[5270,7586],[5272,7620],[5252,7608],[5229,7615],[5177,7590],[5154,7607],[5115,7619],[5106,7597],[5085,7593],[5044,7625],[5011,7635],[5012,7657],[4983,7666],[5007,7687],[4989,7700],[4986,7702],[4979,7707],[4997,7740],[5069,7741],[5071,7770],[5131,7764],[5193,7797],[5271,7787],[5318,7762],[5374,7765],[5395,7758],[5436,7779],[5474,7782],[5493,7765],[5500,7730],[5533,7716],[5534,7714]]]]}},{\"type\":\"Feature\",\"id\":\"BD\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.85,\"hc-middle-y\":0.61,\"hc-key\":\"bd\",\"hc-a2\":\"BD\",\"name\":\"Bangladesh\",\"labelrank\":\"3\",\"country-abbrev\":\"Bang.\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"BGD\",\"iso-a2\":\"BD\",\"woe-id\":\"23424759\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6942,7109],[6918,7163],[6880,7132],[6847,7142],[6832,7189],[6837,7209],[6816,7220],[6843,7237],[6818,7260],[6829,7277],[6870,7262],[6886,7236],[6935,7237],[6949,7229],[6909,7188],[6922,7167],[6939,7192],[6951,7137],[6953,7116],[6942,7109]]]}},{\"type\":\"Feature\",\"id\":\"LC\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.52,\"hc-middle-y\":0.47,\"hc-key\":\"lc\",\"hc-a2\":\"LC\",\"name\":\"Saint Lucia\",\"labelrank\":\"6\",\"country-abbrev\":\"S.L.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"LCA\",\"iso-a2\":\"LC\",\"woe-id\":\"23424951\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2395,6886],[2391,6890],[2396,6897],[2397,6893],[2395,6886]]]}},{\"type\":\"Feature\",\"id\":\"NR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.53,\"hc-middle-y\":0.5,\"hc-key\":\"nr\",\"hc-a2\":\"NR\",\"name\":\"Nauru\",\"labelrank\":\"6\",\"country-abbrev\":\"Nauru\",\"subregion\":\"Micronesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"NRU\",\"iso-a2\":\"NR\",\"woe-id\":\"23424912\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[9158,6463],[9157,6463],[9157,6464],[9159,6464],[9158,6463]]]}},{\"type\":\"Feature\",\"id\":\"NO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.1,\"hc-middle-y\":0.93,\"hc-key\":\"no\",\"hc-a2\":\"NO\",\"name\":\"Norway\",\"labelrank\":\"3\",\"country-abbrev\":\"Nor.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"NOR\",\"iso-a2\":\"NO\",\"woe-id\":\"-90\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4821,8997],[4815,8993],[4809,8996],[4815,9003],[4821,8997]]],[[[4797,8992],[4790,8995],[4784,9004],[4802,8997],[4797,8992]]],[[[4877,9011],[4887,9004],[4870,9006],[4871,9011],[4877,9011]]],[[[4901,9024],[4906,9016],[4890,9006],[4882,9013],[4901,9024]]],[[[4911,9029],[4920,9024],[4909,9019],[4905,9028],[4911,9029]]],[[[4898,9036],[4889,9022],[4861,9017],[4873,9029],[4898,9036]]],[[[4918,9045],[4919,9040],[4914,9042],[4915,9046],[4918,9045]]],[[[4966,9053],[4974,9045],[4962,9041],[4955,9047],[4966,9053]]],[[[4841,9496],[4865,9475],[4829,9471],[4803,9490],[4841,9496]]],[[[4998,9499],[4989,9504],[4994,9510],[5000,9504],[4998,9499]]],[[[5066,9517],[5038,9511],[5030,9512],[5047,9521],[5066,9517]]],[[[4804,9531],[4822,9526],[4810,9523],[4799,9526],[4804,9531]]],[[[4802,9547],[4789,9545],[4786,9549],[4789,9550],[4802,9547]]],[[[5202,9605],[5178,9599],[5142,9595],[5139,9598],[5202,9605]]],[[[4928,9617],[4921,9616],[4921,9620],[4923,9621],[4928,9617]]],[[[4921,9625],[4925,9623],[4923,9622],[4917,9623],[4921,9625]]],[[[4797,9623],[4793,9624],[4796,9627],[4801,9625],[4797,9623]]],[[[4837,9638],[4831,9635],[4828,9638],[4834,9639],[4837,9638]]],[[[4821,9634],[4821,9638],[4813,9643],[4826,9639],[4821,9634]]],[[[4748,8967],[4767,8968],[4802,8988],[4813,8979],[4815,8980],[4817,8980],[4818,8983],[4823,8988],[4820,8990],[4826,8992],[4827,8992],[4845,9007],[4847,9007],[4847,9006],[4849,9005],[4850,9007],[4886,9002],[4934,9033],[4973,9037],[4948,9018],[4950,8995],[4996,9042],[4991,9010],[5022,9050],[5094,9029],[5126,9006],[5099,8995],[5057,9000],[5119,8981],[5093,8957],[5063,8940],[5075,8962],[5032,8995],[4976,8974],[4965,8932],[4942,8915],[4914,8929],[4869,8923],[4847,8952],[4816,8940],[4797,8905],[4743,8914],[4735,8885],[4718,8892],[4683,8857],[4691,8839],[4635,8792],[4635,8753],[4609,8718],[4618,8690],[4580,8688],[4560,8656],[4569,8610],[4565,8584],[4586,8568],[4568,8551],[4575,8512],[4556,8501],[4543,8462],[4515,8473],[4456,8430],[4429,8420],[4398,8424],[4359,8468],[4372,8509],[4342,8554],[4363,8576],[4347,8589],[4369,8612],[4411,8630],[4409,8639],[4464,8659],[4435,8662],[4465,8681],[4504,8658],[4544,8680],[4498,8667],[4487,8679],[4537,8729],[4562,8742],[4566,8761],[4607,8833],[4667,8874],[4643,8878],[4692,8898],[4682,8907],[4716,8924],[4703,8941],[4719,8966],[4748,8967],[4769,8982],[4768,8999],[4781,8983],[4748,8967]],[[5095,8982],[5091,8986],[5086,8978],[5097,8981],[5095,8982]]],[[[4948,9363],[4949,9366],[4963,9376],[4948,9363],[4948,9363],[4948,9363]]],[[[4630,8922],[4662,8932],[4682,8955],[4696,8923],[4668,8902],[4602,8890],[4605,8899],[4657,8910],[4630,8922]]],[[[4893,9411],[4874,9424],[4825,9422],[4847,9452],[4824,9463],[4886,9474],[4905,9449],[4929,9446],[4893,9411]]],[[[4669,9570],[4695,9593],[4764,9552],[4766,9533],[4843,9513],[4768,9488],[4744,9425],[4730,9424],[4703,9367],[4631,9407],[4617,9428],[4702,9450],[4611,9443],[4607,9461],[4650,9465],[4673,9480],[4644,9505],[4641,9483],[4590,9471],[4561,9497],[4565,9471],[4533,9487],[4515,9516],[4540,9521],[4522,9560],[4531,9569],[4564,9568],[4613,9582],[4616,9559],[4636,9577],[4658,9563],[4689,9517],[4669,9570]]],[[[4909,9611],[5000,9602],[5010,9580],[4975,9557],[4918,9535],[4884,9538],[4883,9551],[4822,9548],[4787,9564],[4852,9570],[4854,9578],[4761,9571],[4763,9592],[4732,9599],[4742,9610],[4778,9596],[4809,9619],[4824,9604],[4852,9608],[4868,9590],[4879,9624],[4887,9601],[4909,9611]]],[[[4948,9363],[4946,9359],[4947,9363],[4948,9363],[4948,9363],[4948,9363]]]]}},{\"type\":\"Feature\",\"id\":\"KN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.57,\"hc-middle-y\":0.49,\"hc-key\":\"kn\",\"hc-a2\":\"KN\",\"name\":\"Saint Kitts and Nevis\",\"labelrank\":\"6\",\"country-abbrev\":\"St.K.N.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"KNA\",\"iso-a2\":\"KN\",\"woe-id\":\"23424940\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2346,6991],[2339,6996],[2340,6997],[2343,6995],[2346,6991]]]}},{\"type\":\"Feature\",\"id\":\"BH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.5,\"hc-key\":\"bh\",\"hc-a2\":\"BH\",\"name\":\"Bahrain\",\"labelrank\":\"4\",\"country-abbrev\":\"Bahr.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"BHR\",\"iso-a2\":\"BH\",\"woe-id\":\"23424753\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5702,7271],[5706,7269],[5705,7256],[5701,7263],[5702,7271]]]}},{\"type\":\"Feature\",\"id\":\"TO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.54,\"hc-middle-y\":0.34,\"hc-key\":\"to\",\"hc-a2\":\"TO\",\"name\":\"Tonga\",\"labelrank\":\"4\",\"country-abbrev\":\"Tongo\",\"subregion\":\"Polynesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"TON\",\"iso-a2\":\"TO\",\"woe-id\":\"23424964\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[-987,5842],[-988,5840],[-999,5845],[-992,5847],[-987,5842]]]}},{\"type\":\"Feature\",\"id\":\"FI\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.63,\"hc-middle-y\":0.54,\"hc-key\":\"fi\",\"hc-a2\":\"FI\",\"name\":\"Finland\",\"labelrank\":\"3\",\"country-abbrev\":\"Fin.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"FIN\",\"iso-a2\":\"FI\",\"woe-id\":\"23424812\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4816,8512],[4815,8507],[4806,8505],[4810,8509],[4816,8512]]],[[[4803,8510],[4806,8512],[4803,8505],[4798,8508],[4803,8510]]],[[[4808,8518],[4799,8510],[4785,8518],[4800,8522],[4808,8518]]],[[[4844,8516],[4844,8514],[4855,8514],[4842,8511],[4844,8516]]],[[[4870,8506],[4870,8515],[4882,8511],[4872,8501],[4870,8506]]],[[[4836,8532],[4837,8528],[4836,8523],[4835,8528],[4836,8532]]],[[[4835,8657],[4838,8652],[4834,8650],[4830,8654],[4835,8657]]],[[[4942,8741],[4935,8736],[4933,8739],[4936,8741],[4942,8741]]],[[[4851,8526],[4845,8528],[4834,8596],[4842,8652],[4868,8658],[4939,8731],[4954,8729],[4955,8762],[4921,8778],[4906,8808],[4916,8826],[4899,8860],[4906,8885],[4816,8940],[4847,8952],[4869,8923],[4914,8929],[4942,8915],[4965,8932],[4976,8974],[5032,8995],[5075,8962],[5063,8940],[5048,8914],[5055,8897],[5095,8871],[5067,8828],[5091,8792],[5082,8737],[5111,8691],[5094,8678],[5141,8638],[5131,8620],[5071,8562],[5029,8531],[4909,8505],[4869,8520],[4871,8521],[4866,8521],[4866,8521],[4854,8525],[4857,8523],[4856,8520],[4851,8524],[4851,8526]]]]}},{\"type\":\"Feature\",\"id\":\"ID\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.38,\"hc-middle-y\":0.41,\"hc-key\":\"id\",\"hc-a2\":\"ID\",\"name\":\"Indonesia\",\"labelrank\":\"2\",\"country-abbrev\":\"Indo.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"IDN\",\"iso-a2\":\"ID\",\"woe-id\":\"23424846\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[8188,6311],[8203,6311],[8186,6274],[8184,6299],[8156,6320],[8188,6311]]],[[[7394,6396],[7365,6387],[7343,6415],[7351,6432],[7368,6393],[7394,6396]]],[[[7693,6231],[7736,6235],[7737,6224],[7676,6209],[7642,6218],[7658,6236],[7693,6231]]],[[[8007,6546],[8003,6517],[8028,6486],[8001,6493],[7995,6439],[7976,6470],[7993,6473],[7985,6514],[8007,6546]]],[[[7885,6203],[7891,6198],[7897,6207],[7902,6208],[7911,6214],[7912,6206],[7915,6198],[7897,6179],[7868,6172],[7885,6203]]],[[[7703,6601],[7696,6596],[7697,6601],[7703,6601]]],[[[8388,6402],[8388,6275],[8388,6210],[8360,6240],[8289,6230],[8299,6253],[8325,6262],[8294,6324],[8238,6346],[8216,6347],[8170,6376],[8148,6358],[8127,6400],[8181,6408],[8142,6411],[8087,6439],[8070,6476],[8099,6455],[8142,6468],[8180,6457],[8185,6415],[8210,6380],[8248,6403],[8246,6430],[8295,6435],[8355,6409],[8388,6402]]],[[[7779,6174],[7734,6196],[7755,6202],[7771,6234],[7833,6224],[7852,6236],[7936,6242],[7886,6226],[7878,6234],[7818,6216],[7763,6218],[7789,6183],[7779,6174]]],[[[7419,6248],[7365,6260],[7335,6278],[7351,6305],[7419,6294],[7427,6279],[7483,6274],[7496,6290],[7530,6275],[7624,6277],[7624,6218],[7565,6234],[7548,6229],[7490,6237],[7450,6251],[7419,6248]]],[[[8007,6388],[7965,6365],[7943,6380],[7942,6408],[7946,6387],[7976,6380],[8002,6393],[8048,6397],[8079,6386],[8086,6365],[8007,6388]]],[[[7849,6311],[7824,6317],[7851,6347],[7809,6341],[7813,6358],[7778,6383],[7775,6316],[7746,6321],[7754,6351],[7730,6401],[7746,6421],[7766,6500],[7792,6519],[7814,6510],[7882,6503],[7917,6531],[7898,6492],[7774,6491],[7765,6473],[7785,6438],[7815,6465],[7866,6460],[7862,6427],[7846,6446],[7811,6422],[7839,6386],[7855,6349],[7849,6311]]],[[[7693,6601],[7687,6576],[7709,6546],[7702,6535],[7736,6509],[7698,6501],[7689,6463],[7663,6436],[7664,6414],[7646,6373],[7606,6356],[7594,6380],[7558,6385],[7522,6375],[7519,6397],[7476,6390],[7466,6446],[7452,6441],[7434,6503],[7458,6540],[7485,6504],[7557,6525],[7602,6521],[7631,6568],[7642,6608],[7693,6601]]],[[[7120,6602],[7164,6572],[7200,6534],[7221,6541],[7283,6486],[7272,6457],[7301,6448],[7311,6409],[7338,6408],[7352,6382],[7345,6312],[7312,6304],[7219,6384],[7196,6415],[7181,6455],[7152,6486],[7124,6478],[7149,6426],[7139,6429],[7121,6478],[7145,6496],[7128,6536],[7092,6539],[7110,6508],[7103,6496],[7087,6540],[7065,6548],[7092,6543],[7100,6563],[7036,6621],[7032,6650],[7065,6633],[7097,6634],[7120,6602]]]]}},{\"type\":\"Feature\",\"id\":\"MU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.63,\"hc-middle-y\":0.58,\"hc-key\":\"mu\",\"hc-a2\":\"MU\",\"name\":\"Mauritius\",\"labelrank\":\"5\",\"country-abbrev\":\"Mus.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"MUS\",\"iso-a2\":\"MU\",\"woe-id\":\"23424894\",\"continent\":\"Seven seas (open ocean)\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5917,5878],[5916,5867],[5907,5866],[5911,5880],[5917,5878]]]}},{\"type\":\"Feature\",\"id\":\"SE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.4,\"hc-middle-y\":0.48,\"hc-key\":\"se\",\"hc-a2\":\"SE\",\"name\":\"Sweden\",\"labelrank\":\"3\",\"country-abbrev\":\"Swe.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"SWE\",\"iso-a2\":\"SE\",\"woe-id\":\"23424954\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4749,8461],[4749,8461],[4749,8466],[4753,8466],[4749,8461]]],[[[4864,8758],[4864,8764],[4868,8762],[4868,8758],[4864,8758]]],[[[4921,8778],[4853,8764],[4831,8722],[4845,8711],[4821,8684],[4769,8651],[4733,8619],[4712,8569],[4718,8540],[4736,8533],[4770,8495],[4751,8469],[4701,8445],[4691,8414],[4700,8372],[4711,8391],[4741,8387],[4760,8415],[4759,8386],[4710,8386],[4693,8344],[4640,8340],[4625,8309],[4589,8309],[4571,8373],[4546,8417],[4550,8417],[4552,8421],[4545,8421],[4546,8418],[4537,8434],[4543,8462],[4556,8501],[4575,8512],[4568,8551],[4586,8568],[4565,8584],[4569,8610],[4560,8656],[4580,8688],[4618,8690],[4609,8718],[4635,8753],[4635,8792],[4691,8839],[4683,8857],[4718,8892],[4735,8885],[4743,8914],[4797,8905],[4816,8940],[4906,8885],[4899,8860],[4916,8826],[4906,8808],[4921,8778]],[[4554,8430],[4543,8426],[4546,8423],[4554,8424],[4554,8430]]]]}},{\"type\":\"Feature\",\"id\":\"TT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.46,\"hc-middle-y\":0.44,\"hc-key\":\"tt\",\"hc-a2\":\"TT\",\"name\":\"Trinidad and Tobago\",\"labelrank\":\"5\",\"country-abbrev\":\"Tr.T.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"TTO\",\"iso-a2\":\"TT\",\"woe-id\":\"23424958\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2396,6799],[2394,6779],[2380,6783],[2374,6796],[2396,6799]]]}},{\"type\":\"Feature\",\"id\":\"MY\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.9,\"hc-middle-y\":0.26,\"hc-key\":\"my\",\"hc-a2\":\"MY\",\"name\":\"Malaysia\",\"labelrank\":\"3\",\"country-abbrev\":\"Malay.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"MYS\",\"iso-a2\":\"MY\",\"woe-id\":\"23424901\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[7181,6640],[7180,6634],[7177,6634],[7177,6640],[7181,6640]]],[[[7703,6601],[7697,6601],[7698,6602],[7693,6601],[7642,6608],[7631,6568],[7602,6521],[7557,6525],[7485,6504],[7458,6540],[7498,6525],[7508,6550],[7510,6549],[7510,6554],[7511,6558],[7558,6572],[7587,6614],[7606,6597],[7616,6623],[7617,6624],[7618,6621],[7627,6606],[7621,6623],[7650,6660],[7685,6675],[7743,6632],[7710,6623],[7722,6607],[7701,6603],[7703,6601]]],[[[7175,6669],[7204,6663],[7205,6645],[7233,6663],[7274,6620],[7274,6565],[7299,6519],[7272,6524],[7210,6563],[7193,6593],[7175,6669]]]]}},{\"type\":\"Feature\",\"id\":\"PA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.22,\"hc-middle-y\":0.5,\"hc-key\":\"pa\",\"hc-a2\":\"PA\",\"name\":\"Panama\",\"labelrank\":\"4\",\"country-abbrev\":\"Pan.\",\"subregion\":\"Central America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"PAN\",\"iso-a2\":\"PA\",\"woe-id\":\"23424924\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1892,6692],[1873,6732],[1843,6744],[1816,6717],[1829,6699],[1776,6692],[1778,6721],[1744,6716],[1739,6725],[1740,6725],[1740,6725],[1740,6726],[1740,6726],[1754,6762],[1768,6743],[1798,6739],[1841,6763],[1876,6757],[1908,6735],[1914,6713],[1892,6692]]]}},{\"type\":\"Feature\",\"id\":\"PW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.38,\"hc-middle-y\":0.44,\"hc-key\":\"pw\",\"hc-a2\":\"PW\",\"name\":\"Palau\",\"labelrank\":\"6\",\"country-abbrev\":\"Palau\",\"subregion\":\"Micronesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"PLW\",\"iso-a2\":\"PW\",\"woe-id\":\"23424927\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8196,6695],[8195,6699],[8197,6703],[8200,6703],[8196,6695]]]}},{\"type\":\"Feature\",\"id\":\"TV\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.25,\"hc-middle-y\":0.5,\"hc-key\":\"tv\",\"hc-a2\":\"TV\",\"name\":\"Tuvalu\",\"labelrank\":\"6\",\"country-abbrev\":\"Tuv.\",\"subregion\":\"Polynesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"TUV\",\"iso-a2\":\"TV\",\"woe-id\":\"23424970\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[9522,6227],[9522,6227],[9522,6229],[9522,6227],[9522,6227]]]}},{\"type\":\"Feature\",\"id\":\"MH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.6,\"hc-key\":\"mh\",\"hc-a2\":\"MH\",\"name\":\"Marshall Islands\",\"labelrank\":\"6\",\"country-abbrev\":\"M. Is.\",\"subregion\":\"Micronesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"MHL\",\"iso-a2\":\"MH\",\"woe-id\":\"23424932\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[9280,6690],[9285,6688],[9286,6687],[9285,6688],[9280,6690]]]}},{\"type\":\"Feature\",\"id\":\"CL\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.51,\"hc-middle-y\":0.9,\"hc-key\":\"cl\",\"hc-a2\":\"CL\",\"name\":\"Chile\",\"labelrank\":\"2\",\"country-abbrev\":\"Chile\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"CHL\",\"iso-a2\":\"CL\",\"woe-id\":\"23424782\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[2028,4732],[2063,4714],[2042,4700],[2014,4729],[2028,4732]]],[[[1977,4948],[1993,4916],[1994,4867],[1960,4879],[1981,4893],[1959,4908],[1961,4938],[1977,4948]]],[[[2022,5147],[2016,5111],[1985,5101],[2001,5124],[2006,5163],[2022,5147]]],[[[2167,4761],[2167,4674],[2165,4674],[2167,4673],[2167,4670],[2128,4674],[2110,4657],[2088,4695],[2113,4723],[2117,4693],[2157,4688],[2125,4702],[2114,4746],[2144,4768],[2167,4761]]],[[[2115,5932],[2128,5935],[2141,5957],[2157,5913],[2173,5898],[2163,5868],[2180,5842],[2189,5794],[2210,5794],[2206,5757],[2169,5733],[2177,5666],[2162,5659],[2137,5618],[2109,5516],[2133,5456],[2115,5397],[2115,5366],[2096,5352],[2091,5311],[2101,5277],[2085,5269],[2069,5206],[2075,5158],[2063,5125],[2077,5092],[2066,5062],[2088,5042],[2070,4970],[2051,4944],[2059,4928],[2020,4882],[2032,4835],[2058,4839],[2054,4804],[2070,4787],[2128,4786],[2173,4772],[2152,4778],[2105,4757],[2096,4714],[2032,4737],[2038,4753],[2004,4758],[1996,4781],[2017,4777],[2012,4815],[1976,4834],[2000,4847],[1996,4918],[1986,4952],[2000,4987],[1966,4992],[1995,5037],[2008,5015],[2031,5042],[2026,5058],[1996,5060],[2012,5097],[2020,5062],[2053,5159],[2039,5179],[2015,5170],[2010,5197],[2030,5249],[2018,5310],[2031,5329],[2048,5383],[2060,5398],[2085,5489],[2078,5559],[2088,5569],[2081,5601],[2100,5643],[2113,5714],[2109,5785],[2125,5837],[2115,5932]]],[[[2209,4666],[2230,4654],[2168,4659],[2214,4627],[2192,4628],[2162,4657],[2133,4648],[2129,4663],[2202,4668],[2207,4668],[2209,4666]]]]}},{\"type\":\"Feature\",\"id\":\"TH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.25,\"hc-middle-y\":0.49,\"hc-key\":\"th\",\"hc-a2\":\"TH\",\"name\":\"Thailand\",\"labelrank\":\"3\",\"country-abbrev\":\"Thai.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"THA\",\"iso-a2\":\"TH\",\"woe-id\":\"23424960\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[7239,6839],[7241,6837],[7244,6834],[7240,6833],[7239,6839]]],[[[7233,6663],[7205,6645],[7204,6663],[7175,6669],[7151,6704],[7118,6732],[7134,6785],[7161,6829],[7146,6886],[7119,6918],[7137,6959],[7095,7030],[7113,7070],[7128,7066],[7175,7086],[7186,7062],[7209,7061],[7205,6999],[7233,7022],[7249,7010],[7272,7029],[7290,7025],[7315,6996],[7313,6970],[7338,6946],[7325,6904],[7280,6907],[7241,6881],[7258,6824],[7226,6854],[7201,6852],[7200,6878],[7173,6876],[7172,6840],[7151,6793],[7149,6752],[7167,6753],[7185,6690],[7218,6681],[7233,6663]]]]}},{\"type\":\"Feature\",\"id\":\"GD\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.5,\"hc-key\":\"gd\",\"hc-a2\":\"GD\",\"name\":\"Grenada\",\"labelrank\":\"6\",\"country-abbrev\":\"Gren.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"GRD\",\"iso-a2\":\"GD\",\"woe-id\":\"23424826\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2375,6835],[2372,6835],[2372,6839],[2376,6841],[2375,6835]]]}},{\"type\":\"Feature\",\"id\":\"EE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.35,\"hc-middle-y\":0.41,\"hc-key\":\"ee\",\"hc-a2\":\"EE\",\"name\":\"Estonia\",\"labelrank\":\"6\",\"country-abbrev\":\"Est.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"EST\",\"iso-a2\":\"EE\",\"woe-id\":\"23424805\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4876,8444],[4887,8435],[4863,8425],[4852,8441],[4876,8444]]],[[[4897,8446],[4893,8442],[4888,8445],[4892,8448],[4897,8446]]],[[[4893,8464],[4897,8464],[4898,8461],[4891,8461],[4893,8464]]],[[[4878,8463],[4888,8455],[4872,8449],[4858,8459],[4878,8463]]],[[[5026,8462],[5004,8453],[5024,8419],[5021,8411],[5016,8399],[4990,8398],[4954,8422],[4925,8413],[4902,8443],[4901,8472],[4975,8490],[5035,8483],[5038,8482],[5040,8478],[5038,8477],[5035,8477],[5035,8477],[5037,8476],[5037,8476],[5038,8476],[5037,8476],[5034,8476],[5030,8469],[5026,8462]]]]}},{\"type\":\"Feature\",\"id\":\"AG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.48,\"hc-key\":\"ag\",\"hc-a2\":\"AG\",\"name\":\"Antigua and Barbuda\",\"labelrank\":\"6\",\"country-abbrev\":\"Ant.B.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"ATG\",\"iso-a2\":\"AG\",\"woe-id\":\"23424737\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2371,6989],[2373,6986],[2369,6985],[2367,6988],[2371,6989]]]}},{\"type\":\"Feature\",\"id\":\"TW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.41,\"hc-key\":\"tw\",\"hc-a2\":\"TW\",\"name\":\"Taiwan\",\"labelrank\":\"3\",\"country-abbrev\":\"Taiwan\",\"subregion\":\"Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"TWN\",\"iso-a2\":\"TW\",\"woe-id\":\"23424971\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7752,7185],[7768,7185],[7797,7233],[7821,7235],[7807,7173],[7790,7136],[7752,7185]]]}},{\"type\":\"Feature\",\"id\":\"BB\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.31,\"hc-middle-y\":0.56,\"hc-key\":\"bb\",\"hc-a2\":\"BB\",\"name\":\"Barbados\",\"labelrank\":\"5\",\"country-abbrev\":\"Barb.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"BRB\",\"iso-a2\":\"BB\",\"woe-id\":\"23424754\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2438,6866],[2434,6868],[2435,6874],[2440,6869],[2438,6866]]]}},{\"type\":\"Feature\",\"id\":\"IT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.79,\"hc-middle-y\":0.71,\"hc-key\":\"it\",\"hc-a2\":\"IT\",\"name\":\"Italy\",\"labelrank\":\"2\",\"country-abbrev\":\"Italy\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"ITA\",\"iso-a2\":\"IT\",\"woe-id\":\"23424853\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4571,7654],[4668,7666],[4655,7649],[4652,7611],[4634,7616],[4571,7654]]],[[[4484,7768],[4496,7744],[4488,7697],[4454,7690],[4456,7736],[4448,7757],[4484,7768]]],[[[4427,7861],[4400,7909],[4412,7939],[4444,7951],[4466,7944],[4500,7955],[4514,7974],[4566,7982],[4572,7967],[4611,7961],[4601,7952],[4611,7927],[4596,7933],[4565,7916],[4572,7876],[4608,7851],[4622,7818],[4654,7794],[4680,7795],[4677,7778],[4738,7749],[4753,7731],[4710,7744],[4694,7715],[4713,7705],[4681,7655],[4685,7684],[4668,7729],[4611,7770],[4591,7769],[4536,7815],[4504,7869],[4464,7884],[4427,7861]],[[4574,7793],[4574,7793],[4574,7793],[4574,7793],[4574,7793]],[[4574,7865],[4574,7868],[4573,7867],[4572,7866],[4574,7865]]]]}},{\"type\":\"Feature\",\"id\":\"MT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.53,\"hc-key\":\"mt\",\"hc-a2\":\"MT\",\"name\":\"Malta\",\"labelrank\":\"5\",\"country-abbrev\":\"Malta\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"MLT\",\"iso-a2\":\"MT\",\"woe-id\":\"23424897\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4628,7589],[4635,7586],[4635,7582],[4631,7584],[4628,7589]]]}},{\"type\":\"Feature\",\"id\":\"VU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.6,\"hc-middle-y\":0.53,\"hc-key\":\"vu\",\"hc-a2\":\"VU\",\"name\":\"Vanuatu\",\"labelrank\":\"4\",\"country-abbrev\":\"Van.\",\"subregion\":\"Melanesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"VUT\",\"iso-a2\":\"VU\",\"woe-id\":\"23424907\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[9172,6054],[9194,6034],[9205,5976],[9178,5988],[9154,6029],[9172,6054]]]}},{\"type\":\"Feature\",\"id\":\"SG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.57,\"hc-key\":\"sg\",\"hc-a2\":\"SG\",\"name\":\"Singapore\",\"labelrank\":\"6\",\"country-abbrev\":\"Sing.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"SGP\",\"iso-a2\":\"SG\",\"woe-id\":\"23424948\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7286,6521],[7290,6519],[7286,6516],[7280,6517],[7286,6521]]]}},{\"type\":\"Feature\",\"id\":\"CY\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.39,\"hc-middle-y\":0.51,\"hc-key\":\"cy\",\"hc-a2\":\"CY\",\"name\":\"Cyprus\",\"labelrank\":\"5\",\"country-abbrev\":\"Cyp.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"CYP\",\"iso-a2\":\"CY\",\"woe-id\":\"-90\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5205,7555],[5205,7556],[5206,7556],[5205,7555]]],[[[5214,7557],[5216,7554],[5210,7554],[5207,7557],[5210,7557],[5213,7557],[5214,7557]]],[[[5206,7555],[5206,7555],[5207,7555],[5207,7554],[5206,7555]]],[[[5204,7554],[5201,7549],[5184,7543],[5178,7545],[5176,7544],[5162,7557],[5171,7561],[5172,7560],[5173,7562],[5174,7561],[5175,7561],[5175,7561],[5175,7561],[5175,7561],[5175,7561],[5196,7561],[5204,7555],[5204,7554]]]]}},{\"type\":\"Feature\",\"id\":\"LK\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.62,\"hc-middle-y\":0.91,\"hc-key\":\"lk\",\"hc-a2\":\"LK\",\"name\":\"Sri Lanka\",\"labelrank\":\"3\",\"country-abbrev\":\"Sri L.\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"LKA\",\"iso-a2\":\"LK\",\"woe-id\":\"23424778\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6576,6765],[6600,6755],[6632,6703],[6631,6674],[6596,6654],[6581,6660],[6572,6717],[6584,6759],[6576,6765]]]}},{\"type\":\"Feature\",\"id\":\"KM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.41,\"hc-middle-y\":0.51,\"hc-key\":\"km\",\"hc-a2\":\"KM\",\"name\":\"Comoros\",\"labelrank\":\"6\",\"country-abbrev\":\"Com.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"COM\",\"iso-a2\":\"KM\",\"woe-id\":\"23424786\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5494,6125],[5487,6131],[5488,6142],[5492,6141],[5494,6125]]]}},{\"type\":\"Feature\",\"id\":\"FJ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.44,\"hc-middle-y\":0.33,\"hc-key\":\"fj\",\"hc-a2\":\"FJ\",\"name\":\"Fiji\",\"labelrank\":\"6\",\"country-abbrev\":\"Fiji\",\"subregion\":\"Melanesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"FJI\",\"iso-a2\":\"FJ\",\"woe-id\":\"23424813\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[9460,5963],[9494,5962],[9495,5978],[9543,5996],[9494,5959],[9507,5951],[9500,5915],[9490,5934],[9467,5939],[9460,5963]]]}},{\"type\":\"Feature\",\"id\":\"RU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.57,\"hc-middle-y\":0.56,\"hc-key\":\"ru\",\"hc-a2\":\"RU\",\"name\":\"Russia\",\"labelrank\":\"2\",\"country-abbrev\":\"Rus.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"RUS\",\"iso-a2\":\"RU\",\"woe-id\":\"23424936\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[8620,7917],[8587,7905],[8565,7884],[8519,7862],[8540,7887],[8614,7923],[8620,7917]]],[[[5691,8936],[5646,8924],[5637,8953],[5666,8965],[5693,8952],[5691,8936]]],[[[5965,9010],[5999,8987],[5972,8976],[5942,8995],[5965,9010]]],[[[6315,9176],[6331,9169],[6278,9157],[6280,9178],[6315,9176]]],[[[7568,9234],[7551,9218],[7512,9233],[7528,9245],[7568,9234]]],[[[5900,9603],[5857,9597],[5866,9613],[5939,9622],[5950,9582],[5900,9603]]],[[[5825,9623],[5819,9605],[5766,9602],[5774,9618],[5819,9609],[5825,9623]]],[[[5870,9665],[5945,9662],[5893,9635],[5861,9633],[5807,9645],[5870,9665]]],[[[6124,9673],[6147,9654],[6077,9637],[6060,9648],[6104,9658],[6124,9673]]],[[[5922,9709],[5937,9692],[5916,9668],[5861,9672],[5922,9709]]],[[[5391,7846],[5361,7874],[5289,7912],[5317,7918],[5327,7959],[5370,7979],[5338,7983],[5356,8011],[5384,8010],[5382,8045],[5395,8064],[5367,8087],[5315,8109],[5262,8106],[5245,8140],[5218,8142],[5225,8161],[5207,8185],[5147,8175],[5131,8212],[5175,8229],[5146,8243],[5121,8317],[5039,8340],[5024,8370],[5016,8399],[5021,8411],[5024,8419],[5030,8439],[5026,8462],[5030,8469],[5033,8474],[5037,8476],[5037,8476],[5035,8477],[5035,8477],[5035,8477],[5037,8476],[5040,8478],[5038,8482],[5035,8483],[5037,8497],[5090,8514],[5029,8531],[5071,8562],[5131,8620],[5141,8638],[5094,8678],[5111,8691],[5082,8737],[5091,8792],[5067,8828],[5095,8871],[5055,8897],[5048,8914],[5063,8940],[5093,8957],[5119,8981],[5155,8989],[5187,8976],[5154,8968],[5271,8947],[5422,8870],[5431,8846],[5404,8806],[5372,8793],[5330,8791],[5199,8822],[5161,8842],[5242,8773],[5227,8755],[5241,8731],[5264,8746],[5302,8746],[5378,8716],[5404,8728],[5386,8767],[5431,8789],[5468,8824],[5515,8780],[5524,8820],[5504,8845],[5517,8900],[5490,8918],[5567,8909],[5591,8879],[5550,8873],[5538,8852],[5564,8831],[5620,8836],[5629,8869],[5652,8873],[5723,8912],[5790,8934],[5806,8904],[5827,8896],[5866,8921],[5905,8916],[5951,8938],[5975,8904],[6011,8945],[5989,8968],[6007,8983],[6107,8967],[6153,8943],[6199,8929],[6230,8904],[6255,8935],[6236,8937],[6223,8964],[6186,8969],[6202,9029],[6176,9027],[6190,9061],[6236,9090],[6251,9138],[6269,9149],[6328,9151],[6366,9139],[6367,9115],[6336,9074],[6361,9051],[6354,9006],[6358,8935],[6389,8913],[6375,8873],[6358,8867],[6328,8819],[6292,8803],[6343,8798],[6385,8827],[6422,8871],[6414,8922],[6471,8938],[6499,8913],[6493,8875],[6522,8899],[6509,8932],[6445,8952],[6393,8949],[6386,8977],[6409,9019],[6371,9068],[6386,9090],[6428,9105],[6421,9150],[6448,9187],[6481,9183],[6445,9141],[6451,9113],[6436,9067],[6512,9052],[6527,9059],[6469,9075],[6459,9094],[6487,9102],[6506,9090],[6515,9116],[6553,9161],[6560,9121],[6630,9083],[6675,9084],[6646,9060],[6663,9044],[6673,9007],[6690,9016],[6671,9058],[6685,9079],[6643,9115],[6599,9130],[6588,9167],[6594,9189],[6788,9206],[6780,9224],[6737,9257],[6785,9249],[6777,9269],[6809,9274],[6873,9307],[6980,9323],[6962,9336],[7011,9336],[7047,9351],[7033,9373],[7059,9393],[7066,9353],[7049,9341],[7067,9325],[7108,9332],[7138,9364],[7197,9366],[7207,9400],[7268,9436],[7313,9439],[7346,9430],[7326,9407],[7393,9388],[7362,9364],[7404,9365],[7407,9378],[7502,9378],[7543,9370],[7546,9346],[7568,9345],[7578,9308],[7544,9323],[7575,9289],[7467,9233],[7411,9192],[7384,9191],[7360,9167],[7401,9165],[7495,9195],[7457,9196],[7469,9214],[7539,9196],[7561,9206],[7571,9185],[7629,9196],[7719,9189],[7716,9172],[7772,9155],[7853,9150],[7870,9168],[7862,9188],[7901,9208],[7905,9196],[7955,9179],[7974,9187],[8045,9157],[8030,9104],[7998,9123],[8055,9053],[8088,9032],[8108,9038],[8137,9093],[8170,9068],[8195,9065],[8239,9079],[8270,9074],[8322,9080],[8360,9070],[8335,9109],[8345,9127],[8405,9143],[8519,9131],[8564,9117],[8534,9111],[8541,9090],[8572,9118],[8644,9108],[8657,9095],[8626,9083],[8700,9063],[8721,9038],[8764,9037],[8832,9050],[8908,9043],[8943,9027],[8955,9004],[8943,8985],[8984,8961],[9072,8979],[9096,8968],[9158,8964],[9197,8992],[9232,8984],[9225,8968],[9192,8975],[9201,8950],[9238,8927],[9278,8941],[9267,8997],[9413,8983],[9467,8971],[9580,8925],[9584,8914],[9685,8870],[9711,8813],[9723,8834],[9791,8834],[9851,8793],[9826,8768],[9778,8763],[9764,8722],[9776,8709],[9742,8703],[9702,8728],[9668,8738],[9667,8757],[9635,8767],[9589,8762],[9555,8796],[9567,8768],[9556,8744],[9493,8721],[9439,8731],[9486,8700],[9495,8707],[9534,8629],[9519,8610],[9488,8621],[9448,8619],[9352,8576],[9308,8545],[9266,8526],[9261,8505],[9227,8532],[9158,8520],[9133,8499],[9142,8528],[9095,8497],[9060,8508],[9046,8484],[9064,8458],[9090,8456],[9056,8438],[9043,8461],[9011,8423],[9051,8406],[9035,8366],[9052,8342],[9016,8339],[9005,8318],[9016,8287],[8954,8259],[8941,8221],[8912,8207],[8886,8153],[8827,8100],[8811,8101],[8856,8131],[8837,8208],[8820,8304],[8835,8366],[8877,8410],[8923,8437],[8948,8468],[9008,8515],[9010,8525],[9072,8567],[9075,8609],[9107,8615],[9089,8628],[9049,8621],[9040,8587],[8957,8532],[8946,8548],[8962,8594],[8877,8587],[8802,8523],[8776,8485],[8810,8470],[8755,8473],[8696,8456],[8678,8483],[8643,8496],[8619,8473],[8474,8481],[8435,8472],[8385,8435],[8373,8412],[8319,8375],[8287,8339],[8217,8288],[8256,8276],[8261,8291],[8303,8293],[8279,8254],[8297,8235],[8321,8264],[8353,8263],[8401,8217],[8372,8113],[8375,8076],[8364,8034],[8337,8008],[8302,7950],[8237,7883],[8214,7850],[8156,7821],[8116,7844],[8083,7807],[8081,7811],[8078,7815],[8091,7827],[8099,7870],[8090,7899],[8121,7913],[8132,7887],[8146,7907],[8178,7951],[8185,7988],[8204,8005],[8192,8031],[8135,8005],[8093,8004],[8086,8027],[8043,8071],[8005,8075],[7935,8210],[7862,8234],[7790,8222],[7766,8201],[7788,8176],[7768,8158],[7740,8107],[7742,8093],[7699,8074],[7667,8086],[7628,8089],[7596,8104],[7559,8077],[7490,8060],[7425,8067],[7407,8090],[7330,8111],[7280,8098],[7239,8117],[7237,8144],[7139,8176],[7106,8132],[7121,8113],[7093,8083],[7011,8094],[7001,8115],[6945,8127],[6810,8061],[6801,8059],[6795,8058],[6774,8077],[6734,8077],[6680,8131],[6621,8121],[6598,8144],[6577,8124],[6515,8222],[6475,8250],[6479,8269],[6407,8235],[6385,8249],[6316,8256],[6306,8305],[6230,8300],[6227,8291],[6139,8266],[6014,8247],[6020,8222],[6045,8216],[6005,8198],[6015,8184],[5989,8167],[6028,8148],[6025,8123],[5983,8125],[5978,8114],[5943,8133],[5881,8134],[5856,8113],[5821,8126],[5787,8152],[5705,8157],[5648,8115],[5641,8085],[5615,8110],[5596,8086],[5600,8062],[5583,8032],[5602,8009],[5630,8008],[5665,7954],[5617,7931],[5591,7892],[5617,7860],[5612,7833],[5646,7791],[5621,7768],[5582,7793],[5534,7823],[5508,7816],[5475,7838],[5391,7846]]],[[[9599,9071],[9621,9058],[9607,9047],[9546,9044],[9510,9034],[9513,9057],[9553,9077],[9599,9071]]],[[[8377,9210],[8419,9208],[8460,9187],[8453,9166],[8373,9183],[8377,9210]]],[[[6937,9577],[6908,9593],[6985,9585],[6953,9568],[6937,9577]]],[[[5596,9641],[5637,9647],[5572,9620],[5542,9634],[5596,9641]]],[[[5995,9655],[6034,9667],[6052,9644],[6016,9618],[5975,9619],[5961,9635],[5995,9655]]],[[[4790,8269],[4810,8280],[4786,8270],[4786,8270],[4795,8288],[4825,8304],[4827,8304],[4814,8290],[4835,8303],[4881,8288],[4880,8266],[4878,8266],[4790,8269]]],[[[7022,9596],[7001,9593],[6984,9590],[6920,9610],[6957,9625],[6965,9659],[7046,9679],[7111,9638],[7088,9634],[7088,9606],[7033,9597],[7100,9602],[7123,9582],[7148,9593],[7170,9569],[7154,9511],[7105,9510],[7077,9522],[7024,9525],[6986,9559],[7022,9596]]],[[[8455,8069],[8434,8017],[8459,7961],[8432,7965],[8421,7938],[8413,7964],[8424,8015],[8417,8049],[8426,8138],[8409,8161],[8411,8226],[8442,8239],[8434,8264],[8456,8217],[8461,8152],[8486,8064],[8455,8069]]],[[[5879,9169],[5847,9116],[5869,9059],[5914,9030],[5900,9017],[5849,9031],[5841,9020],[5786,9037],[5794,9055],[5774,9065],[5778,9046],[5733,9076],[5731,9096],[5759,9104],[5780,9161],[5834,9180],[5879,9169]]],[[[8571,9292],[8608,9297],[8629,9288],[8681,9280],[8673,9266],[8601,9260],[8539,9286],[8548,9307],[8571,9292]]],[[[8399,9343],[8434,9324],[8476,9322],[8518,9303],[8477,9274],[8433,9294],[8437,9278],[8468,9268],[8429,9262],[8413,9272],[8329,9252],[8296,9263],[8266,9294],[8241,9299],[8224,9294],[8230,9324],[8269,9309],[8282,9329],[8326,9346],[8388,9309],[8399,9343]]],[[[6210,9395],[6246,9386],[6250,9367],[6197,9339],[6025,9292],[5959,9239],[5931,9247],[5933,9224],[5888,9170],[5837,9181],[5814,9174],[5796,9199],[5830,9212],[5852,9252],[5897,9296],[5931,9307],[5947,9326],[6017,9337],[6017,9349],[6055,9344],[6104,9352],[6210,9395]]],[[[7197,9509],[7203,9532],[7240,9552],[7265,9544],[7257,9526],[7285,9533],[7322,9512],[7352,9475],[7326,9488],[7282,9474],[7207,9470],[7173,9455],[7150,9460],[7197,9509]]],[[[5588,9611],[5677,9634],[5658,9643],[5699,9660],[5738,9636],[5680,9624],[5695,9590],[5674,9601],[5588,9611]]]]}},{\"type\":\"Feature\",\"id\":\"VA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.61,\"hc-middle-y\":0.44,\"hc-key\":\"va\",\"hc-a2\":\"VA\",\"name\":\"Vatican\",\"labelrank\":\"6\",\"country-abbrev\":\"Vat.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"VAT\",\"iso-a2\":\"VA\",\"woe-id\":\"23424986\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4574,7793],[4574,7793],[4574,7793],[4574,7793],[4574,7793]]]}},{\"type\":\"Feature\",\"id\":\"SM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.42,\"hc-key\":\"sm\",\"hc-a2\":\"SM\",\"name\":\"San Marino\",\"labelrank\":\"6\",\"country-abbrev\":\"S.M.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"SMR\",\"iso-a2\":\"SM\",\"woe-id\":\"23424947\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4574,7865],[4572,7866],[4573,7867],[4574,7868],[4574,7865]]]}},{\"type\":\"Feature\",\"id\":\"KZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.57,\"hc-middle-y\":0.46,\"hc-key\":\"kz\",\"hc-a2\":\"KZ\",\"name\":\"Kazakhstan\",\"labelrank\":\"3\",\"country-abbrev\":\"Kaz.\",\"subregion\":\"Central Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"KAZ\",\"iso-a2\":\"KZ\",\"woe-id\":\"-90\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5991,7941],[5960,7930],[5968,7910],[5947,7922],[5952,7928],[5943,7925],[5865,7905],[5865,7773],[5851,7770],[5812,7808],[5792,7800],[5792,7800],[5792,7800],[5792,7800],[5780,7795],[5780,7795],[5780,7795],[5780,7795],[5760,7788],[5768,7823],[5745,7826],[5697,7892],[5729,7917],[5763,7920],[5779,7942],[5779,7975],[5750,7972],[5724,7983],[5665,7954],[5630,8008],[5602,8009],[5583,8032],[5600,8062],[5596,8086],[5615,8110],[5641,8085],[5648,8115],[5705,8157],[5787,8152],[5821,8126],[5856,8113],[5881,8134],[5943,8133],[5978,8114],[5983,8125],[6025,8123],[6028,8148],[5989,8167],[6015,8184],[6005,8198],[6045,8216],[6020,8222],[6014,8247],[6139,8266],[6227,8291],[6230,8300],[6306,8305],[6316,8256],[6385,8249],[6407,8235],[6479,8269],[6475,8250],[6515,8222],[6577,8124],[6598,8144],[6621,8121],[6680,8131],[6734,8077],[6774,8077],[6795,8058],[6750,8032],[6741,7981],[6719,7972],[6668,7986],[6646,7924],[6581,7906],[6602,7838],[6584,7803],[6531,7828],[6435,7827],[6405,7842],[6385,7812],[6336,7826],[6309,7805],[6253,7774],[6240,7747],[6220,7768],[6183,7768],[6178,7796],[6163,7797],[6157,7828],[6131,7858],[6045,7850],[6015,7882],[5986,7899],[5977,7930],[5996,7939],[5991,7941]],[[5995,7942],[5997,7942],[5997,7940],[6021,7950],[5995,7942]]],[[[5693,7900],[5687,7903],[5689,7907],[5698,7908],[5693,7900]]]]}},{\"type\":\"Feature\",\"id\":\"AZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.83,\"hc-middle-y\":0.51,\"hc-key\":\"az\",\"hc-a2\":\"AZ\",\"name\":\"Azerbaijan\",\"labelrank\":\"5\",\"country-abbrev\":\"Aze.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"AZE\",\"iso-a2\":\"AZ\",\"woe-id\":\"23424741\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5540,7763],[5539,7762],[5538,7764],[5540,7764],[5540,7763]]],[[[5546,7760],[5545,7760],[5545,7761],[5545,7761],[5546,7760]]],[[[5554,7747],[5554,7749],[5556,7749],[5555,7747],[5554,7747]]],[[[5534,7714],[5533,7716],[5563,7710],[5573,7687],[5552,7692],[5534,7714]]],[[[5582,7793],[5621,7768],[5646,7791],[5676,7748],[5654,7672],[5629,7685],[5627,7716],[5584,7687],[5558,7727],[5568,7734],[5539,7771],[5584,7763],[5582,7793]]]]}},{\"type\":\"Feature\",\"id\":\"TJ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.28,\"hc-middle-y\":0.56,\"hc-key\":\"tj\",\"hc-a2\":\"TJ\",\"name\":\"Tajikistan\",\"labelrank\":\"4\",\"country-abbrev\":\"Tjk.\",\"subregion\":\"Central Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"TJK\",\"iso-a2\":\"TJ\",\"woe-id\":\"23424961\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[6300,7759],[6300,7759],[6298,7762],[6299,7761],[6300,7759]]],[[[6300,7721],[6302,7720],[6299,7718],[6296,7722],[6300,7721]]],[[[6389,7707],[6395,7677],[6423,7675],[6426,7631],[6379,7639],[6329,7613],[6329,7653],[6299,7669],[6285,7641],[6259,7626],[6215,7629],[6232,7665],[6225,7691],[6203,7699],[6235,7710],[6264,7754],[6295,7762],[6310,7734],[6280,7734],[6261,7709],[6325,7713],[6348,7698],[6389,7707]]]]}},{\"type\":\"Feature\",\"id\":\"LS\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.52,\"hc-middle-y\":0.45,\"hc-key\":\"ls\",\"hc-a2\":\"LS\",\"name\":\"Lesotho\",\"labelrank\":\"6\",\"country-abbrev\":\"Les.\",\"subregion\":\"Southern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"LSO\",\"iso-a2\":\"LS\",\"woe-id\":\"23424880\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5040,5608],[5054,5613],[5078,5588],[5037,5545],[5006,5579],[5040,5608]]]}},{\"type\":\"Feature\",\"id\":\"UZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.46,\"hc-middle-y\":0.53,\"hc-key\":\"uz\",\"hc-a2\":\"UZ\",\"name\":\"Uzbekistan\",\"labelrank\":\"3\",\"country-abbrev\":\"Uzb.\",\"subregion\":\"Central Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"UZB\",\"iso-a2\":\"UZ\",\"woe-id\":\"23424980\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[6333,7723],[6332,7723],[6331,7724],[6334,7726],[6333,7723]]],[[[6316,7728],[6317,7722],[6312,7722],[6310,7729],[6316,7728]]],[[[5968,7910],[5961,7895],[5982,7876],[5986,7899],[6015,7882],[6045,7850],[6131,7858],[6157,7828],[6163,7797],[6178,7796],[6183,7768],[6220,7768],[6240,7747],[6253,7774],[6309,7805],[6286,7782],[6323,7766],[6333,7777],[6374,7754],[6331,7731],[6310,7734],[6295,7762],[6264,7754],[6235,7710],[6203,7699],[6225,7691],[6232,7665],[6215,7629],[6200,7629],[6178,7635],[6179,7658],[6151,7665],[6057,7726],[6043,7761],[5987,7775],[5981,7807],[5943,7825],[5915,7802],[5908,7809],[5898,7794],[5896,7770],[5865,7773],[5865,7905],[5943,7925],[5934,7884],[5947,7922],[5968,7910]],[[6300,7759],[6299,7761],[6298,7762],[6300,7759],[6300,7759]]]]}},{\"type\":\"Feature\",\"id\":\"MA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.6,\"hc-middle-y\":0.21,\"hc-key\":\"ma\",\"hc-a2\":\"MA\",\"name\":\"Morocco\",\"labelrank\":\"3\",\"country-abbrev\":\"Mor.\",\"subregion\":\"Northern Africa\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"MAR\",\"iso-a2\":\"MA\",\"woe-id\":\"23424893\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4117,7564],[4118,7565],[4119,7560],[4138,7558],[4151,7547],[4154,7497],[4173,7473],[4167,7459],[4129,7460],[4095,7444],[4096,7414],[4033,7378],[3977,7371],[3946,7348],[3946,7316],[3943,7298],[3915,7290],[3866,7291],[3847,7264],[3835,7226],[3788,7182],[3782,7148],[3764,7121],[3699,7120],[3740,7201],[3762,7222],[3774,7267],[3800,7285],[3820,7324],[3863,7337],[3890,7358],[3919,7404],[3912,7436],[3929,7475],[3951,7498],[4002,7523],[4028,7582],[4044,7586],[4044,7585],[4045,7584],[4074,7560],[4116,7566],[4117,7566],[4117,7564]]]}},{\"type\":\"Feature\",\"id\":\"CO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.54,\"hc-key\":\"co\",\"hc-a2\":\"CO\",\"name\":\"Colombia\",\"labelrank\":\"2\",\"country-abbrev\":\"Col.\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"COL\",\"iso-a2\":\"CO\",\"woe-id\":\"23424787\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1865,6521],[1868,6543],[1894,6559],[1916,6592],[1909,6611],[1909,6673],[1892,6692],[1914,6713],[1908,6735],[1920,6731],[1960,6758],[1963,6791],[2005,6815],[2029,6813],[2082,6847],[2087,6830],[2068,6824],[2040,6787],[2037,6753],[2056,6726],[2064,6688],[2123,6685],[2143,6659],[2201,6662],[2190,6612],[2207,6580],[2191,6564],[2210,6549],[2219,6515],[2206,6540],[2181,6529],[2131,6529],[2125,6474],[2143,6437],[2128,6354],[2105,6367],[2125,6399],[2096,6414],[2056,6406],[2032,6413],[2019,6442],[1970,6476],[1940,6492],[1905,6498],[1865,6521]]]}},{\"type\":\"Feature\",\"id\":\"TL\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.65,\"hc-middle-y\":0.36,\"hc-key\":\"tl\",\"hc-a2\":\"TL\",\"name\":\"East Timor\",\"labelrank\":\"5\",\"country-abbrev\":\"T.L.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"TLS\",\"iso-a2\":\"TL\",\"woe-id\":\"23424968\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[7885,6203],[7890,6206],[7897,6207],[7891,6198],[7885,6203]]],[[[7911,6214],[7918,6224],[7972,6233],[7957,6214],[7915,6198],[7912,6206],[7911,6214]]]]}},{\"type\":\"Feature\",\"id\":\"TZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.5,\"hc-key\":\"tz\",\"hc-a2\":\"TZ\",\"name\":\"United Republic of Tanzania\",\"labelrank\":\"3\",\"country-abbrev\":\"Tanz.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"TZA\",\"iso-a2\":\"TZ\",\"woe-id\":\"23424973\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5242,6136],[5241,6138],[5240,6141],[5240,6141],[5236,6143],[5235,6145],[5235,6145],[5234,6146],[5227,6185],[5222,6192],[5219,6195],[5219,6195],[5216,6197],[5215,6197],[5215,6198],[5211,6196],[5210,6191],[5195,6195],[5181,6201],[5153,6211],[5129,6225],[5093,6304],[5084,6347],[5118,6383],[5111,6408],[5119,6432],[5108,6447],[5119,6449],[5147,6449],[5147,6448],[5148,6449],[5149,6449],[5151,6407],[5189,6405],[5215,6448],[5321,6389],[5325,6371],[5367,6341],[5387,6324],[5371,6310],[5378,6289],[5372,6221],[5404,6169],[5316,6132],[5242,6136]]]}},{\"type\":\"Feature\",\"id\":\"AR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.46,\"hc-middle-y\":0.27,\"hc-key\":\"ar\",\"hc-a2\":\"AR\",\"name\":\"Argentina\",\"labelrank\":\"2\",\"country-abbrev\":\"Arg.\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"ARG\",\"iso-a2\":\"AR\",\"woe-id\":\"23424747\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[2167,4673],[2169,4670],[2167,4670],[2167,4673]]],[[[2584,5708],[2604,5706],[2606,5658],[2549,5623],[2494,5561],[2477,5505],[2477,5487],[2466,5426],[2509,5387],[2501,5373],[2522,5338],[2495,5295],[2451,5277],[2398,5267],[2362,5269],[2354,5201],[2310,5191],[2278,5207],[2273,5163],[2287,5146],[2312,5158],[2316,5134],[2292,5143],[2292,5126],[2265,5101],[2257,5052],[2239,5053],[2206,5030],[2197,5010],[2222,4978],[2246,4976],[2246,4939],[2199,4902],[2189,4865],[2160,4852],[2151,4826],[2173,4772],[2128,4786],[2070,4787],[2054,4804],[2058,4839],[2032,4835],[2020,4882],[2059,4928],[2051,4944],[2070,4970],[2088,5042],[2066,5062],[2077,5092],[2063,5125],[2075,5158],[2069,5206],[2085,5269],[2101,5277],[2091,5311],[2096,5352],[2115,5366],[2115,5397],[2133,5456],[2109,5516],[2137,5618],[2162,5659],[2177,5666],[2169,5733],[2206,5757],[2210,5794],[2238,5826],[2287,5813],[2295,5792],[2307,5819],[2345,5812],[2394,5763],[2422,5757],[2496,5712],[2465,5653],[2549,5649],[2578,5674],[2584,5708]]],[[[2167,4674],[2167,4761],[2173,4734],[2207,4704],[2250,4679],[2287,4669],[2229,4663],[2209,4666],[2202,4668],[2167,4674]]]]}},{\"type\":\"Feature\",\"id\":\"SA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.53,\"hc-key\":\"sa\",\"hc-a2\":\"SA\",\"name\":\"Saudi Arabia\",\"labelrank\":\"2\",\"country-abbrev\":\"Saud.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"SAU\",\"iso-a2\":\"SA\",\"woe-id\":\"23424938\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5641,7344],[5655,7313],[5692,7284],[5692,7255],[5712,7224],[5717,7218],[5724,7220],[5726,7210],[5734,7208],[5764,7167],[5842,7160],[5855,7137],[5836,7076],[5747,7045],[5662,7034],[5633,7020],[5611,6987],[5544,6998],[5485,6995],[5474,6966],[5427,7036],[5419,7061],[5381,7090],[5364,7117],[5364,7155],[5345,7193],[5318,7209],[5309,7237],[5249,7328],[5230,7330],[5241,7370],[5274,7365],[5331,7407],[5301,7439],[5366,7460],[5404,7453],[5453,7426],[5530,7365],[5585,7362],[5612,7358],[5641,7344]]]}},{\"type\":\"Feature\",\"id\":\"PK\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.34,\"hc-middle-y\":0.64,\"hc-key\":\"pk\",\"hc-a2\":\"PK\",\"name\":\"Pakistan\",\"labelrank\":\"2\",\"country-abbrev\":\"Pak.\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"PAK\",\"iso-a2\":\"PK\",\"woe-id\":\"23424922\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6416,7624],[6459,7605],[6482,7577],[6490,7559],[6453,7539],[6410,7548],[6393,7534],[6400,7495],[6438,7461],[6415,7446],[6416,7427],[6381,7388],[6368,7360],[6337,7325],[6295,7328],[6265,7289],[6313,7222],[6280,7205],[6247,7208],[6227,7195],[6203,7202],[6173,7246],[6088,7238],[6032,7238],[6039,7270],[6076,7283],[6067,7334],[6041,7344],[6010,7386],[6058,7372],[6106,7371],[6168,7385],[6173,7421],[6226,7450],[6261,7454],[6268,7491],[6290,7499],[6281,7523],[6313,7524],[6330,7562],[6316,7590],[6357,7617],[6416,7624]]]}},{\"type\":\"Feature\",\"id\":\"YE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.39,\"hc-middle-y\":0.75,\"hc-key\":\"ye\",\"hc-a2\":\"YE\",\"name\":\"Yemen\",\"labelrank\":\"3\",\"country-abbrev\":\"Yem.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"YEM\",\"iso-a2\":\"YE\",\"woe-id\":\"23425002\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5747,7045],[5769,6994],[5780,6974],[5754,6943],[5675,6916],[5649,6895],[5629,6896],[5590,6877],[5564,6875],[5508,6852],[5494,6859],[5472,6941],[5474,6966],[5485,6995],[5544,6998],[5611,6987],[5633,7020],[5662,7034],[5747,7045]]]}},{\"type\":\"Feature\",\"id\":\"AE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.59,\"hc-middle-y\":0.65,\"hc-key\":\"ae\",\"hc-a2\":\"AE\",\"name\":\"United Arab Emirates\",\"labelrank\":\"4\",\"country-abbrev\":\"U.A.E.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"ARE\",\"iso-a2\":\"AE\",\"woe-id\":\"23424738\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5874,7251],[5877,7248],[5877,7231],[5860,7228],[5842,7160],[5764,7167],[5734,7208],[5810,7205],[5868,7265],[5870,7253],[5874,7251]],[[5874,7239],[5876,7241],[5873,7241],[5873,7238],[5874,7239]]]}},{\"type\":\"Feature\",\"id\":\"KE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.87,\"hc-middle-y\":0.7,\"hc-key\":\"ke\",\"hc-a2\":\"KE\",\"name\":\"Kenya\",\"labelrank\":\"2\",\"country-abbrev\":\"Ken.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"KEN\",\"iso-a2\":\"KE\",\"woe-id\":\"23424863\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5367,6341],[5325,6371],[5321,6389],[5215,6448],[5220,6471],[5213,6486],[5242,6527],[5240,6552],[5212,6603],[5255,6627],[5270,6615],[5297,6609],[5335,6585],[5377,6579],[5414,6605],[5447,6596],[5420,6562],[5420,6453],[5437,6429],[5396,6397],[5367,6341]]]}},{\"type\":\"Feature\",\"id\":\"PE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.69,\"hc-middle-y\":0.71,\"hc-key\":\"pe\",\"hc-a2\":\"PE\",\"name\":\"Peru\",\"labelrank\":\"2\",\"country-abbrev\":\"Peru\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"PER\",\"iso-a2\":\"PE\",\"woe-id\":\"23424919\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1970,6476],[2019,6442],[2032,6413],[2056,6406],[2096,6414],[2125,6399],[2105,6367],[2128,6354],[2103,6356],[2040,6327],[2034,6290],[2007,6256],[2061,6183],[2091,6185],[2111,6200],[2108,6153],[2139,6155],[2166,6108],[2153,6073],[2160,6058],[2145,6017],[2126,6008],[2153,5996],[2155,5997],[2157,5996],[2153,5988],[2155,5986],[2137,5964],[2141,5957],[2128,5935],[2115,5932],[2082,5964],[1973,6022],[1940,6061],[1942,6083],[1900,6144],[1860,6236],[1831,6278],[1797,6299],[1793,6354],[1820,6379],[1815,6358],[1858,6331],[1879,6379],[1928,6403],[1961,6433],[1970,6476]]]}},{\"type\":\"Feature\",\"id\":\"DO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.46,\"hc-middle-y\":0.38,\"hc-key\":\"do\",\"hc-a2\":\"DO\",\"name\":\"Dominican Republic\",\"labelrank\":\"5\",\"country-abbrev\":\"Dom. Rep.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"DOM\",\"iso-a2\":\"DO\",\"woe-id\":\"23424800\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2070,7030],[2070,7030],[2069,7031],[2069,7031],[2067,7033],[2076,7038],[2075,7067],[2097,7074],[2128,7066],[2138,7048],[2175,7035],[2159,7028],[2106,7028],[2085,7003],[2074,7016],[2076,7025],[2070,7030]]]}},{\"type\":\"Feature\",\"id\":\"HT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.82,\"hc-middle-y\":0.96,\"hc-key\":\"ht\",\"hc-a2\":\"HT\",\"name\":\"Haiti\",\"labelrank\":\"5\",\"country-abbrev\":\"Haiti\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"HTI\",\"iso-a2\":\"HT\",\"woe-id\":\"23424839\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[2070,7030],[2069,7031],[2069,7031],[2069,7031],[2070,7030]]],[[[2075,7067],[2076,7038],[2067,7033],[2068,7030],[2070,7030],[2076,7025],[2074,7016],[2028,7023],[2011,7016],[2000,7036],[2046,7028],[2046,7059],[2025,7070],[2075,7067]]]]}},{\"type\":\"Feature\",\"id\":\"PG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.14,\"hc-middle-y\":0.5,\"hc-key\":\"pg\",\"hc-a2\":\"PG\",\"name\":\"Papua New Guinea\",\"labelrank\":\"2\",\"country-abbrev\":\"P.N.G.\",\"subregion\":\"Melanesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"PNG\",\"iso-a2\":\"PG\",\"woe-id\":\"23424926\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[8388,6210],[8388,6275],[8388,6402],[8478,6367],[8493,6366],[8531,6335],[8530,6317],[8580,6303],[8592,6281],[8565,6279],[8572,6258],[8600,6241],[8632,6198],[8684,6195],[8676,6166],[8595,6178],[8568,6199],[8539,6240],[8470,6255],[8460,6214],[8437,6203],[8388,6210]]],[[[8654,6406],[8646,6432],[8662,6408],[8716,6383],[8749,6353],[8741,6336],[8723,6373],[8654,6406]]],[[[8645,6292],[8598,6309],[8685,6319],[8703,6332],[8701,6355],[8727,6351],[8719,6320],[8669,6294],[8645,6292]]]]}},{\"type\":\"Feature\",\"id\":\"AO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.67,\"hc-key\":\"ao\",\"hc-a2\":\"AO\",\"name\":\"Angola\",\"labelrank\":\"3\",\"country-abbrev\":\"Ang.\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"AGO\",\"iso-a2\":\"AO\",\"woe-id\":\"23424745\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4566,6309],[4567,6317],[4560,6331],[4583,6349],[4592,6342],[4573,6330],[4566,6309]]],[[[4898,5953],[4821,5941],[4761,5950],[4752,5961],[4618,5960],[4595,5974],[4553,5965],[4553,6009],[4575,6081],[4609,6116],[4613,6163],[4590,6210],[4601,6232],[4568,6298],[4595,6306],[4697,6304],[4708,6263],[4726,6239],[4778,6242],[4783,6272],[4850,6264],[4851,6201],[4862,6185],[4864,6146],[4915,6157],[4916,6093],[4856,6093],[4856,5998],[4898,5953]]]]}},{\"type\":\"Feature\",\"id\":\"KH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.84,\"hc-middle-y\":0.49,\"hc-key\":\"kh\",\"hc-a2\":\"KH\",\"name\":\"Cambodia\",\"labelrank\":\"3\",\"country-abbrev\":\"Camb.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"KHM\",\"iso-a2\":\"KH\",\"woe-id\":\"23424776\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7395,6915],[7395,6844],[7342,6805],[7304,6787],[7279,6789],[7258,6824],[7241,6881],[7280,6907],[7325,6904],[7374,6904],[7395,6915]]]}},{\"type\":\"Feature\",\"id\":\"VN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.59,\"hc-middle-y\":0.89,\"hc-key\":\"vn\",\"hc-a2\":\"VN\",\"name\":\"Vietnam\",\"labelrank\":\"2\",\"country-abbrev\":\"Viet.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"VNM\",\"iso-a2\":\"VN\",\"woe-id\":\"23424984\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7304,6787],[7342,6805],[7395,6844],[7395,6915],[7399,6932],[7365,6984],[7311,7039],[7286,7055],[7319,7079],[7292,7106],[7264,7103],[7260,7125],[7234,7150],[7245,7162],[7289,7154],[7329,7180],[7372,7161],[7366,7149],[7409,7122],[7377,7105],[7350,7076],[7338,7046],[7368,6999],[7432,6936],[7452,6861],[7439,6815],[7387,6786],[7371,6790],[7364,6761],[7313,6739],[7314,6781],[7304,6787]]]}},{\"type\":\"Feature\",\"id\":\"MZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.83,\"hc-middle-y\":0.28,\"hc-key\":\"mz\",\"hc-a2\":\"MZ\",\"name\":\"Mozambique\",\"labelrank\":\"3\",\"country-abbrev\":\"Moz.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"MOZ\",\"iso-a2\":\"MZ\",\"woe-id\":\"23424902\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5238,6078],[5234,6118],[5242,6136],[5316,6132],[5404,6169],[5416,6039],[5388,5991],[5305,5946],[5239,5885],[5233,5868],[5258,5816],[5246,5739],[5205,5723],[5169,5696],[5180,5668],[5164,5667],[5157,5668],[5155,5685],[5152,5696],[5153,5744],[5133,5807],[5166,5841],[5184,5880],[5176,5898],[5185,5932],[5182,5982],[5106,6014],[5101,6034],[5189,6063],[5202,6045],[5223,6052],[5220,6006],[5247,5987],[5266,6002],[5268,6044],[5238,6078]]]}},{\"type\":\"Feature\",\"id\":\"CR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.55,\"hc-middle-y\":0.31,\"hc-key\":\"cr\",\"hc-a2\":\"CR\",\"name\":\"Costa Rica\",\"labelrank\":\"5\",\"country-abbrev\":\"C.R.\",\"subregion\":\"Central America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"CRI\",\"iso-a2\":\"CR\",\"woe-id\":\"23424791\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[1722,6802],[1727,6789],[1754,6762],[1740,6726],[1740,6726],[1736,6734],[1656,6785],[1661,6807],[1701,6804],[1722,6802]]],[[[1744,6716],[1739,6725],[1740,6725],[1740,6725],[1744,6716]]]]}},{\"type\":\"Feature\",\"id\":\"BJ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.57,\"hc-middle-y\":0.49,\"hc-key\":\"bj\",\"hc-a2\":\"BJ\",\"name\":\"Benin\",\"labelrank\":\"5\",\"country-abbrev\":\"Benin\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"BEN\",\"iso-a2\":\"BJ\",\"woe-id\":\"23424764\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4311,6825],[4318,6792],[4286,6746],[4284,6667],[4260,6664],[4252,6662],[4252,6746],[4231,6804],[4247,6818],[4275,6831],[4288,6846],[4311,6825]]]}},{\"type\":\"Feature\",\"id\":\"NG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.36,\"hc-middle-y\":0.33,\"hc-key\":\"ng\",\"hc-a2\":\"NG\",\"name\":\"Nigeria\",\"labelrank\":\"2\",\"country-abbrev\":\"Nigeria\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"NGA\",\"iso-a2\":\"NG\",\"woe-id\":\"23424908\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4284,6667],[4286,6746],[4318,6792],[4311,6825],[4326,6878],[4368,6891],[4410,6864],[4436,6874],[4490,6859],[4504,6872],[4543,6875],[4574,6866],[4608,6885],[4621,6866],[4639,6839],[4567,6725],[4540,6669],[4518,6689],[4466,6651],[4459,6621],[4388,6605],[4370,6615],[4335,6666],[4284,6667]]]}},{\"type\":\"Feature\",\"id\":\"IR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.58,\"hc-middle-y\":0.51,\"hc-key\":\"ir\",\"hc-a2\":\"IR\",\"name\":\"Iran\",\"labelrank\":\"2\",\"country-abbrev\":\"Iran\",\"subregion\":\"Southern Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"IRN\",\"iso-a2\":\"IR\",\"woe-id\":\"23424851\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5532,7628],[5516,7656],[5510,7704],[5534,7714],[5552,7692],[5573,7687],[5580,7689],[5584,7687],[5627,7716],[5629,7685],[5654,7672],[5659,7648],[5694,7636],[5720,7614],[5744,7609],[5807,7617],[5804,7634],[5849,7660],[5902,7666],[5906,7656],[5949,7646],[5995,7610],[6020,7608],[6022,7576],[6001,7491],[6009,7439],[6035,7435],[6038,7418],[6010,7386],[6041,7344],[6067,7334],[6076,7283],[6039,7270],[6032,7238],[5982,7242],[5905,7256],[5896,7290],[5876,7301],[5830,7279],[5729,7324],[5690,7397],[5657,7404],[5644,7390],[5619,7423],[5623,7448],[5611,7469],[5577,7487],[5551,7521],[5579,7582],[5549,7589],[5532,7628]]]}},{\"type\":\"Feature\",\"id\":\"SV\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.55,\"hc-key\":\"sv\",\"hc-a2\":\"SV\",\"name\":\"El Salvador\",\"labelrank\":\"6\",\"country-abbrev\":\"El. S.\",\"subregion\":\"Central America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"SLV\",\"iso-a2\":\"SV\",\"woe-id\":\"23424807\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1598,6876],[1569,6871],[1530,6886],[1530,6889],[1552,6907],[1601,6889],[1598,6876]]]}},{\"type\":\"Feature\",\"id\":\"SL\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.48,\"hc-key\":\"sl\",\"hc-a2\":\"SL\",\"name\":\"Sierra Leone\",\"labelrank\":\"4\",\"country-abbrev\":\"S.L.\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"SLE\",\"iso-a2\":\"SL\",\"woe-id\":\"23424946\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3863,6683],[3820,6702],[3809,6746],[3833,6770],[3870,6774],[3899,6729],[3889,6708],[3863,6683]]]}},{\"type\":\"Feature\",\"id\":\"GW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.55,\"hc-middle-y\":0.49,\"hc-key\":\"gw\",\"hc-a2\":\"GW\",\"name\":\"Guinea Bissau\",\"labelrank\":\"6\",\"country-abbrev\":\"GnB.\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"GNB\",\"iso-a2\":\"GW\",\"woe-id\":\"23424929\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3758,6803],[3732,6811],[3708,6844],[3753,6854],[3797,6854],[3797,6825],[3767,6819],[3758,6803]]]}},{\"type\":\"Feature\",\"id\":\"HR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.35,\"hc-middle-y\":0.59,\"hc-key\":\"hr\",\"hc-a2\":\"HR\",\"name\":\"Croatia\",\"labelrank\":\"6\",\"country-abbrev\":\"Cro.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"HRV\",\"iso-a2\":\"HR\",\"woe-id\":\"23424843\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4753,7811],[4732,7826],[4728,7828],[4734,7826],[4751,7816],[4751,7814],[4753,7811]]],[[[4607,7923],[4659,7921],[4668,7949],[4694,7960],[4719,7940],[4765,7939],[4769,7910],[4768,7900],[4706,7915],[4672,7911],[4685,7876],[4726,7830],[4699,7837],[4645,7875],[4645,7908],[4619,7898],[4607,7923]]]]}},{\"type\":\"Feature\",\"id\":\"BZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.53,\"hc-middle-y\":0.5,\"hc-key\":\"bz\",\"hc-a2\":\"BZ\",\"name\":\"Belize\",\"labelrank\":\"6\",\"country-abbrev\":\"Belize\",\"subregion\":\"Central America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"BLZ\",\"iso-a2\":\"BZ\",\"woe-id\":\"23424760\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1558,7009],[1567,7012],[1583,7030],[1586,6984],[1565,6951],[1556,6951],[1558,7009]]]}},{\"type\":\"Feature\",\"id\":\"ZA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.36,\"hc-middle-y\":0.7,\"hc-key\":\"za\",\"hc-a2\":\"ZA\",\"name\":\"South Africa\",\"labelrank\":\"2\",\"country-abbrev\":\"S.Af.\",\"subregion\":\"Southern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"ZAF\",\"iso-a2\":\"ZA\",\"woe-id\":\"23424942\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5157,5668],[5164,5667],[5180,5668],[5165,5613],[5129,5581],[5106,5539],[5061,5492],[5008,5451],[4942,5430],[4874,5436],[4854,5424],[4787,5410],[4753,5441],[4733,5474],[4746,5480],[4744,5511],[4717,5555],[4693,5613],[4711,5630],[4720,5608],[4771,5600],[4797,5617],[4797,5734],[4822,5690],[4818,5666],[4847,5667],[4878,5695],[4887,5716],[4941,5700],[4963,5706],[4972,5734],[5000,5749],[5006,5769],[5041,5799],[5075,5814],[5104,5809],[5133,5807],[5153,5744],[5152,5696],[5137,5702],[5118,5682],[5128,5656],[5157,5668]],[[5040,5608],[5006,5579],[5037,5545],[5078,5588],[5054,5613],[5040,5608]]]}},{\"type\":\"Feature\",\"id\":\"CF\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.47,\"hc-middle-y\":0.46,\"hc-key\":\"cf\",\"hc-a2\":\"CF\",\"name\":\"Central African Republic\",\"labelrank\":\"4\",\"country-abbrev\":\"C.A.R.\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"CAF\",\"iso-a2\":\"CF\",\"woe-id\":\"23424792\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4882,6802],[4906,6770],[4901,6738],[4921,6735],[4956,6696],[4987,6675],[4988,6658],[5018,6628],[4963,6637],[4872,6602],[4815,6609],[4789,6630],[4754,6606],[4757,6581],[4722,6588],[4696,6581],[4685,6545],[4682,6562],[4654,6590],[4631,6657],[4663,6701],[4702,6702],[4756,6716],[4771,6745],[4810,6749],[4870,6804],[4882,6802]]]}},{\"type\":\"Feature\",\"id\":\"SD\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.38,\"hc-key\":\"sd\",\"hc-a2\":\"SD\",\"name\":\"Sudan\",\"labelrank\":\"3\",\"country-abbrev\":\"Sudan\",\"subregion\":\"Northern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"SDN\",\"iso-a2\":\"SD\",\"woe-id\":\"-90\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4921,6735],[4901,6738],[4906,6770],[4882,6802],[4863,6856],[4859,6887],[4873,6898],[4889,6945],[4916,6946],[4916,7061],[4916,7076],[4945,7076],[4945,7138],[5131,7138],[5299,7138],[5310,7102],[5318,7037],[5350,7015],[5302,6987],[5285,6928],[5288,6902],[5276,6855],[5263,6854],[5238,6796],[5230,6801],[5215,6758],[5189,6800],[5190,6840],[5156,6834],[5166,6806],[5131,6768],[5095,6783],[5060,6754],[4992,6760],[4970,6787],[4948,6783],[4921,6735]]]}},{\"type\":\"Feature\",\"id\":\"CD\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.58,\"hc-middle-y\":0.42,\"hc-key\":\"cd\",\"hc-a2\":\"CD\",\"name\":\"Democratic Republic of the Congo\",\"labelrank\":\"2\",\"country-abbrev\":\"D.R.C.\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"COD\",\"iso-a2\":\"CD\",\"woe-id\":\"23424780\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5071,6380],[5067,6329],[5079,6281],[5111,6236],[5061,6228],[5045,6210],[5050,6201],[5056,6189],[5046,6140],[5066,6112],[5088,6119],[5088,6081],[5070,6080],[5011,6136],[4996,6123],[4956,6134],[4955,6147],[4925,6142],[4915,6157],[4864,6146],[4862,6185],[4851,6201],[4850,6264],[4783,6272],[4778,6242],[4726,6239],[4708,6263],[4697,6304],[4595,6306],[4573,6300],[4566,6309],[4573,6330],[4592,6342],[4631,6353],[4644,6337],[4685,6381],[4686,6416],[4731,6463],[4740,6542],[4757,6581],[4754,6606],[4789,6630],[4815,6609],[4872,6602],[4963,6637],[5018,6628],[5046,6605],[5088,6613],[5119,6582],[5115,6551],[5132,6543],[5109,6523],[5108,6515],[5093,6503],[5085,6476],[5074,6464],[5084,6465],[5081,6452],[5082,6438],[5075,6434],[5071,6429],[5063,6421],[5061,6406],[5061,6400],[5065,6398],[5072,6389],[5071,6380]]]}},{\"type\":\"Feature\",\"id\":\"KW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.61,\"hc-middle-y\":0.4,\"hc-key\":\"kw\",\"hc-a2\":\"KW\",\"name\":\"Kuwait\",\"labelrank\":\"6\",\"country-abbrev\":\"Kwt.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"KWT\",\"iso-a2\":\"KW\",\"woe-id\":\"23424870\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5641,7344],[5612,7358],[5585,7362],[5602,7390],[5627,7391],[5631,7370],[5641,7344]]]}},{\"type\":\"Feature\",\"id\":\"DE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.52,\"hc-middle-y\":0.34,\"hc-key\":\"de\",\"hc-a2\":\"DE\",\"name\":\"Germany\",\"labelrank\":\"2\",\"country-abbrev\":\"Ger.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"DEU\",\"iso-a2\":\"DE\",\"woe-id\":\"23424829\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4477,8004],[4477,8003],[4477,8003],[4477,8004]]],[[[4461,8288],[4466,8289],[4484,8285],[4544,8248],[4575,8271],[4609,8275],[4620,8254],[4626,8249],[4625,8248],[4625,8247],[4621,8251],[4627,8239],[4623,8205],[4639,8194],[4644,8126],[4575,8108],[4571,8083],[4614,8045],[4582,8021],[4591,7997],[4565,8005],[4530,7993],[4492,7999],[4473,8009],[4477,8004],[4455,8001],[4429,8001],[4447,8053],[4392,8072],[4397,8085],[4386,8097],[4393,8105],[4382,8122],[4393,8164],[4412,8180],[4417,8221],[4422,8240],[4458,8233],[4471,8247],[4461,8288]]]]}},{\"type\":\"Feature\",\"id\":\"BE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.54,\"hc-middle-y\":0.4,\"hc-key\":\"be\",\"hc-a2\":\"BE\",\"name\":\"Belgium\",\"labelrank\":\"2\",\"country-abbrev\":\"Belg.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"BEL\",\"iso-a2\":\"BE\",\"woe-id\":\"23424757\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4382,8122],[4393,8105],[4386,8097],[4374,8088],[4376,8075],[4327,8092],[4279,8135],[4297,8145],[4303,8146],[4317,8140],[4329,8146],[4331,8144],[4330,8146],[4353,8150],[4382,8122]]]}},{\"type\":\"Feature\",\"id\":\"IE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.48,\"hc-key\":\"ie\",\"hc-a2\":\"IE\",\"name\":\"Ireland\",\"labelrank\":\"3\",\"country-abbrev\":\"Ire.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"IRL\",\"iso-a2\":\"IE\",\"woe-id\":\"23424803\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3989,8295],[3961,8270],[3987,8256],[4018,8256],[4026,8209],[4015,8179],[3979,8174],[3946,8154],[3913,8149],[3895,8167],[3939,8222],[3907,8226],[3912,8265],[3948,8262],[3958,8299],[3989,8295]]]}},{\"type\":\"Feature\",\"id\":\"KP\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.32,\"hc-middle-y\":0.63,\"hc-key\":\"kp\",\"hc-a2\":\"KP\",\"name\":\"North Korea\",\"labelrank\":\"3\",\"country-abbrev\":\"N.K.\",\"subregion\":\"Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"PRK\",\"iso-a2\":\"KP\",\"woe-id\":\"23424865\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8083,7807],[8051,7781],[8053,7755],[7988,7717],[7986,7697],[8013,7678],[7978,7667],[7963,7651],[7931,7658],[7924,7646],[7907,7675],[7927,7702],[7895,7730],[7943,7758],[7962,7785],[8007,7774],[8004,7796],[8053,7812],[8057,7831],[8078,7815],[8081,7811],[8083,7807]]]}},{\"type\":\"Feature\",\"id\":\"KR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.54,\"hc-middle-y\":0.5,\"hc-key\":\"kr\",\"hc-a2\":\"KR\",\"name\":\"South Korea\",\"labelrank\":\"2\",\"country-abbrev\":\"S.K.\",\"subregion\":\"Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"KOR\",\"iso-a2\":\"KR\",\"woe-id\":\"23424868\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7963,7651],[7978,7667],[8013,7678],[8042,7632],[8046,7573],[8021,7546],[8004,7553],[7987,7536],[7955,7542],[7963,7651]]]}},{\"type\":\"Feature\",\"id\":\"GY\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.26,\"hc-middle-y\":0.07,\"hc-key\":\"gy\",\"hc-a2\":\"GY\",\"name\":\"Guyana\",\"labelrank\":\"4\",\"country-abbrev\":\"Guy.\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"GUY\",\"iso-a2\":\"GY\",\"woe-id\":\"23424836\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2423,6732],[2450,6715],[2507,6658],[2505,6641],[2481,6602],[2528,6536],[2509,6538],[2459,6514],[2431,6534],[2423,6558],[2437,6595],[2424,6629],[2401,6632],[2382,6653],[2387,6672],[2415,6689],[2408,6709],[2423,6732]]]}},{\"type\":\"Feature\",\"id\":\"HN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.71,\"hc-middle-y\":0.09,\"hc-key\":\"hn\",\"hc-a2\":\"HN\",\"name\":\"Honduras\",\"labelrank\":\"5\",\"country-abbrev\":\"Hond.\",\"subregion\":\"Central America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"HND\",\"iso-a2\":\"HN\",\"woe-id\":\"23424841\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1586,6946],[1654,6955],[1702,6949],[1737,6924],[1688,6919],[1660,6893],[1630,6887],[1613,6864],[1607,6873],[1598,6876],[1601,6889],[1552,6907],[1558,6926],[1586,6946]]]}},{\"type\":\"Feature\",\"id\":\"MM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.17,\"hc-middle-y\":0.49,\"hc-key\":\"mm\",\"hc-a2\":\"MM\",\"name\":\"Myanmar\",\"labelrank\":\"3\",\"country-abbrev\":\"Myan.\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"MMR\",\"iso-a2\":\"MM\",\"woe-id\":\"23424763\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6942,7109],[6953,7116],[6951,7137],[6969,7150],[6973,7200],[6996,7195],[7023,7255],[7024,7278],[7074,7306],[7092,7333],[7098,7343],[7132,7313],[7133,7260],[7103,7234],[7101,7195],[7130,7203],[7138,7175],[7157,7171],[7146,7143],[7170,7139],[7177,7120],[7206,7124],[7193,7117],[7175,7086],[7128,7066],[7113,7070],[7095,7030],[7137,6959],[7119,6918],[7146,6886],[7161,6829],[7134,6785],[7129,6870],[7106,6921],[7102,6963],[7088,6985],[7036,6946],[7000,6955],[7012,7001],[6993,7058],[6965,7077],[6942,7109]]]}},{\"type\":\"Feature\",\"id\":\"GA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.36,\"hc-middle-y\":0.65,\"hc-key\":\"ga\",\"hc-a2\":\"GA\",\"name\":\"Gabon\",\"labelrank\":\"4\",\"country-abbrev\":\"Gabon\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"GAB\",\"iso-a2\":\"GA\",\"woe-id\":\"23424822\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4495,6508],[4540,6508],[4540,6543],[4541,6547],[4599,6542],[4597,6515],[4633,6506],[4614,6473],[4634,6461],[4622,6405],[4573,6423],[4547,6410],[4555,6369],[4534,6363],[4479,6425],[4462,6461],[4479,6467],[4480,6495],[4495,6508]]]}},{\"type\":\"Feature\",\"id\":\"GQ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.53,\"hc-middle-y\":0.55,\"hc-key\":\"gq\",\"hc-a2\":\"GQ\",\"name\":\"Equatorial Guinea\",\"labelrank\":\"4\",\"country-abbrev\":\"Eq. G.\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"GNQ\",\"iso-a2\":\"GQ\",\"woe-id\":\"23424804\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4540,6543],[4540,6508],[4495,6508],[4481,6514],[4495,6548],[4500,6543],[4540,6543]]]}},{\"type\":\"Feature\",\"id\":\"NI\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.84,\"hc-middle-y\":0.5,\"hc-key\":\"ni\",\"hc-a2\":\"NI\",\"name\":\"Nicaragua\",\"labelrank\":\"5\",\"country-abbrev\":\"Nic.\",\"subregion\":\"Central America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"NIC\",\"iso-a2\":\"NI\",\"woe-id\":\"23424915\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1661,6807],[1603,6860],[1613,6864],[1630,6887],[1660,6893],[1688,6919],[1737,6924],[1715,6816],[1722,6802],[1701,6804],[1661,6807]]]}},{\"type\":\"Feature\",\"id\":\"LV\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.05,\"hc-middle-y\":0.36,\"hc-key\":\"lv\",\"hc-a2\":\"LV\",\"name\":\"Latvia\",\"labelrank\":\"5\",\"country-abbrev\":\"Lat.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"LVA\",\"iso-a2\":\"LV\",\"woe-id\":\"23424874\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5016,8399],[5024,8370],[5039,8340],[5023,8325],[4993,8320],[4942,8353],[4929,8345],[4860,8352],[4829,8337],[4829,8370],[4849,8401],[4875,8408],[4907,8375],[4927,8386],[4925,8413],[4954,8422],[4990,8398],[5016,8399]]]}},{\"type\":\"Feature\",\"id\":\"UG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.16,\"hc-middle-y\":0.56,\"hc-key\":\"ug\",\"hc-a2\":\"UG\",\"name\":\"Uganda\",\"labelrank\":\"3\",\"country-abbrev\":\"Uga.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"UGA\",\"iso-a2\":\"UG\",\"woe-id\":\"23424974\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5148,6449],[5148,6450],[5149,6449],[5148,6449]]],[[[5082,6438],[5081,6452],[5084,6465],[5091,6474],[5085,6476],[5093,6503],[5108,6515],[5136,6535],[5132,6543],[5115,6551],[5119,6582],[5198,6589],[5212,6603],[5240,6552],[5242,6527],[5213,6486],[5171,6483],[5147,6449],[5119,6449],[5108,6447],[5092,6435],[5082,6438]]]]}},{\"type\":\"Feature\",\"id\":\"MW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.16,\"hc-middle-y\":0.29,\"hc-key\":\"mw\",\"hc-a2\":\"MW\",\"name\":\"Malawi\",\"labelrank\":\"6\",\"country-abbrev\":\"Mal.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"MWI\",\"iso-a2\":\"MW\",\"woe-id\":\"23424889\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5240,6141],[5240,6141],[5240,6141],[5240,6141]]],[[[5235,6145],[5235,6146],[5234,6146],[5235,6145],[5235,6145]]],[[[5222,6192],[5219,6195],[5219,6195],[5222,6192]]],[[[5216,6197],[5215,6198],[5215,6197],[5216,6197]]],[[[5181,6201],[5195,6195],[5210,6191],[5223,6133],[5222,6082],[5238,6078],[5268,6044],[5266,6002],[5247,5987],[5220,6006],[5223,6052],[5202,6045],[5189,6063],[5178,6072],[5194,6107],[5190,6157],[5203,6166],[5181,6201]]]]}},{\"type\":\"Feature\",\"id\":\"AM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.1,\"hc-middle-y\":0.12,\"hc-key\":\"am\",\"hc-a2\":\"AM\",\"name\":\"Armenia\",\"labelrank\":\"6\",\"country-abbrev\":\"Arm.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"ARM\",\"iso-a2\":\"AM\",\"woe-id\":\"23424743\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5584,7687],[5580,7689],[5573,7687],[5563,7710],[5533,7716],[5500,7730],[5493,7765],[5515,7769],[5539,7771],[5568,7734],[5558,7727],[5584,7687]],[[5540,7763],[5540,7764],[5538,7764],[5539,7762],[5540,7763]],[[5546,7760],[5545,7761],[5545,7761],[5545,7760],[5546,7760]],[[5554,7747],[5555,7747],[5556,7749],[5554,7749],[5554,7747]]]}},{\"type\":\"Feature\",\"id\":\"SX\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.76,\"hc-middle-y\":0.53,\"hc-key\":\"sx\",\"hc-a2\":\"SX\",\"name\":\"Somaliland\",\"labelrank\":\"5\",\"country-abbrev\":\"Solnd.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"-99\",\"iso-a2\":\"SX\",\"woe-id\":\"-99\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5487,6819],[5518,6788],[5562,6801],[5582,6795],[5611,6810],[5656,6812],[5656,6758],[5628,6715],[5598,6715],[5510,6744],[5470,6793],[5478,6804],[5487,6819]]]}},{\"type\":\"Feature\",\"id\":\"TM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.4,\"hc-middle-y\":0.42,\"hc-key\":\"tm\",\"hc-a2\":\"TM\",\"name\":\"Turkmenistan\",\"labelrank\":\"4\",\"country-abbrev\":\"Turkm.\",\"subregion\":\"Central Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"TKM\",\"iso-a2\":\"TM\",\"woe-id\":\"23424972\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5898,7794],[5921,7785],[5915,7802],[5943,7825],[5981,7807],[5987,7775],[6043,7761],[6057,7726],[6151,7665],[6179,7658],[6178,7635],[6156,7642],[6126,7626],[6117,7598],[6052,7560],[6022,7576],[6020,7608],[5995,7610],[5949,7646],[5906,7656],[5902,7666],[5849,7660],[5804,7634],[5806,7688],[5794,7724],[5769,7728],[5775,7760],[5798,7748],[5828,7765],[5803,7799],[5792,7800],[5792,7800],[5812,7808],[5851,7770],[5865,7773],[5896,7770],[5898,7794]]],[[[5780,7795],[5782,7800],[5792,7800],[5792,7800],[5780,7795],[5780,7795],[5780,7795]]],[[[5780,7795],[5771,7775],[5760,7788],[5780,7795],[5780,7795],[5780,7795]]]]}},{\"type\":\"Feature\",\"id\":\"ZM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.36,\"hc-middle-y\":0.58,\"hc-key\":\"zm\",\"hc-a2\":\"ZM\",\"name\":\"Zambia\",\"labelrank\":\"3\",\"country-abbrev\":\"Zambia\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"ZMB\",\"iso-a2\":\"ZM\",\"woe-id\":\"23425003\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5050,6201],[5069,6222],[5061,6228],[5111,6236],[5125,6219],[5129,6225],[5153,6211],[5181,6201],[5203,6166],[5190,6157],[5194,6107],[5178,6072],[5189,6063],[5101,6034],[5106,6014],[5060,6001],[5058,5987],[5038,5977],[5022,5969],[5006,5944],[4996,5940],[4954,5949],[4923,5958],[4898,5953],[4856,5998],[4856,6093],[4916,6093],[4915,6157],[4925,6142],[4955,6147],[4956,6134],[4996,6123],[5011,6136],[5070,6080],[5088,6081],[5088,6119],[5066,6112],[5046,6140],[5056,6189],[5050,6201]]]}},{\"type\":\"Feature\",\"id\":\"NC\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.56,\"hc-middle-y\":0.71,\"hc-key\":\"nc\",\"hc-a2\":\"NC\",\"name\":\"Northern Cyprus\",\"labelrank\":\"6\",\"country-abbrev\":\"N. Cy.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"-99\",\"iso-a2\":\"NC\",\"woe-id\":\"-90\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5210,7558],[5206,7556],[5203,7556],[5196,7562],[5175,7561],[5175,7561],[5175,7561],[5175,7561],[5175,7561],[5175,7561],[5231,7579],[5213,7557],[5210,7558]]],[[[5171,7561],[5173,7562],[5172,7561],[5171,7561]]]]}},{\"type\":\"Feature\",\"id\":\"MR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.61,\"hc-middle-y\":0.63,\"hc-key\":\"mr\",\"hc-a2\":\"MR\",\"name\":\"Mauritania\",\"labelrank\":\"3\",\"country-abbrev\":\"Mrt.\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"MRT\",\"iso-a2\":\"MR\",\"woe-id\":\"23424896\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3946,7304],[4040,7245],[4061,7231],[4008,7231],[4040,6939],[3886,6937],[3856,6941],[3840,6917],[3779,6974],[3719,6968],[3713,6949],[3728,7014],[3714,7058],[3723,7083],[3698,7100],[3701,7117],[3818,7117],[3818,7170],[3847,7183],[3847,7263],[3946,7263],[3946,7304]]]}},{\"type\":\"Feature\",\"id\":\"DZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.63,\"hc-middle-y\":0.5,\"hc-key\":\"dz\",\"hc-a2\":\"DZ\",\"name\":\"Algeria\",\"labelrank\":\"3\",\"country-abbrev\":\"Alg.\",\"subregion\":\"Northern Africa\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"DZA\",\"iso-a2\":\"DZ\",\"woe-id\":\"23424740\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4061,7231],[4040,7245],[3946,7304],[3946,7316],[3946,7348],[3977,7371],[4033,7378],[4096,7414],[4095,7444],[4129,7460],[4167,7459],[4173,7473],[4154,7497],[4151,7547],[4138,7558],[4235,7605],[4291,7616],[4346,7619],[4359,7611],[4423,7626],[4459,7621],[4452,7604],[4448,7543],[4426,7518],[4451,7473],[4472,7458],[4486,7398],[4496,7363],[4496,7279],[4483,7267],[4502,7227],[4546,7209],[4559,7185],[4426,7103],[4376,7059],[4329,7050],[4296,7050],[4299,7070],[4260,7083],[4238,7110],[4061,7231]]]}},{\"type\":\"Feature\",\"id\":\"LT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.27,\"hc-middle-y\":0.06,\"hc-key\":\"lt\",\"hc-a2\":\"LT\",\"name\":\"Lithuania\",\"labelrank\":\"5\",\"country-abbrev\":\"Lith.\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"LTU\",\"iso-a2\":\"LT\",\"woe-id\":\"23424875\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4835,8303],[4832,8321],[4829,8337],[4860,8352],[4929,8345],[4942,8353],[4993,8320],[4998,8305],[4972,8290],[4960,8264],[4927,8247],[4901,8249],[4900,8258],[4880,8266],[4881,8288],[4835,8303]]],[[[4825,8304],[4830,8313],[4827,8304],[4825,8304]]]]}},{\"type\":\"Feature\",\"id\":\"ET\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.58,\"hc-key\":\"et\",\"hc-a2\":\"ET\",\"name\":\"Ethiopia\",\"labelrank\":\"2\",\"country-abbrev\":\"Eth.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"ETH\",\"iso-a2\":\"ET\",\"woe-id\":\"23424808\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5444,6813],[5441,6810],[5444,6807],[5449,6802],[5478,6804],[5470,6793],[5510,6744],[5598,6715],[5628,6715],[5538,6624],[5509,6625],[5447,6596],[5414,6605],[5377,6579],[5335,6585],[5297,6609],[5270,6615],[5235,6675],[5205,6705],[5185,6709],[5190,6729],[5211,6728],[5215,6758],[5230,6801],[5238,6796],[5263,6854],[5276,6855],[5288,6902],[5328,6921],[5416,6897],[5462,6848],[5443,6820],[5444,6813]]]}},{\"type\":\"Feature\",\"id\":\"ER\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.29,\"hc-middle-y\":0.05,\"hc-key\":\"er\",\"hc-a2\":\"ER\",\"name\":\"Eritrea\",\"labelrank\":\"4\",\"country-abbrev\":\"Erit.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"ERI\",\"iso-a2\":\"ER\",\"woe-id\":\"23424806\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5462,6848],[5416,6897],[5328,6921],[5288,6902],[5285,6928],[5302,6987],[5350,7015],[5382,6928],[5426,6913],[5484,6855],[5471,6845],[5462,6848]]]}},{\"type\":\"Feature\",\"id\":\"GH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.13,\"hc-middle-y\":0.77,\"hc-key\":\"gh\",\"hc-a2\":\"GH\",\"name\":\"Ghana\",\"labelrank\":\"3\",\"country-abbrev\":\"Ghana\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"GHA\",\"iso-a2\":\"GH\",\"woe-id\":\"23424824\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4239,6659],[4142,6618],[4111,6629],[4112,6629],[4116,6629],[4120,6631],[4108,6681],[4130,6721],[4124,6759],[4122,6804],[4199,6808],[4215,6781],[4219,6681],[4239,6659]]]}},{\"type\":\"Feature\",\"id\":\"SI\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.52,\"hc-middle-y\":0.57,\"hc-key\":\"si\",\"hc-a2\":\"SI\",\"name\":\"Slovenia\",\"labelrank\":\"6\",\"country-abbrev\":\"Slo.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"SVN\",\"iso-a2\":\"SI\",\"woe-id\":\"23424945\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4607,7923],[4607,7925],[4611,7927],[4601,7952],[4611,7961],[4635,7956],[4682,7974],[4687,7974],[4694,7960],[4668,7949],[4659,7921],[4607,7923]]]}},{\"type\":\"Feature\",\"id\":\"GT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.44,\"hc-middle-y\":0.87,\"hc-key\":\"gt\",\"hc-a2\":\"GT\",\"name\":\"Guatemala\",\"labelrank\":\"3\",\"country-abbrev\":\"Guat.\",\"subregion\":\"Central America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"GTM\",\"iso-a2\":\"GT\",\"woe-id\":\"23424834\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1565,6951],[1574,6947],[1586,6946],[1558,6926],[1552,6907],[1530,6889],[1530,6886],[1494,6893],[1466,6911],[1482,6956],[1522,6966],[1491,6992],[1504,7009],[1558,7009],[1556,6951],[1565,6951]]]}},{\"type\":\"Feature\",\"id\":\"BA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.48,\"hc-key\":\"ba\",\"hc-a2\":\"BA\",\"name\":\"Bosnia and Herzegovina\",\"labelrank\":\"5\",\"country-abbrev\":\"B.H.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"BIH\",\"iso-a2\":\"BA\",\"woe-id\":\"23424761\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4728,7828],[4725,7830],[4726,7830],[4685,7876],[4672,7911],[4706,7915],[4768,7900],[4779,7901],[4774,7851],[4752,7832],[4751,7816],[4734,7826],[4728,7828]]]}},{\"type\":\"Feature\",\"id\":\"JO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.85,\"hc-key\":\"jo\",\"hc-a2\":\"JO\",\"name\":\"Jordan\",\"labelrank\":\"4\",\"country-abbrev\":\"Jord.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"JOR\",\"iso-a2\":\"JO\",\"woe-id\":\"23424860\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5255,7426],[5258,7429],[5255,7431],[5254,7432],[5255,7434],[5259,7434],[5259,7448],[5259,7477],[5265,7480],[5296,7466],[5355,7501],[5363,7472],[5366,7460],[5301,7439],[5331,7407],[5274,7365],[5241,7370],[5243,7376],[5241,7377],[5247,7405],[5255,7426]]]}},{\"type\":\"Feature\",\"id\":\"SY\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.25,\"hc-middle-y\":0.54,\"hc-key\":\"sy\",\"hc-a2\":\"SY\",\"name\":\"Syria\",\"labelrank\":\"3\",\"country-abbrev\":\"Syria\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"SYR\",\"iso-a2\":\"SY\",\"woe-id\":\"23424956\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5355,7501],[5296,7466],[5265,7480],[5269,7487],[5267,7502],[5290,7529],[5271,7544],[5270,7569],[5270,7586],[5291,7617],[5338,7620],[5384,7614],[5457,7634],[5461,7627],[5432,7606],[5427,7548],[5412,7533],[5355,7501]]]}},{\"type\":\"Feature\",\"id\":\"MC\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.67,\"hc-key\":\"mc\",\"hc-a2\":\"MC\",\"name\":\"Monaco\",\"labelrank\":\"6\",\"country-abbrev\":\"Mco.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"MCO\",\"iso-a2\":\"MC\",\"woe-id\":\"23424892\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4425,7859],[4424,7858],[4423,7858],[4424,7860],[4425,7859]]]}},{\"type\":\"Feature\",\"id\":\"AL\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.39,\"hc-middle-y\":0.49,\"hc-key\":\"al\",\"hc-a2\":\"AL\",\"name\":\"Albania\",\"labelrank\":\"6\",\"country-abbrev\":\"Alb.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"ALB\",\"iso-a2\":\"AL\",\"woe-id\":\"23424742\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4826,7757],[4826,7757],[4825,7758],[4826,7757]]],[[[4779,7800],[4779,7805],[4780,7808],[4789,7820],[4799,7816],[4812,7804],[4814,7792],[4811,7781],[4816,7764],[4817,7758],[4819,7758],[4822,7758],[4825,7758],[4825,7757],[4826,7756],[4826,7756],[4824,7753],[4826,7754],[4826,7753],[4828,7750],[4827,7750],[4828,7750],[4809,7720],[4798,7715],[4777,7749],[4779,7791],[4778,7795],[4779,7800]]],[[[4779,7807],[4779,7807],[4779,7806],[4779,7807]]]]}},{\"type\":\"Feature\",\"id\":\"UY\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.81,\"hc-middle-y\":0.63,\"hc-key\":\"uy\",\"hc-a2\":\"UY\",\"name\":\"Uruguay\",\"labelrank\":\"4\",\"country-abbrev\":\"Ury.\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"URY\",\"iso-a2\":\"UY\",\"woe-id\":\"23424979\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2626,5480],[2612,5465],[2615,5450],[2615,5447],[2620,5444],[2608,5422],[2573,5404],[2537,5404],[2487,5420],[2471,5437],[2477,5487],[2477,5505],[2494,5561],[2517,5563],[2542,5531],[2554,5539],[2626,5480]]]}},{\"type\":\"Feature\",\"id\":\"CNM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.39,\"hc-middle-y\":0.11,\"hc-key\":\"cnm\",\"hc-a2\":\"CN\",\"name\":\"Cyprus No Mans Area\",\"labelrank\":\"9\",\"country-abbrev\":null,\"subregion\":\"Western Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"-99\",\"iso-a2\":null,\"woe-id\":\"-99\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[5213,7557],[5214,7557],[5213,7557],[5210,7557],[5210,7558],[5213,7557]]],[[[5171,7561],[5171,7561],[5172,7561],[5173,7562],[5173,7562],[5172,7560],[5171,7561]]],[[[5175,7561],[5174,7561],[5175,7561],[5175,7561],[5175,7561],[5175,7561]]],[[[5203,7556],[5205,7555],[5204,7555],[5196,7561],[5175,7561],[5175,7561],[5196,7562],[5203,7556]]]]}},{\"type\":\"Feature\",\"id\":\"MN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.53,\"hc-key\":\"mn\",\"hc-a2\":\"MN\",\"name\":\"Mongolia\",\"labelrank\":\"3\",\"country-abbrev\":\"Mong.\",\"subregion\":\"Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"MNG\",\"iso-a2\":\"MN\",\"woe-id\":\"23424887\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7691,8008],[7702,8011],[7698,8015],[7722,8015],[7762,7975],[7756,7963],[7714,7968],[7664,7953],[7637,7921],[7603,7919],[7575,7895],[7528,7908],[7511,7885],[7526,7857],[7453,7813],[7372,7807],[7326,7787],[7282,7788],[7232,7803],[7220,7815],[7064,7822],[7034,7879],[6979,7903],[6901,7912],[6906,7963],[6885,8003],[6847,8016],[6814,8039],[6810,8061],[6945,8127],[7001,8115],[7011,8094],[7093,8083],[7121,8113],[7106,8132],[7139,8176],[7237,8144],[7239,8117],[7280,8098],[7330,8111],[7407,8090],[7425,8067],[7490,8060],[7559,8077],[7596,8104],[7628,8089],[7667,8086],[7632,8021],[7642,8005],[7691,8008]]]}},{\"type\":\"Feature\",\"id\":\"RW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.56,\"hc-key\":\"rw\",\"hc-a2\":\"RW\",\"name\":\"Rwanda\",\"labelrank\":\"3\",\"country-abbrev\":\"Rwa.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"RWA\",\"iso-a2\":\"RW\",\"woe-id\":\"23424937\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5065,6398],[5061,6400],[5061,6406],[5075,6419],[5071,6429],[5075,6434],[5082,6438],[5092,6435],[5108,6447],[5119,6432],[5111,6408],[5091,6400],[5065,6398]]]}},{\"type\":\"Feature\",\"id\":\"SO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.39,\"hc-middle-y\":0.74,\"hc-key\":\"so\",\"hc-a2\":\"SO\",\"name\":\"Somalia\",\"labelrank\":\"6\",\"country-abbrev\":\"Som.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"SOM\",\"iso-a2\":\"SO\",\"woe-id\":\"-90\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5447,6596],[5509,6625],[5538,6624],[5628,6715],[5656,6758],[5656,6812],[5726,6829],[5713,6758],[5627,6610],[5570,6551],[5494,6497],[5437,6429],[5420,6453],[5420,6562],[5447,6596]]]}},{\"type\":\"Feature\",\"id\":\"BO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.59,\"hc-key\":\"bo\",\"hc-a2\":\"BO\",\"name\":\"Bolivia\",\"labelrank\":\"3\",\"country-abbrev\":\"Bolivia\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"BOL\",\"iso-a2\":\"BO\",\"woe-id\":\"23424762\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[2153,5996],[2153,6001],[2157,5996],[2155,5997],[2153,5996]]],[[[2141,5957],[2137,5964],[2155,5986],[2169,5993],[2145,6017],[2160,6058],[2153,6073],[2166,6108],[2139,6155],[2177,6154],[2226,6186],[2262,6192],[2263,6149],[2293,6110],[2332,6104],[2369,6077],[2409,6069],[2419,5995],[2469,5993],[2471,5965],[2496,5937],[2478,5876],[2450,5903],[2371,5892],[2356,5864],[2345,5812],[2307,5819],[2295,5792],[2287,5813],[2238,5826],[2210,5794],[2189,5794],[2180,5842],[2163,5868],[2173,5898],[2157,5913],[2141,5957]]]]}},{\"type\":\"Feature\",\"id\":\"CM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.81,\"hc-key\":\"cm\",\"hc-a2\":\"CM\",\"name\":\"Cameroon\",\"labelrank\":\"3\",\"country-abbrev\":\"Cam.\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"CMR\",\"iso-a2\":\"CM\",\"woe-id\":\"23424785\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4599,6542],[4541,6547],[4540,6543],[4500,6543],[4495,6548],[4490,6593],[4459,6621],[4466,6651],[4518,6689],[4540,6669],[4567,6725],[4639,6839],[4621,6866],[4629,6866],[4627,6861],[4634,6863],[4653,6820],[4651,6798],[4669,6774],[4625,6774],[4618,6764],[4655,6729],[4663,6701],[4631,6657],[4654,6590],[4682,6562],[4685,6545],[4684,6530],[4636,6544],[4599,6542]]],[[[4631,6866],[4631,6866],[4630,6866],[4631,6866]]]]}},{\"type\":\"Feature\",\"id\":\"CG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.15,\"hc-middle-y\":0.78,\"hc-key\":\"cg\",\"hc-a2\":\"CG\",\"name\":\"Republic of Congo\",\"labelrank\":\"4\",\"country-abbrev\":\"Rep. Congo\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"COG\",\"iso-a2\":\"CG\",\"woe-id\":\"23424779\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4599,6542],[4636,6544],[4684,6530],[4685,6545],[4696,6581],[4722,6588],[4757,6581],[4740,6542],[4731,6463],[4686,6416],[4685,6381],[4644,6337],[4631,6353],[4592,6342],[4583,6349],[4560,6331],[4554,6344],[4534,6363],[4555,6369],[4547,6410],[4573,6423],[4622,6405],[4634,6461],[4614,6473],[4633,6506],[4597,6515],[4599,6542]]]}},{\"type\":\"Feature\",\"id\":\"EH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.41,\"hc-middle-y\":0.71,\"hc-key\":\"eh\",\"hc-a2\":\"EH\",\"name\":\"Western Sahara\",\"labelrank\":\"7\",\"country-abbrev\":\"W. Sah.\",\"subregion\":\"Northern Africa\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"ESH\",\"iso-a2\":\"EH\",\"woe-id\":\"23424990\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3698,7100],[3696,7103],[3699,7120],[3764,7121],[3782,7148],[3788,7182],[3835,7226],[3847,7264],[3866,7291],[3915,7290],[3943,7298],[3946,7316],[3946,7304],[3946,7263],[3847,7263],[3847,7183],[3818,7170],[3818,7117],[3701,7117],[3698,7100]]]}},{\"type\":\"Feature\",\"id\":\"RS\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.42,\"hc-middle-y\":0.52,\"hc-key\":\"rs\",\"hc-a2\":\"RS\",\"name\":\"Republic of Serbia\",\"labelrank\":\"5\",\"country-abbrev\":\"Serb.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"SRB\",\"iso-a2\":\"RS\",\"woe-id\":\"-90\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4774,7851],[4779,7901],[4768,7900],[4769,7910],[4765,7939],[4784,7948],[4805,7946],[4842,7910],[4839,7897],[4877,7877],[4867,7861],[4885,7836],[4867,7808],[4855,7808],[4844,7805],[4850,7820],[4820,7842],[4808,7826],[4786,7839],[4774,7851]]]}},{\"type\":\"Feature\",\"id\":\"ME\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.42,\"hc-middle-y\":0.47,\"hc-key\":\"me\",\"hc-a2\":\"ME\",\"name\":\"Montenegro\",\"labelrank\":\"6\",\"country-abbrev\":\"Mont.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"MNE\",\"iso-a2\":\"ME\",\"woe-id\":\"20069817\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4774,7851],[4786,7839],[4808,7826],[4798,7822],[4799,7816],[4789,7820],[4780,7808],[4779,7807],[4779,7806],[4772,7806],[4779,7800],[4778,7795],[4779,7791],[4761,7806],[4753,7811],[4751,7814],[4751,7816],[4752,7832],[4774,7851]]]}},{\"type\":\"Feature\",\"id\":\"TG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.76,\"hc-middle-y\":0.81,\"hc-key\":\"tg\",\"hc-a2\":\"TG\",\"name\":\"Togo\",\"labelrank\":\"6\",\"country-abbrev\":\"Togo\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"TGO\",\"iso-a2\":\"TG\",\"woe-id\":\"23424965\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4231,6804],[4252,6746],[4252,6662],[4246,6661],[4239,6659],[4219,6681],[4215,6781],[4199,6808],[4218,6804],[4231,6804]]]}},{\"type\":\"Feature\",\"id\":\"LA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.88,\"hc-middle-y\":0.79,\"hc-key\":\"la\",\"hc-a2\":\"LA\",\"name\":\"Laos\",\"labelrank\":\"4\",\"country-abbrev\":\"Laos\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"LAO\",\"iso-a2\":\"LA\",\"woe-id\":\"23424872\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[7395,6915],[7374,6904],[7325,6904],[7338,6946],[7313,6970],[7315,6996],[7290,7025],[7272,7029],[7249,7010],[7233,7022],[7205,6999],[7209,7061],[7186,7062],[7175,7086],[7193,7117],[7206,7124],[7222,7111],[7217,7146],[7234,7150],[7260,7125],[7264,7103],[7292,7106],[7319,7079],[7286,7055],[7311,7039],[7365,6984],[7399,6932],[7395,6915]]]}},{\"type\":\"Feature\",\"id\":\"AF\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.37,\"hc-middle-y\":0.52,\"hc-key\":\"af\",\"hc-a2\":\"AF\",\"name\":\"Afghanistan\",\"labelrank\":\"3\",\"country-abbrev\":\"Afg.\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"AFG\",\"iso-a2\":\"AF\",\"woe-id\":\"23424739\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6426,7631],[6411,7627],[6416,7624],[6357,7617],[6316,7590],[6330,7562],[6313,7524],[6281,7523],[6290,7499],[6268,7491],[6261,7454],[6226,7450],[6173,7421],[6168,7385],[6106,7371],[6058,7372],[6010,7386],[6038,7418],[6035,7435],[6009,7439],[6001,7491],[6022,7576],[6052,7560],[6117,7598],[6126,7626],[6156,7642],[6178,7635],[6200,7629],[6215,7629],[6259,7626],[6285,7641],[6299,7669],[6329,7653],[6329,7613],[6379,7639],[6426,7631]]]}},{\"type\":\"Feature\",\"id\":\"UA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.7,\"hc-middle-y\":0.46,\"hc-key\":\"ua\",\"hc-a2\":\"UA\",\"name\":\"Ukraine\",\"labelrank\":\"3\",\"country-abbrev\":\"Ukr.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"UKR\",\"iso-a2\":\"UA\",\"woe-id\":\"23424976\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4861,8032],[4866,8042],[4873,8057],[4876,8075],[4919,8114],[4905,8152],[4928,8166],[4969,8168],[5013,8155],[5074,8146],[5110,8154],[5122,8174],[5147,8175],[5207,8185],[5225,8161],[5218,8142],[5245,8140],[5262,8106],[5315,8109],[5367,8087],[5395,8064],[5382,8045],[5384,8010],[5356,8011],[5338,7983],[5269,7966],[5237,7948],[5260,7909],[5212,7882],[5179,7928],[5206,7939],[5146,7950],[5163,7959],[5129,7965],[5089,7927],[5084,7913],[5059,7914],[5041,7922],[5063,7958],[5097,7955],[5068,7999],[5072,8011],[5028,8033],[4994,8026],[4954,8013],[4883,8014],[4875,8020],[4861,8032]],[[5098,7955],[5107,7945],[5109,7947],[5100,7956],[5098,7955]],[[5213,7945],[5242,7929],[5237,7943],[5218,7952],[5213,7945]]]}},{\"type\":\"Feature\",\"id\":\"SK\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.21,\"hc-middle-y\":0.52,\"hc-key\":\"sk\",\"hc-a2\":\"SK\",\"name\":\"Slovakia\",\"labelrank\":\"6\",\"country-abbrev\":\"Svk.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"SVK\",\"iso-a2\":\"SK\",\"woe-id\":\"23424877\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4873,8057],[4866,8042],[4861,8032],[4812,8036],[4795,8021],[4733,8007],[4713,8017],[4704,8030],[4707,8039],[4741,8058],[4763,8074],[4852,8069],[4873,8057]]]}},{\"type\":\"Feature\",\"id\":\"JK\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.4,\"hc-middle-y\":0.63,\"hc-key\":\"jk\",\"hc-a2\":\"JK\",\"name\":\"Siachen Glacier\",\"labelrank\":\"5\",\"country-abbrev\":\"Siachen\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"-99\",\"iso-a2\":\"JK\",\"woe-id\":\"23424928\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6513,7572],[6490,7559],[6482,7577],[6500,7571],[6513,7572]]]}},{\"type\":\"Feature\",\"id\":\"BG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.76,\"hc-middle-y\":0.51,\"hc-key\":\"bg\",\"hc-a2\":\"BG\",\"name\":\"Bulgaria\",\"labelrank\":\"4\",\"country-abbrev\":\"Bulg.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"BGR\",\"iso-a2\":\"BG\",\"woe-id\":\"23424771\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5052,7859],[5026,7812],[5035,7796],[5007,7799],[4985,7786],[4953,7770],[4931,7781],[4884,7773],[4887,7787],[4867,7808],[4885,7836],[4867,7861],[4877,7877],[4896,7864],[4957,7856],[5006,7875],[5052,7859]]]}},{\"type\":\"Feature\",\"id\":\"QA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.36,\"hc-middle-y\":0.46,\"hc-key\":\"qa\",\"hc-a2\":\"QA\",\"name\":\"Qatar\",\"labelrank\":\"5\",\"country-abbrev\":\"Qatar\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"QAT\",\"iso-a2\":\"QA\",\"woe-id\":\"23424930\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5712,7224],[5710,7247],[5735,7259],[5724,7220],[5717,7218],[5712,7224]]]}},{\"type\":\"Feature\",\"id\":\"LI\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.61,\"hc-middle-y\":0.53,\"hc-key\":\"li\",\"hc-a2\":\"LI\",\"name\":\"Liechtenstein\",\"labelrank\":\"6\",\"country-abbrev\":\"Liech.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"LIE\",\"iso-a2\":\"LI\",\"woe-id\":\"23424879\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4487,7989],[4489,7983],[4488,7981],[4485,7981],[4487,7989]]]}},{\"type\":\"Feature\",\"id\":\"AT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.52,\"hc-middle-y\":0.62,\"hc-key\":\"at\",\"hc-a2\":\"AT\",\"name\":\"Austria\",\"labelrank\":\"4\",\"country-abbrev\":\"Aust.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"AUT\",\"iso-a2\":\"AT\",\"woe-id\":\"23424750\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4488,7981],[4489,7983],[4487,7989],[4490,7994],[4488,7998],[4491,7997],[4492,7999],[4530,7993],[4565,8005],[4591,7997],[4582,8021],[4614,8045],[4640,8039],[4648,8053],[4707,8039],[4704,8030],[4713,8017],[4696,8007],[4682,7974],[4635,7956],[4611,7961],[4572,7967],[4566,7982],[4514,7974],[4504,7973],[4488,7981]]]}},{\"type\":\"Feature\",\"id\":\"SZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.51,\"hc-middle-y\":0.45,\"hc-key\":\"sz\",\"hc-a2\":\"SZ\",\"name\":\"Eswatini\",\"labelrank\":\"4\",\"country-abbrev\":\"Swz.\",\"subregion\":\"Southern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"SWZ\",\"iso-a2\":\"SZ\",\"woe-id\":\"23424993\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5152,5696],[5155,5685],[5157,5668],[5128,5656],[5118,5682],[5137,5702],[5152,5696]]]}},{\"type\":\"Feature\",\"id\":\"HU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.27,\"hc-middle-y\":0.61,\"hc-key\":\"hu\",\"hc-a2\":\"HU\",\"name\":\"Hungary\",\"labelrank\":\"5\",\"country-abbrev\":\"Hun.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"HUN\",\"iso-a2\":\"HU\",\"woe-id\":\"23424844\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4861,8032],[4875,8020],[4883,8014],[4857,7997],[4831,7952],[4805,7946],[4784,7948],[4765,7939],[4719,7940],[4694,7960],[4687,7974],[4682,7974],[4696,8007],[4713,8017],[4733,8007],[4795,8021],[4812,8036],[4861,8032]]]}},{\"type\":\"Feature\",\"id\":\"RO\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.67,\"hc-middle-y\":0.5,\"hc-key\":\"ro\",\"hc-a2\":\"RO\",\"name\":\"Romania\",\"labelrank\":\"3\",\"country-abbrev\":\"Rom.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"ROU\",\"iso-a2\":\"RO\",\"woe-id\":\"23424933\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4877,7877],[4839,7897],[4842,7910],[4805,7946],[4831,7952],[4857,7997],[4883,8014],[4954,8013],[4994,8026],[5005,8023],[5042,7965],[5041,7922],[5059,7914],[5084,7913],[5054,7880],[5052,7859],[5006,7875],[4957,7856],[4896,7864],[4877,7877]]]}},{\"type\":\"Feature\",\"id\":\"NE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.64,\"hc-middle-y\":0.53,\"hc-key\":\"ne\",\"hc-a2\":\"NE\",\"name\":\"Niger\",\"labelrank\":\"3\",\"country-abbrev\":\"Niger\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"NER\",\"iso-a2\":\"NE\",\"woe-id\":\"23424906\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4311,6825],[4288,6846],[4275,6831],[4269,6852],[4233,6865],[4210,6922],[4243,6933],[4308,6935],[4328,6967],[4329,7050],[4376,7059],[4426,7103],[4559,7185],[4604,7175],[4626,7157],[4649,7169],[4655,7122],[4678,7087],[4671,7073],[4663,6982],[4603,6906],[4608,6885],[4574,6866],[4543,6875],[4504,6872],[4490,6859],[4436,6874],[4410,6864],[4368,6891],[4326,6878],[4311,6825]]]}},{\"type\":\"Feature\",\"id\":\"LU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.6,\"hc-key\":\"lu\",\"hc-a2\":\"LU\",\"name\":\"Luxembourg\",\"labelrank\":\"6\",\"country-abbrev\":\"Lux.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"LUX\",\"iso-a2\":\"LU\",\"woe-id\":\"23424881\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4392,8072],[4381,8071],[4376,8075],[4374,8088],[4386,8097],[4397,8085],[4392,8072]]]}},{\"type\":\"Feature\",\"id\":\"AD\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.58,\"hc-middle-y\":0.28,\"hc-key\":\"ad\",\"hc-a2\":\"AD\",\"name\":\"Andorra\",\"labelrank\":\"6\",\"country-abbrev\":\"And.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"AND\",\"iso-a2\":\"AD\",\"woe-id\":\"23424744\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4246,7818],[4255,7818],[4255,7814],[4249,7812],[4246,7818]]]}},{\"type\":\"Feature\",\"id\":\"CI\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.48,\"hc-key\":\"ci\",\"hc-a2\":\"CI\",\"name\":\"Ivory Coast\",\"labelrank\":\"3\",\"country-abbrev\":\"I.C.\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"CIV\",\"iso-a2\":\"CI\",\"woe-id\":\"23424854\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4124,6759],[4130,6721],[4108,6681],[4120,6631],[4030,6627],[3980,6607],[3982,6650],[3948,6670],[3952,6702],[3971,6757],[3967,6779],[4019,6782],[4040,6787],[4065,6765],[4109,6772],[4124,6759]]],[[[4111,6629],[4107,6630],[4112,6629],[4111,6629]]]]}},{\"type\":\"Feature\",\"id\":\"LR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.96,\"hc-middle-y\":0.75,\"hc-key\":\"lr\",\"hc-a2\":\"LR\",\"name\":\"Liberia\",\"labelrank\":\"4\",\"country-abbrev\":\"Liberia\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"LBR\",\"iso-a2\":\"LR\",\"woe-id\":\"23424876\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3952,6702],[3948,6670],[3982,6650],[3980,6607],[3929,6631],[3863,6683],[3889,6708],[3899,6729],[3922,6725],[3933,6691],[3952,6702]]]}},{\"type\":\"Feature\",\"id\":\"BN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.32,\"hc-middle-y\":0.34,\"hc-key\":\"bn\",\"hc-a2\":\"BN\",\"name\":\"Brunei\",\"labelrank\":\"6\",\"country-abbrev\":\"Brunei\",\"subregion\":\"South-Eastern Asia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"BRN\",\"iso-a2\":\"BN\",\"woe-id\":\"23424773\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[7618,6621],[7621,6622],[7621,6623],[7627,6606],[7618,6621]]],[[[7587,6614],[7603,6617],[7616,6623],[7606,6597],[7587,6614]]]]}},{\"type\":\"Feature\",\"id\":\"IQ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.46,\"hc-middle-y\":0.44,\"hc-key\":\"iq\",\"hc-a2\":\"IQ\",\"name\":\"Iraq\",\"labelrank\":\"3\",\"country-abbrev\":\"Iraq\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"IRQ\",\"iso-a2\":\"IQ\",\"woe-id\":\"23424855\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5644,7390],[5632,7392],[5627,7391],[5602,7390],[5585,7362],[5530,7365],[5453,7426],[5404,7453],[5366,7460],[5363,7472],[5355,7501],[5412,7533],[5427,7548],[5432,7606],[5461,7627],[5472,7635],[5532,7628],[5549,7589],[5579,7582],[5551,7521],[5577,7487],[5611,7469],[5623,7448],[5619,7423],[5644,7390]]]}},{\"type\":\"Feature\",\"id\":\"GE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.99,\"hc-middle-y\":0.82,\"hc-key\":\"ge\",\"hc-a2\":\"GE\",\"name\":\"Georgia\",\"labelrank\":\"5\",\"country-abbrev\":\"Geo.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"GEO\",\"iso-a2\":\"GE\",\"woe-id\":\"23424823\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5539,7771],[5515,7769],[5493,7765],[5474,7782],[5436,7779],[5436,7819],[5391,7846],[5475,7838],[5508,7816],[5534,7823],[5582,7793],[5584,7763],[5539,7771]]]}},{\"type\":\"Feature\",\"id\":\"GM\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.51,\"hc-middle-y\":0.51,\"hc-key\":\"gm\",\"hc-a2\":\"GM\",\"name\":\"Gambia\",\"labelrank\":\"6\",\"country-abbrev\":\"Gambia\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"GMB\",\"iso-a2\":\"GM\",\"woe-id\":\"23424821\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3707,6866],[3705,6874],[3713,6882],[3762,6888],[3734,6869],[3707,6866]]]}},{\"type\":\"Feature\",\"id\":\"CH\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.12,\"hc-middle-y\":0.55,\"hc-key\":\"ch\",\"hc-a2\":\"CH\",\"name\":\"Switzerland\",\"labelrank\":\"4\",\"country-abbrev\":\"Switz.\",\"subregion\":\"Western Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"CHE\",\"iso-a2\":\"CH\",\"woe-id\":\"23424957\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4477,8004],[4477,8004],[4477,8003],[4477,8003],[4486,7997],[4488,7998],[4490,7994],[4487,7989],[4485,7981],[4488,7981],[4504,7973],[4514,7974],[4500,7955],[4466,7944],[4444,7951],[4412,7939],[4405,7947],[4405,7957],[4400,7961],[4393,7956],[4389,7952],[4386,7963],[4429,8001],[4455,8001],[4477,8004]]]}},{\"type\":\"Feature\",\"id\":\"TD\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.47,\"hc-middle-y\":0.63,\"hc-key\":\"td\",\"hc-a2\":\"TD\",\"name\":\"Chad\",\"labelrank\":\"3\",\"country-abbrev\":\"Chad\",\"subregion\":\"Middle Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"TCD\",\"iso-a2\":\"TD\",\"woe-id\":\"23424777\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4634,6863],[4642,6866],[4631,6866],[4630,6866],[4628,6868],[4629,6866],[4621,6866],[4608,6885],[4603,6906],[4663,6982],[4671,7073],[4678,7087],[4655,7122],[4649,7169],[4678,7183],[4916,7061],[4916,6946],[4889,6945],[4873,6898],[4859,6887],[4863,6856],[4882,6802],[4870,6804],[4810,6749],[4771,6745],[4756,6716],[4702,6702],[4663,6701],[4655,6729],[4618,6764],[4625,6774],[4669,6774],[4651,6798],[4653,6820],[4634,6863]]]}},{\"type\":\"Feature\",\"id\":\"KV\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.52,\"hc-key\":\"kv\",\"hc-a2\":\"KV\",\"name\":\"Kosovo\",\"labelrank\":\"6\",\"country-abbrev\":\"Kos.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"-99\",\"iso-a2\":\"KV\",\"woe-id\":\"-90\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4814,7792],[4812,7804],[4799,7816],[4798,7822],[4808,7826],[4820,7842],[4850,7820],[4844,7805],[4830,7804],[4814,7792]]]}},{\"type\":\"Feature\",\"id\":\"LB\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.39,\"hc-middle-y\":0.57,\"hc-key\":\"lb\",\"hc-a2\":\"LB\",\"name\":\"Lebanon\",\"labelrank\":\"5\",\"country-abbrev\":\"Leb.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"LBN\",\"iso-a2\":\"LB\",\"woe-id\":\"23424873\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5246,7492],[5260,7519],[5271,7544],[5290,7529],[5267,7502],[5257,7492],[5246,7492]]]}},{\"type\":\"Feature\",\"id\":\"DJ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.56,\"hc-middle-y\":0.55,\"hc-key\":\"dj\",\"hc-a2\":\"DJ\",\"name\":\"Djibouti\",\"labelrank\":\"5\",\"country-abbrev\":\"Dji.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"DJI\",\"iso-a2\":\"DJ\",\"woe-id\":\"23424797\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5478,6804],[5449,6802],[5444,6807],[5447,6810],[5444,6813],[5443,6820],[5462,6848],[5471,6845],[5484,6855],[5490,6834],[5487,6819],[5478,6804]]]}},{\"type\":\"Feature\",\"id\":\"BI\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.57,\"hc-middle-y\":0.47,\"hc-key\":\"bi\",\"hc-a2\":\"BI\",\"name\":\"Burundi\",\"labelrank\":\"6\",\"country-abbrev\":\"Bur.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"BDI\",\"iso-a2\":\"BI\",\"woe-id\":\"23424774\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5084,6347],[5076,6364],[5071,6380],[5072,6389],[5065,6398],[5091,6400],[5111,6408],[5118,6383],[5084,6347]]]}},{\"type\":\"Feature\",\"id\":\"SR\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.91,\"hc-middle-y\":0.09,\"hc-key\":\"sr\",\"hc-a2\":\"SR\",\"name\":\"Suriname\",\"labelrank\":\"4\",\"country-abbrev\":\"Sur.\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"SUR\",\"iso-a2\":\"SR\",\"woe-id\":\"23424913\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2583,6547],[2543,6553],[2528,6536],[2481,6602],[2505,6641],[2514,6656],[2601,6651],[2596,6636],[2587,6623],[2601,6581],[2583,6547]]]}},{\"type\":\"Feature\",\"id\":\"IL\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.68,\"hc-middle-y\":0.1,\"hc-key\":\"il\",\"hc-a2\":\"IL\",\"name\":\"Israel\",\"labelrank\":\"4\",\"country-abbrev\":\"Isr.\",\"subregion\":\"Western Asia\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"ISR\",\"iso-a2\":\"IL\",\"woe-id\":\"23424852\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5219,7433],[5238,7465],[5246,7492],[5257,7492],[5267,7502],[5269,7487],[5265,7480],[5259,7477],[5259,7448],[5254,7440],[5255,7434],[5254,7432],[5255,7431],[5253,7429],[5255,7426],[5247,7405],[5241,7377],[5240,7374],[5239,7374],[5237,7382],[5219,7433]]]}},{\"type\":\"Feature\",\"id\":\"ML\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.59,\"hc-middle-y\":0.38,\"hc-key\":\"ml\",\"hc-a2\":\"ML\",\"name\":\"Mali\",\"labelrank\":\"3\",\"country-abbrev\":\"Mali\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"MLI\",\"iso-a2\":\"ML\",\"woe-id\":\"23424891\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4040,6787],[4019,6782],[3967,6779],[3955,6815],[3931,6848],[3886,6831],[3866,6846],[3845,6885],[3840,6917],[3856,6941],[3886,6937],[4040,6939],[4008,7231],[4061,7231],[4238,7110],[4260,7083],[4299,7070],[4296,7050],[4329,7050],[4328,6967],[4308,6935],[4243,6933],[4210,6922],[4183,6927],[4141,6899],[4120,6895],[4099,6869],[4083,6876],[4069,6839],[4051,6832],[4040,6787]]]}},{\"type\":\"Feature\",\"id\":\"SN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.2,\"hc-middle-y\":0.55,\"hc-key\":\"sn\",\"hc-a2\":\"SN\",\"name\":\"Senegal\",\"labelrank\":\"3\",\"country-abbrev\":\"Sen.\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"SEN\",\"iso-a2\":\"SN\",\"woe-id\":\"23424943\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3708,6844],[3705,6859],[3707,6866],[3734,6869],[3762,6888],[3713,6882],[3695,6922],[3713,6949],[3719,6968],[3779,6974],[3840,6917],[3845,6885],[3866,6846],[3837,6843],[3797,6854],[3753,6854],[3708,6844]]]}},{\"type\":\"Feature\",\"id\":\"GN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.24,\"hc-middle-y\":0.51,\"hc-key\":\"gn\",\"hc-a2\":\"GN\",\"name\":\"Guinea\",\"labelrank\":\"3\",\"country-abbrev\":\"Gin.\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"GIN\",\"iso-a2\":\"GN\",\"woe-id\":\"23424835\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3866,6846],[3886,6831],[3931,6848],[3955,6815],[3967,6779],[3971,6757],[3952,6702],[3933,6691],[3922,6725],[3899,6729],[3870,6774],[3833,6770],[3809,6746],[3793,6770],[3758,6803],[3767,6819],[3797,6825],[3797,6854],[3837,6843],[3866,6846]]]}},{\"type\":\"Feature\",\"id\":\"ZW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.81,\"hc-middle-y\":0.42,\"hc-key\":\"zw\",\"hc-a2\":\"ZW\",\"name\":\"Zimbabwe\",\"labelrank\":\"3\",\"country-abbrev\":\"Zimb.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"ZWE\",\"iso-a2\":\"ZW\",\"woe-id\":\"23425004\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4954,5949],[4996,5940],[5006,5944],[5038,5977],[5038,5977],[5058,5987],[5060,6001],[5106,6014],[5182,5982],[5185,5932],[5176,5898],[5184,5880],[5166,5841],[5133,5807],[5104,5809],[5075,5814],[5036,5833],[5026,5865],[4979,5896],[4954,5949]]]}},{\"type\":\"Feature\",\"id\":\"PL\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.48,\"hc-key\":\"pl\",\"hc-a2\":\"PL\",\"name\":\"Poland\",\"labelrank\":\"3\",\"country-abbrev\":\"Pol.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"POL\",\"iso-a2\":\"PL\",\"woe-id\":\"23424923\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4786,8270],[4779,8263],[4790,8269],[4878,8266],[4880,8266],[4900,8258],[4901,8249],[4912,8198],[4891,8183],[4905,8152],[4919,8114],[4876,8075],[4873,8057],[4852,8069],[4763,8074],[4755,8089],[4691,8116],[4644,8126],[4639,8194],[4623,8205],[4627,8239],[4638,8245],[4625,8247],[4625,8248],[4626,8249],[4683,8263],[4696,8274],[4748,8286],[4756,8269],[4786,8270],[4786,8270]]]}},{\"type\":\"Feature\",\"id\":\"MK\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.44,\"hc-key\":\"mk\",\"hc-a2\":\"MK\",\"name\":\"North Macedonia\",\"labelrank\":\"6\",\"country-abbrev\":\"Mkd.\",\"subregion\":\"Southern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"MKD\",\"iso-a2\":\"MK\",\"woe-id\":\"23424890\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[4826,7756],[4826,7756],[4826,7756],[4826,7756]]],[[[4867,7808],[4887,7787],[4884,7773],[4854,7765],[4831,7756],[4826,7762],[4826,7757],[4825,7758],[4825,7758],[4822,7758],[4819,7758],[4822,7765],[4816,7764],[4811,7781],[4814,7792],[4830,7804],[4844,7805],[4855,7808],[4867,7808]]]]}},{\"type\":\"Feature\",\"id\":\"PY\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.35,\"hc-middle-y\":0.36,\"hc-key\":\"py\",\"hc-a2\":\"PY\",\"name\":\"Paraguay\",\"labelrank\":\"4\",\"country-abbrev\":\"Para.\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"PRY\",\"iso-a2\":\"PY\",\"woe-id\":\"23424917\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2594,5755],[2590,5743],[2583,5712],[2584,5709],[2584,5708],[2578,5674],[2549,5649],[2465,5653],[2496,5712],[2422,5757],[2394,5763],[2345,5812],[2356,5864],[2371,5892],[2450,5903],[2478,5876],[2488,5852],[2483,5817],[2530,5817],[2553,5800],[2559,5759],[2594,5755]]]}},{\"type\":\"Feature\",\"id\":\"BY\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.5,\"hc-key\":\"by\",\"hc-a2\":\"BY\",\"name\":\"Belarus\",\"labelrank\":\"4\",\"country-abbrev\":\"Bela.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"BLR\",\"iso-a2\":\"BY\",\"woe-id\":\"23424765\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4905,8152],[4891,8183],[4912,8198],[4901,8249],[4927,8247],[4960,8264],[4972,8290],[4998,8305],[4993,8320],[5023,8325],[5039,8340],[5121,8317],[5146,8243],[5175,8229],[5131,8212],[5147,8175],[5122,8174],[5110,8154],[5074,8146],[5013,8155],[4969,8168],[4928,8166],[4905,8152]]]}},{\"type\":\"Feature\",\"id\":\"CZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.56,\"hc-key\":\"cz\",\"hc-a2\":\"CZ\",\"name\":\"Czech Republic\",\"labelrank\":\"5\",\"country-abbrev\":\"Cz. Rep.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"CZE\",\"iso-a2\":\"CZ\",\"woe-id\":\"23424810\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4763,8074],[4741,8058],[4707,8039],[4648,8053],[4640,8039],[4614,8045],[4571,8083],[4575,8108],[4644,8126],[4691,8116],[4755,8089],[4763,8074]]]}},{\"type\":\"Feature\",\"id\":\"BF\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.54,\"hc-key\":\"bf\",\"hc-a2\":\"BF\",\"name\":\"Burkina Faso\",\"labelrank\":\"3\",\"country-abbrev\":\"B.F.\",\"subregion\":\"Western Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"BFA\",\"iso-a2\":\"BF\",\"woe-id\":\"23424978\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4231,6804],[4218,6804],[4199,6808],[4122,6804],[4124,6759],[4109,6772],[4065,6765],[4040,6787],[4051,6832],[4069,6839],[4083,6876],[4099,6869],[4120,6895],[4141,6899],[4183,6927],[4210,6922],[4233,6865],[4269,6852],[4275,6831],[4247,6818],[4231,6804]]]}},{\"type\":\"Feature\",\"id\":\"NA\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.33,\"hc-middle-y\":0.37,\"hc-key\":\"na\",\"hc-a2\":\"NA\",\"name\":\"Namibia\",\"labelrank\":\"3\",\"country-abbrev\":\"Nam.\",\"subregion\":\"Southern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"NAM\",\"iso-a2\":\"NA\",\"woe-id\":\"23424987\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4898,5953],[4923,5958],[4954,5949],[4904,5928],[4895,5942],[4826,5933],[4827,5821],[4797,5819],[4797,5734],[4797,5617],[4771,5600],[4720,5608],[4711,5630],[4693,5613],[4658,5652],[4637,5740],[4631,5811],[4602,5855],[4577,5909],[4561,5927],[4553,5965],[4595,5974],[4618,5960],[4752,5961],[4761,5950],[4821,5941],[4898,5953]]]}},{\"type\":\"Feature\",\"id\":\"LY\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.51,\"hc-middle-y\":0.38,\"hc-key\":\"ly\",\"hc-a2\":\"LY\",\"name\":\"Libya\",\"labelrank\":\"3\",\"country-abbrev\":\"Libya\",\"subregion\":\"Northern Africa\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"LBY\",\"iso-a2\":\"LY\",\"woe-id\":\"23424882\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4649,7169],[4626,7157],[4604,7175],[4559,7185],[4546,7209],[4502,7227],[4483,7267],[4496,7279],[4496,7363],[4486,7398],[4509,7421],[4504,7437],[4547,7471],[4545,7495],[4570,7483],[4600,7486],[4655,7469],[4680,7432],[4719,7426],[4770,7399],[4790,7407],[4795,7448],[4814,7474],[4846,7487],[4890,7477],[4889,7467],[4945,7455],[4950,7445],[4937,7397],[4945,7364],[4945,7138],[4945,7076],[4916,7076],[4916,7061],[4678,7183],[4649,7169]]]}},{\"type\":\"Feature\",\"id\":\"TN\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.53,\"hc-middle-y\":0.03,\"hc-key\":\"tn\",\"hc-a2\":\"TN\",\"name\":\"Tunisia\",\"labelrank\":\"3\",\"country-abbrev\":\"Tun.\",\"subregion\":\"Northern Africa\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"TUN\",\"iso-a2\":\"TN\",\"woe-id\":\"23424967\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4545,7495],[4547,7471],[4504,7437],[4509,7421],[4486,7398],[4472,7458],[4451,7473],[4426,7518],[4448,7543],[4452,7604],[4459,7621],[4493,7635],[4535,7563],[4505,7533],[4511,7512],[4532,7515],[4545,7495]]]}},{\"type\":\"Feature\",\"id\":\"BT\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.48,\"hc-key\":\"bt\",\"hc-a2\":\"BT\",\"name\":\"Bhutan\",\"labelrank\":\"5\",\"country-abbrev\":\"Bhutan\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"BTN\",\"iso-a2\":\"BT\",\"woe-id\":\"23424770\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6842,7305],[6882,7338],[6923,7319],[6937,7293],[6869,7285],[6842,7305]]]}},{\"type\":\"Feature\",\"id\":\"MD\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.52,\"hc-middle-y\":0.42,\"hc-key\":\"md\",\"hc-a2\":\"MD\",\"name\":\"Moldova\",\"labelrank\":\"6\",\"country-abbrev\":\"Mda.\",\"subregion\":\"Eastern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"MDA\",\"iso-a2\":\"MD\",\"woe-id\":\"23424885\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5041,7922],[5042,7965],[5005,8023],[4994,8026],[5028,8033],[5072,8011],[5068,7999],[5097,7955],[5063,7958],[5041,7922]]]}},{\"type\":\"Feature\",\"id\":\"SS\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.58,\"hc-key\":\"ss\",\"hc-a2\":\"SS\",\"name\":\"South Sudan\",\"labelrank\":\"3\",\"country-abbrev\":\"S. Sud.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"SSD\",\"iso-a2\":\"SS\",\"woe-id\":\"-99\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5212,6603],[5198,6589],[5119,6582],[5088,6613],[5046,6605],[5018,6628],[4988,6658],[4987,6675],[4956,6696],[4921,6735],[4948,6783],[4970,6787],[4992,6760],[5060,6754],[5095,6783],[5131,6768],[5166,6806],[5156,6834],[5190,6840],[5189,6800],[5215,6758],[5211,6728],[5190,6729],[5185,6709],[5205,6705],[5235,6675],[5270,6615],[5255,6627],[5212,6603]]]}},{\"type\":\"Feature\",\"id\":\"BW\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.49,\"hc-middle-y\":0.6,\"hc-key\":\"bw\",\"hc-a2\":\"BW\",\"name\":\"Botswana\",\"labelrank\":\"4\",\"country-abbrev\":\"Bwa.\",\"subregion\":\"Southern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"BWA\",\"iso-a2\":\"BW\",\"woe-id\":\"23424755\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[4954,5949],[4979,5896],[5026,5865],[5036,5833],[5075,5814],[5041,5799],[5006,5769],[5000,5749],[4972,5734],[4963,5706],[4941,5700],[4887,5716],[4878,5695],[4847,5667],[4818,5666],[4822,5690],[4797,5734],[4797,5819],[4827,5821],[4826,5933],[4895,5942],[4904,5928],[4954,5949]]]}},{\"type\":\"Feature\",\"id\":\"BS\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.8,\"hc-middle-y\":0.92,\"hc-key\":\"bs\",\"hc-a2\":\"BS\",\"name\":\"The Bahamas\",\"labelrank\":\"4\",\"country-abbrev\":\"Bhs.\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"BHS\",\"iso-a2\":\"BS\",\"woe-id\":\"23424758\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[1956,7219],[1937,7241],[1937,7241],[1937,7241],[1944,7236],[1956,7219],[1956,7219]]],[[[1956,7219],[1970,7205],[1976,7173],[2045,7149],[1983,7165],[1949,7190],[1966,7207],[1956,7219],[1956,7219]]],[[[1937,7241],[1911,7260],[1890,7236],[1901,7192],[1881,7221],[1883,7237],[1912,7268],[1937,7241],[1937,7241],[1937,7241]]]]}},{\"type\":\"Feature\",\"id\":\"NZ\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.25,\"hc-middle-y\":0.81,\"hc-key\":\"nz\",\"hc-a2\":\"NZ\",\"name\":\"New Zealand\",\"labelrank\":\"2\",\"country-abbrev\":\"N.Z.\",\"subregion\":\"Australia and New Zealand\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"NZL\",\"iso-a2\":\"NZ\",\"woe-id\":\"23424916\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[9238,4994],[9198,4996],[9194,4975],[9181,5009],[9153,5008],[9145,5023],[9159,5047],[9201,5088],[9241,5104],[9282,5140],[9311,5200],[9330,5213],[9341,5185],[9362,5199],[9374,5165],[9321,5099],[9289,5079],[9268,5027],[9238,4994]]],[[[9429,5191],[9404,5174],[9386,5186],[9404,5221],[9361,5252],[9385,5272],[9393,5308],[9378,5347],[9341,5395],[9364,5402],[9402,5361],[9422,5343],[9427,5313],[9470,5301],[9503,5310],[9483,5263],[9469,5264],[9429,5191]]]]}},{\"type\":\"Feature\",\"id\":\"CU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.67,\"hc-middle-y\":0.64,\"hc-key\":\"cu\",\"hc-a2\":\"CU\",\"name\":\"Cuba\",\"labelrank\":\"3\",\"country-abbrev\":\"Cuba\",\"subregion\":\"Caribbean\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"CUB\",\"iso-a2\":\"CU\",\"woe-id\":\"23424793\",\"continent\":\"North America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1916,7091],[1870,7097],[1853,7124],[1817,7140],[1776,7144],[1774,7159],[1748,7160],[1696,7131],[1700,7149],[1734,7169],[1770,7175],[1828,7171],[1852,7150],[1867,7154],[1879,7155],[1933,7113],[1986,7095],[2000,7078],[1898,7071],[1916,7091]]]}},{\"type\":\"Feature\",\"id\":\"EC\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.16,\"hc-middle-y\":0.37,\"hc-key\":\"ec\",\"hc-a2\":\"EC\",\"name\":\"Ecuador\",\"labelrank\":\"3\",\"country-abbrev\":\"Ecu.\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"ECU\",\"iso-a2\":\"EC\",\"woe-id\":\"23424801\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[1820,6379],[1837,6400],[1803,6410],[1803,6447],[1828,6480],[1827,6500],[1865,6521],[1905,6498],[1940,6492],[1970,6476],[1961,6433],[1928,6403],[1879,6379],[1858,6331],[1815,6358],[1820,6379]]]}},{\"type\":\"Feature\",\"id\":\"AU\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.53,\"hc-middle-y\":0.39,\"hc-key\":\"au\",\"hc-a2\":\"AU\",\"name\":\"Australia\",\"labelrank\":\"2\",\"country-abbrev\":\"Auz.\",\"subregion\":\"Australia and New Zealand\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"AUS\",\"iso-a2\":\"AU\",\"woe-id\":\"-90\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[8563,5105],[8537,5105],[8515,5139],[8497,5193],[8499,5215],[8479,5229],[8543,5191],[8602,5210],[8604,5168],[8595,5117],[8581,5130],[8563,5105]]],[[[8541,5953],[8550,5909],[8629,5866],[8644,5812],[8680,5798],[8682,5771],[8712,5753],[8733,5720],[8756,5726],[8746,5701],[8761,5650],[8762,5603],[8731,5487],[8709,5472],[8660,5372],[8655,5318],[8605,5306],[8551,5275],[8505,5283],[8507,5304],[8464,5271],[8430,5288],[8379,5298],[8351,5328],[8347,5368],[8329,5384],[8261,5366],[8280,5383],[8270,5405],[8300,5464],[8283,5464],[8229,5404],[8216,5439],[8189,5463],[8185,5486],[8128,5500],[8096,5519],[8032,5512],[7981,5492],[7949,5494],[7887,5463],[7870,5437],[7765,5438],[7718,5405],[7680,5400],[7646,5408],[7616,5433],[7637,5459],[7637,5513],[7616,5560],[7616,5583],[7592,5627],[7587,5653],[7556,5702],[7573,5710],[7590,5680],[7592,5701],[7570,5741],[7577,5802],[7645,5849],[7698,5861],[7793,5892],[7834,5938],[7830,5965],[7853,5985],[7871,5957],[7872,5998],[7896,5993],[7897,6026],[7916,6045],[7961,6056],[7971,6072],[8008,6042],[8052,6031],[8043,6051],[8090,6125],[8063,6129],[8073,6147],[8104,6146],[8105,6115],[8141,6119],[8139,6152],[8156,6132],[8212,6115],[8254,6129],[8267,6115],[8237,6071],[8224,6036],[8256,6011],[8329,5976],[8359,5951],[8384,5959],[8408,6030],[8406,6107],[8417,6122],[8422,6177],[8436,6161],[8463,6071],[8476,6048],[8492,6058],[8517,6035],[8519,5993],[8541,5953]]]]}},{\"type\":\"Feature\",\"id\":\"VE\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.33,\"hc-key\":\"ve\",\"hc-a2\":\"VE\",\"name\":\"Venezuela\",\"labelrank\":\"3\",\"country-abbrev\":\"Ven.\",\"subregion\":\"South America\",\"region-wb\":\"Latin America & Caribbean\",\"iso-a3\":\"VEN\",\"iso-a2\":\"VE\",\"woe-id\":\"23424982\",\"continent\":\"South America\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[2087,6830],[2070,6823],[2080,6796],[2064,6769],[2082,6746],[2096,6767],[2080,6799],[2122,6818],[2160,6818],[2188,6788],[2237,6794],[2282,6777],[2307,6793],[2343,6797],[2357,6776],[2400,6756],[2397,6742],[2423,6732],[2408,6709],[2415,6689],[2387,6672],[2382,6653],[2401,6632],[2377,6604],[2286,6596],[2303,6552],[2324,6550],[2301,6525],[2258,6498],[2219,6515],[2210,6549],[2191,6564],[2207,6580],[2190,6612],[2201,6662],[2143,6659],[2123,6685],[2064,6688],[2056,6726],[2037,6753],[2040,6787],[2068,6824],[2087,6830]]]}},{\"type\":\"Feature\",\"id\":\"SB\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.13,\"hc-middle-y\":0.24,\"hc-key\":\"sb\",\"hc-a2\":\"SB\",\"name\":\"Solomon Islands\",\"labelrank\":\"3\",\"country-abbrev\":\"S. Is.\",\"subregion\":\"Melanesia\",\"region-wb\":\"East Asia & Pacific\",\"iso-a3\":\"SLB\",\"iso-a2\":\"SB\",\"woe-id\":\"23424766\",\"continent\":\"Oceania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8977,6187],[8947,6189],[8947,6226],[8902,6255],[8881,6242],[8899,6222],[8858,6239],[8861,6266],[8912,6255],[8947,6233],[8955,6212],[8982,6224],[8977,6187]]]}},{\"type\":\"Feature\",\"id\":\"MG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.45,\"hc-middle-y\":0.48,\"hc-key\":\"mg\",\"hc-a2\":\"MG\",\"name\":\"Madagascar\",\"labelrank\":\"3\",\"country-abbrev\":\"Mad.\",\"subregion\":\"Eastern Africa\",\"region-wb\":\"Sub-Saharan Africa\",\"iso-a3\":\"MDG\",\"iso-a2\":\"MG\",\"woe-id\":\"23424883\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5683,5987],[5616,5762],[5601,5727],[5544,5707],[5511,5726],[5503,5774],[5487,5812],[5495,5841],[5524,5882],[5508,5959],[5523,5997],[5558,6004],[5613,6031],[5635,6081],[5650,6080],[5665,6125],[5686,6092],[5702,6020],[5677,6017],[5683,5987]]]}},{\"type\":\"Feature\",\"id\":\"IS\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.5,\"hc-key\":\"is\",\"hc-a2\":\"IS\",\"name\":\"Iceland\",\"labelrank\":\"3\",\"country-abbrev\":\"Iceland\",\"subregion\":\"Northern Europe\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"ISL\",\"iso-a2\":\"IS\",\"woe-id\":\"23424845\",\"continent\":\"Europe\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[3490,8732],[3556,8739],[3551,8757],[3516,8766],[3476,8762],[3500,8775],[3508,8796],[3538,8790],[3534,8809],[3571,8786],[3566,8765],[3584,8755],[3607,8792],[3661,8795],[3682,8785],[3715,8796],[3713,8811],[3768,8789],[3763,8773],[3795,8763],[3803,8741],[3772,8709],[3677,8676],[3648,8661],[3605,8668],[3575,8684],[3530,8682],[3560,8708],[3538,8728],[3490,8732]]]}},{\"type\":\"Feature\",\"id\":\"EG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.5,\"hc-middle-y\":0.66,\"hc-key\":\"eg\",\"hc-a2\":\"EG\",\"name\":\"Egypt\",\"labelrank\":\"2\",\"country-abbrev\":\"Egypt\",\"subregion\":\"Northern Africa\",\"region-wb\":\"Middle East & North Africa\",\"iso-a3\":\"EGY\",\"iso-a2\":\"EG\",\"woe-id\":\"23424802\",\"continent\":\"Africa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[5239,7374],[5220,7318],[5190,7345],[5169,7390],[5172,7358],[5201,7320],[5213,7282],[5258,7199],[5263,7167],[5299,7138],[5131,7138],[4945,7138],[4945,7364],[4937,7397],[4950,7445],[5015,7435],[5065,7418],[5105,7440],[5140,7438],[5157,7425],[5219,7433],[5237,7382],[5239,7374]]]}},{\"type\":\"Feature\",\"id\":\"KG\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.48,\"hc-middle-y\":0.43,\"hc-key\":\"kg\",\"hc-a2\":\"KG\",\"name\":\"Kyrgyzstan\",\"labelrank\":\"4\",\"country-abbrev\":\"Kgz.\",\"subregion\":\"Central Asia\",\"region-wb\":\"Europe & Central Asia\",\"iso-a3\":\"KGZ\",\"iso-a2\":\"KG\",\"woe-id\":\"23424864\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6389,7707],[6348,7698],[6325,7713],[6261,7709],[6280,7734],[6310,7734],[6331,7731],[6374,7754],[6333,7777],[6323,7766],[6286,7782],[6309,7805],[6336,7826],[6385,7812],[6405,7842],[6435,7827],[6531,7828],[6584,7803],[6529,7774],[6521,7763],[6482,7759],[6450,7736],[6446,7748],[6399,7728],[6389,7707]],[[6300,7721],[6296,7722],[6299,7718],[6302,7720],[6300,7721]],[[6333,7723],[6334,7726],[6331,7724],[6332,7723],[6333,7723]],[[6316,7728],[6310,7729],[6312,7722],[6317,7722],[6316,7728]]]}},{\"type\":\"Feature\",\"id\":\"NP\",\"properties\":{\"hc-group\":\"admin0\",\"hc-middle-x\":0.52,\"hc-middle-y\":0.54,\"hc-key\":\"np\",\"hc-a2\":\"NP\",\"name\":\"Nepal\",\"labelrank\":\"3\",\"country-abbrev\":\"Nepal\",\"subregion\":\"Southern Asia\",\"region-wb\":\"South Asia\",\"iso-a3\":\"NPL\",\"iso-a2\":\"NP\",\"woe-id\":\"23424911\",\"continent\":\"Asia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6819,7322],[6820,7286],[6795,7274],[6751,7281],[6714,7305],[6660,7310],[6579,7353],[6589,7383],[6608,7397],[6640,7401],[6683,7364],[6699,7367],[6729,7336],[6756,7323],[6773,7330],[6819,7322]]]}}]}"));}}),
"[project]/node_modules/highcharts/modules/tiledwebmap.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
!/**
 * Highcharts JS v12.1.2 (2024-12-21)
 * @module highcharts/modules/tiledwebmap
 * @requires highcharts
 *
 * (c) 2009-2024
 *
 * License: www.highcharts.com/license
 */ function(e, t) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = t(e._Highcharts, e._Highcharts.SeriesRegistry) : ("TURBOPACK unreachable", undefined);
}("undefined" == typeof window ? this : window, (e, t)=>(()=>{
        "use strict";
        var o = {
            512: (e)=>{
                e.exports = t;
            },
            944: (t)=>{
                t.exports = e;
            }
        }, r = {};
        function i(e) {
            var t = r[e];
            if (void 0 !== t) return t.exports;
            var s = r[e] = {
                exports: {}
            };
            return o[e](s, s.exports, i), s.exports;
        }
        i.n = (e)=>{
            var t = e && e.__esModule ? ()=>e.default : ()=>e;
            return i.d(t, {
                a: t
            }), t;
        }, i.d = (e, t)=>{
            for(var o in t)i.o(t, o) && !i.o(e, o) && Object.defineProperty(e, o, {
                enumerable: !0,
                get: t[o]
            });
        }, i.o = (e, t)=>Object.prototype.hasOwnProperty.call(e, t);
        var s = {};
        i.d(s, {
            default: ()=>v
        });
        var a = i(944), n = i.n(a);
        let p = {
            Esri: class {
                constructor(){
                    this.defaultCredits = "Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS,  Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012", this.initialProjectionName = "WebMercator", this.themes = {
                        WorldStreetMap: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 20
                        },
                        DeLorme: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/Specialty/DeLorme_World_Base_Map/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 1,
                            maxZoom: 11,
                            credits: "Tiles &copy; Esri &mdash; Copyright: &copy;2012 DeLorme"
                        },
                        WorldTopoMap: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 20,
                            credits: "Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community"
                        },
                        WorldImagery: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 20,
                            credits: "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community"
                        },
                        WorldTerrain: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 13,
                            credits: "Tiles &copy; Esri &mdash; Source: USGS, Esri, TANA, DeLorme, and NPS"
                        },
                        WorldShadedRelief: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 13,
                            credits: "Tiles &copy; Esri &mdash; Source: Esri"
                        },
                        WorldPhysical: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 8,
                            credits: "Tiles &copy; Esri &mdash; Source: US National Park Service"
                        },
                        NatGeoWorldMap: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 16,
                            credits: "Tiles &copy; Esri &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC"
                        },
                        WorldGrayCanvas: {
                            url: "https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 16,
                            credits: "Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ"
                        }
                    };
                }
            },
            LimaLabs: class {
                constructor(){
                    this.defaultCredits = 'Map data &copy;2023 <a href="https://maps.lima-labs.com/">LimaLabs</a>', this.initialProjectionName = "WebMercator", this.requiresApiKey = !0, this.themes = {
                        Standard: {
                            url: "https://cdn.lima-labs.com/{zoom}/{x}/{y}.png?api={apikey}",
                            minZoom: 0,
                            maxZoom: 20
                        }
                    };
                }
            },
            OpenStreetMap: class {
                constructor(){
                    this.defaultCredits = 'Map data &copy2023 <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>', this.initialProjectionName = "WebMercator", this.subdomains = [
                        "a",
                        "b",
                        "c"
                    ], this.themes = {
                        Standard: {
                            url: "https://tile.openstreetmap.org/{zoom}/{x}/{y}.png",
                            minZoom: 0,
                            maxZoom: 19
                        },
                        Hot: {
                            url: "https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png",
                            minZoom: 0,
                            maxZoom: 19
                        },
                        OpenTopoMap: {
                            url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
                            minZoom: 0,
                            maxZoom: 17,
                            credits: `Map data: &copy; <a href="https://www.openstreetmap.org/copyright">
                OpenStreetMap</a> contributors, <a href="https://viewfinderpanoramas.org">SRTM</a> 
                | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> 
                (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)`
                        }
                    };
                }
            },
            Stamen: class {
                constructor(){
                    this.defaultCredits = '&copy; Map tiles by <a href="https://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://www.openstreetmap.org/copyright">ODbL</a>', this.initialProjectionName = "WebMercator", this.subdomains = [
                        "a",
                        "b",
                        "c",
                        "d"
                    ], this.themes = {
                        Toner: {
                            url: "https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png",
                            minZoom: 0,
                            maxZoom: 20
                        },
                        TonerBackground: {
                            url: "https://stamen-tiles-{s}.a.ssl.fastly.net/toner-background/{z}/{x}/{y}.png",
                            minZoom: 0,
                            maxZoom: 20
                        },
                        TonerLite: {
                            url: "https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png",
                            minZoom: 0,
                            maxZoom: 20
                        },
                        Terrain: {
                            url: "https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png",
                            minZoom: 0,
                            maxZoom: 18
                        },
                        TerrainBackground: {
                            url: "https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}.png",
                            minZoom: 0,
                            maxZoom: 18
                        },
                        Watercolor: {
                            url: "https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.png",
                            minZoom: 1,
                            maxZoom: 16,
                            credits: '&copy Map tiles by <a href="https://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>'
                        }
                    };
                }
            },
            Thunderforest: class {
                constructor(){
                    this.defaultCredits = 'Maps &copy <a href="https://www.thunderforest.com">Thunderforest</a>, Data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>', this.initialProjectionName = "WebMercator", this.requiresApiKey = !0, this.subdomains = [
                        "a",
                        "b",
                        "c"
                    ], this.themes = {
                        OpenCycleMap: {
                            url: "https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        },
                        Transport: {
                            url: "https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        },
                        TransportDark: {
                            url: "https://{s}.tile.thunderforest.com/transport-dark/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        },
                        SpinalMap: {
                            url: "https://{s}.tile.thunderforest.com/spinal-map/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        },
                        Landscape: {
                            url: "https://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        },
                        Outdoors: {
                            url: "https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        },
                        Pioneer: {
                            url: "https://{s}.tile.thunderforest.com/pioneer/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        },
                        MobileAtlas: {
                            url: "https://{s}.tile.thunderforest.com/mobile-atlas/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        },
                        Neighbourhood: {
                            url: "https://{s}.tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png?apikey={apikey}",
                            minZoom: 0,
                            maxZoom: 22
                        }
                    };
                }
            },
            USGS: class {
                constructor(){
                    this.defaultCredits = 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. GeologicalSurvey</a>', this.initialProjectionName = "WebMercator", this.themes = {
                        USTopo: {
                            url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 20
                        },
                        USImagery: {
                            url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 20
                        },
                        USImageryTopo: {
                            url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}",
                            minZoom: 0,
                            maxZoom: 20
                        }
                    };
                }
            }
        };
        var l = i(512), m = i.n(l);
        let { composed: h } = n(), { map: c } = m().seriesTypes, { addEvent: d, defined: y, error: u, merge: g, pick: f, pushUnique: x } = n();
        function M(e) {
            let { geoBounds: t, chart: o } = e, r = (o.options.series || []).filter((e)=>"tiledwebmap" === e.type)[0];
            if (r && r.provider && r.provider.type && !r.provider.url) {
                let e = p[r.provider.type];
                if (y(e)) {
                    let { initialProjectionName: o } = new e;
                    if (t) {
                        let { x1: e, y1: r, x2: i, y2: s } = t;
                        this.recommendedMapView = {
                            projection: {
                                name: o,
                                parallels: [
                                    r,
                                    s
                                ],
                                rotation: [
                                    -(e + i) / 2
                                ]
                            }
                        };
                    } else this.recommendedMapView = {
                        projection: {
                            name: o
                        },
                        minZoom: 0
                    };
                    return !1;
                }
                u("Highcharts warning: Tiles Provider not defined in the Provider Registry.", !1);
            }
            return !0;
        }
        class S extends c {
            constructor(){
                super(...arguments), this.redrawTiles = !1, this.isAnimating = !1;
            }
            static compose(e) {
                x(h, "TiledWebMapSeries") && d(e, "onRecommendMapView", M);
            }
            lonLatToTile(e, t) {
                let { lon: o, lat: r } = e;
                return {
                    x: Math.floor((o + 180) / 360 * Math.pow(2, t)),
                    y: Math.floor((1 - Math.log(Math.tan(r * Math.PI / 180) + 1 / Math.cos(r * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, t))
                };
            }
            tileToLonLat(e, t, o) {
                let r = e / Math.pow(2, o) * 360 - 180, i = Math.PI - 2 * Math.PI * t / Math.pow(2, o);
                return {
                    lon: r,
                    lat: 180 / Math.PI * Math.atan(.5 * (Math.exp(i) - Math.exp(-i)))
                };
            }
            drawPoints() {
                let e = this.chart, t = e.mapView;
                if (!t) return;
                let o = this.tiles = this.tiles || {}, r = this.transformGroups = this.transformGroups || [], i = this, s = this.options.provider, { zoom: a } = t, n = f(t.projection.options.rotation && t.projection.options.rotation[0], 0), l = e.renderer.forExport ? 0 : 200, m = (e)=>{
                    for (let r of Object.keys(o))parseFloat(r) === (t.zoom < 0 ? 0 : Math.floor(t.zoom)) || i.minZoom && (t.zoom < 0 ? 0 : Math.floor(t.zoom)) < i.minZoom && parseFloat(r) === i.minZoom || i.maxZoom && (t.zoom < 0 ? 0 : Math.floor(t.zoom)) > i.maxZoom && parseFloat(r) === i.maxZoom ? Object.keys(o[r].tiles).forEach((t, i)=>{
                        o[r].tiles[t].animate({
                            opacity: 1
                        }, {
                            duration: e
                        }, ()=>{
                            i === Object.keys(o[r].tiles).length - 1 && (o[r].isActive = !0);
                        });
                    }) : Object.keys(o[r].tiles).forEach((t, i)=>{
                        o[r].tiles[t].animate({
                            opacity: 0
                        }, {
                            duration: e,
                            defer: e / 2
                        }, ()=>{
                            o[r].tiles[t].destroy(), delete o[r].tiles[t], i === Object.keys(o[r].tiles).length - 1 && (o[r].isActive = !1, o[r].loaded = !1);
                        });
                    });
                }, h = a < 0 ? 0 : Math.floor(a), c = Math.pow(2, h), d = .638436911716859 * Math.pow(2, a) / (.638436911716859 * Math.pow(2, h)), g = 256 * d;
                if (s && (s.type || s.url)) {
                    if (s.type && !s.url) {
                        let o = p[s.type];
                        if (!y(o)) {
                            u("Highcharts warning: Tiles Provider '" + s.type + "' not defined in the ProviderRegistry.", !1);
                            return;
                        }
                        let r = new o, i = r.initialProjectionName, a, n = "";
                        if (s.theme && y(r.themes[s.theme])) a = r.themes[s.theme];
                        else {
                            let e = Object.keys(r.themes)[0];
                            a = r.themes[e], u("Highcharts warning: The Tiles Provider's Theme '" + s.theme + "' is not defined in the Provider definition - falling back to '" + e + "'.", !1);
                        }
                        s.subdomain && r.subdomains && -1 !== r.subdomains.indexOf(s.subdomain) ? n = s.subdomain : y(r.subdomains) && -1 !== a.url.indexOf("{s}") && (n = f(r.subdomains && r.subdomains[0], ""), u("Highcharts warning: The Tiles Provider's Subdomain '" + s.subdomain + "' is not defined in the Provider definition - falling back to '" + n + "'.", !1)), r.requiresApiKey && (s.apiKey ? a.url = a.url.replace("{apikey}", s.apiKey) : (u("Highcharts warning: The Tiles Provider requires API Key to use tiles, use provider.apiKey to provide a token.", !1), a.url = a.url.replace("?apikey={apikey}", ""))), s.url = a.url.replace("{s}", n), this.minZoom = a.minZoom, this.maxZoom = a.maxZoom;
                        let l = f(e.userOptions.credits && e.userOptions.credits.text, "Highcharts.com " + f(a.credits, r.defaultCredits));
                        e.credits ? e.credits.update({
                            text: l
                        }) : e.addCredits({
                            text: l,
                            style: f(e.options.credits?.style, {})
                        }), t.projection.options.name !== i && u("Highcharts warning: The set projection is different than supported by Tiles Provider.", !1);
                    } else t.projection.options.name || u("Highcharts warning: The set projection is different than supported by Tiles Provider.", !1);
                    if (y(this.minZoom) && h < this.minZoom ? (c = Math.pow(2, h = this.minZoom), g = 256 * (d = .638436911716859 * Math.pow(2, a) / (.638436911716859 * Math.pow(2, h)))) : y(this.maxZoom) && h > this.maxZoom && (c = Math.pow(2, h = this.maxZoom), g = 256 * (d = .638436911716859 * Math.pow(2, a) / (.638436911716859 * Math.pow(2, h)))), t.projection && t.projection.def) {
                        t.projection.hasCoordinates = !0, r[h] || (r[h] = e.renderer.g().add(this.group));
                        let a = (e, t, o, r)=>e.replace("{x}", t.toString()).replace("{y}", o.toString()).replace("{zoom}", r.toString()).replace("{z}", r.toString()), p = (n, p, h, d, y)=>{
                            let u = n % c, f = p % c, x = u < 0 ? u + c : u, M = f < 0 ? f + c : f;
                            if (!o[`${h}`].tiles[`${n},${p}`] && s.url) {
                                let c = a(s.url, x, M, h);
                                o[h].loaded = !1, o[`${h}`].tiles[`${n},${p}`] = e.renderer.image(c, n * g - d, p * g - y, g, g).attr({
                                    zIndex: 2,
                                    opacity: 0
                                }).on("load", function() {
                                    s.onload && s.onload.apply(this), (h === (t.zoom < 0 ? 0 : Math.floor(t.zoom)) || h === i.minZoom) && (o[`${h}`].actualTilesCount++, o[`${h}`].howManyTiles === o[`${h}`].actualTilesCount && (o[h].loaded = !0, i.isAnimating ? i.redrawTiles = !0 : (i.redrawTiles = !1, m(l)), o[`${h}`].actualTilesCount = 0));
                                }).add(r[h]), o[`${h}`].tiles[`${n},${p}`].posX = n, o[`${h}`].tiles[`${n},${p}`].posY = p, o[`${h}`].tiles[`${n},${p}`].originalURL = c;
                            }
                        }, d = t.pixelsToProjectedUnits({
                            x: 0,
                            y: 0
                        }), y = t.projection.def.inverse([
                            d.x,
                            d.y
                        ]), u = {
                            lon: y[0] - n,
                            lat: y[1]
                        }, f = t.pixelsToProjectedUnits({
                            x: e.plotWidth,
                            y: e.plotHeight
                        }), x = t.projection.def.inverse([
                            f.x,
                            f.y
                        ]), M = {
                            lon: x[0] - n,
                            lat: x[1]
                        };
                        (u.lat > t.projection.maxLatitude || M.lat < -1 * t.projection.maxLatitude) && (u.lat = t.projection.maxLatitude, M.lat = -1 * t.projection.maxLatitude);
                        let S = this.lonLatToTile(u, h), T = this.lonLatToTile(M, h), v = this.tileToLonLat(S.x, S.y, h), Z = t.projection.def.forward([
                            v.lon + n,
                            v.lat
                        ]), b = t.projectedUnitsToPixels({
                            x: Z[0],
                            y: Z[1]
                        }), w = S.x * g - b.x, j = S.y * g - b.y;
                        o[`${h}`] || (o[`${h}`] = {
                            tiles: {},
                            isActive: !1,
                            howManyTiles: 0,
                            actualTilesCount: 0,
                            loaded: !1
                        }), o[`${h}`].howManyTiles = (T.x - S.x + 1) * (T.y - S.y + 1), o[`${h}`].actualTilesCount = 0;
                        for(let e = S.x; e <= T.x; e++)for(let t = S.y; t <= T.y; t++)p(e, t, h, w, j);
                    }
                    for (let r of Object.keys(o))for (let s of Object.keys(o[r].tiles))if (t.projection && t.projection.def) {
                        let p = 256 * (.638436911716859 * Math.pow(2, a) / (.638436911716859 * Math.pow(2, parseFloat(r)))), c = o[r].tiles[Object.keys(o[r].tiles)[0]], { posX: d, posY: u } = o[r].tiles[s];
                        if (y(d) && y(u) && y(c.posX) && y(c.posY)) {
                            let a = this.tileToLonLat(c.posX, c.posY, parseFloat(r)), y = t.projection.def.forward([
                                a.lon + n,
                                a.lat
                            ]), g = t.projectedUnitsToPixels({
                                x: y[0],
                                y: y[1]
                            }), f = c.posX * p - g.x, x = c.posY * p - g.y;
                            if (e.renderer.globalAnimation && e.hasRendered) {
                                let e = Number(o[r].tiles[s].attr("x")), t = Number(o[r].tiles[s].attr("y")), a = Number(o[r].tiles[s].attr("width")), n = Number(o[r].tiles[s].attr("height")), h = (i, l)=>{
                                    o[r].tiles[s].attr({
                                        x: e + (d * p - f - e) * l.pos,
                                        y: t + (u * p - x - t) * l.pos,
                                        width: a + (Math.ceil(p) + 1 - a) * l.pos,
                                        height: n + (Math.ceil(p) + 1 - n) * l.pos
                                    });
                                };
                                i.isAnimating = !0, o[r].tiles[s].attr({
                                    animator: 0
                                }).animate({
                                    animator: 1
                                }, {
                                    step: h
                                }, function() {
                                    i.isAnimating = !1, i.redrawTiles && (i.redrawTiles = !1, m(l));
                                });
                            } else (i.redrawTiles || parseFloat(r) !== h || (o[r].isActive || parseFloat(r) === h) && Object.keys(o[r].tiles).map((e)=>o[r].tiles[e]).some((e)=>0 === e.opacity)) && (i.redrawTiles = !1, m(l)), o[r].tiles[s].attr({
                                x: d * p - f,
                                y: u * p - x,
                                width: Math.ceil(p) + 1,
                                height: Math.ceil(p) + 1
                            });
                        }
                    }
                } else u("Highcharts warning: Tiles Provider not defined in the Provider Registry.", !1);
            }
            update() {
                let { transformGroups: e } = this, t = this.chart, o = t.mapView, r = arguments[0], { provider: i } = r;
                if (e && (e.forEach((e)=>{
                    0 !== Object.keys(e).length && e.destroy();
                }), this.transformGroups = []), o && !y(t.userOptions.mapView?.projection) && i && i.type) {
                    let e = p[i.type];
                    if (e) {
                        let { initialProjectionName: t } = new e;
                        o.update({
                            projection: {
                                name: t
                            }
                        });
                    }
                }
                super.update.apply(this, arguments);
            }
        }
        S.defaultOptions = g(c.defaultOptions, {
            states: {
                inactive: {
                    enabled: !1
                }
            }
        }), m().registerSeriesType("tiledwebmap", S);
        let T = n();
        T.TilesProviderRegistry = T.TilesProviderRegistry || p, S.compose(T.MapView);
        let v = n();
        return s.default;
    })());
}}),
}]);

//# sourceMappingURL=node_modules_13d429._.js.map